<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-05-16T15:42:01.118Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 1916번 최소비용 구하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/17/algorithm1916/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/17/algorithm1916/</id>
    <published>2020-05-16T15:01:12.000Z</published>
    <updated>2020-05-16T15:42:01.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1916"><a href="#Problem-1916" class="headerlink" title="Problem 1916"></a>Problem 1916</h1><h2 id="최소비용-구하기"><a href="#최소비용-구하기" class="headerlink" title="최소비용 구하기"></a>최소비용 구하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.</p><p>그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1916" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1916</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>8<br>1 2 2<br>1 3 3<br>1 4 1<br>1 5 10<br>2 4 2<br>3 4 1<br>3 5 1<br>4 5 3<br>1 5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>다익스트라 알고리즘을 이용하여 해결하였다.</li><li>다익스트라 알고리즘 동작 방식</li></ul><ol><li>출발 노드를 설정한다.</li><li>출발 노드를 기준으로 각 노드의 최소 비용을 저장한다.</li><li>방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택한다.</li><li>해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신한다.</li><li>위 과정에서 3번 ~ 4번을 반복한다.</li></ol><hr><ul><li>거리를 기준으로 최소 힙의 구조로 동작하는 우선순위 큐로 사용하기 위해 최대 힙에 비용 값을 음수로 변환하여 저장한다.</li><li>현제 노드에서 가까운 순서대로 큐에서 꺼내어 더 짧은 거리일 경우에만 dist의 값을 갱신한다.<ul><li>큐에서 꺼낼 때는 음수를 양수로 바꾸어주고 넣을 때는 양수를 음수로 바꾸어 넣어준다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> dist[MAX];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">pq.push(make_pair(<span class="number">0</span>, start));</span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> cost = -pq.top().first; <span class="comment">// 비용 (최대 힙을 최소 힙처럼 사용하기 위해 음수로 저장된 수를 양수로 바꾸어 가져옴)</span></span><br><span class="line"><span class="keyword">int</span> node = pq.top().second; <span class="comment">// 현재 노드</span></span><br><span class="line">pq.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i].first;</span><br><span class="line"><span class="keyword">int</span> nextCost = a[node][i].second + cost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextCost &lt; dist[next]) &#123;</span><br><span class="line">dist[next] = nextCost;</span><br><span class="line">pq.push(make_pair(-nextCost, next)); <span class="comment">// 비용 (최대 힙을 최소 힙처럼 사용하기 위해 음수로 저장)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> start, <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">a[u].push_back(make_pair(v, w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start &gt;&gt; <span class="built_in">end</span>;</span><br><span class="line"><span class="built_in">fill</span>(dist, &amp;dist[n + <span class="number">1</span>], INT_MAX);</span><br><span class="line"></span><br><span class="line">dijkstra(start);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dist[<span class="built_in">end</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1916&quot;&gt;&lt;a href=&quot;#Problem-1916&quot; class=&quot;headerlink&quot; title=&quot;Problem 1916&quot;&gt;&lt;/a&gt;Problem 1916&lt;/h1&gt;&lt;h2 id=&quot;최소비용-구하기&quot;&gt;&lt;a href=&quot;#최소비용-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1753번 최단경로</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/15/algorithm1753/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/15/algorithm1753/</id>
    <published>2020-05-14T15:01:12.000Z</published>
    <updated>2020-05-14T15:06:33.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1753"><a href="#Problem-1753" class="headerlink" title="Problem 1753"></a>Problem 1753</h1><h2 id="최단경로"><a href="#최단경로" class="headerlink" title="최단경로"></a>최단경로</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1≤V≤20,000, 1≤E≤300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1≤K≤V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1753" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1753</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 6<br>1<br>5 1 1<br>1 2 2<br>1 3 3<br>2 3 4<br>2 4 5<br>3 4 6</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0<br>2<br>3<br>7<br>INF</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>다익스트라 알고리즘을 이용하여 해결하였다.</li><li>다익스트라 알고리즘 동작 방식</li></ul><ol><li>출발 노드를 설정한다.</li><li>출발 노드를 기준으로 각 노드의 최소 비용을 저장한다.</li><li>방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택한다.</li><li>해당 노드를 거쳐서 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신한다.</li><li>위 과정에서 3번 ~ 4번을 반복한다.</li></ol><hr><ul><li>거리를 기준으로 최소 힙의 구조로 동작하는 우선순위 큐를 선언한다.</li><li>현제 노드에서 가까운 순서대로 큐에서 꺼내어 더 짧은 거리일 경우에만 dist의 값을 갱신한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">20001</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a[MAX];</span><br><span class="line"><span class="keyword">int</span> dist[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstar</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">dist[start] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq; <span class="comment">// 최소 힙 구조로 선언</span></span><br><span class="line">pq.push(make_pair(<span class="number">0</span>, start)); <span class="comment">// 앞의 값을 기준으로 최소 힙 구성</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 가까운 순서대로 처리하므로 큐를 사용</span></span><br><span class="line"><span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> cost = pq.top().first;</span><br><span class="line"><span class="keyword">int</span> current = pq.top().second;</span><br><span class="line">pq.pop();</span><br><span class="line"><span class="comment">// 최단 거리가 아닌 경우 스킵</span></span><br><span class="line"><span class="keyword">if</span> (dist[current] &lt; cost) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[current].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">// 선택된 노드의 인접 노드</span></span><br><span class="line"><span class="keyword">int</span> next = a[current][i].first;</span><br><span class="line"><span class="comment">// 선택된 노드를 거쳐서 인접 노드로 가는 비용</span></span><br><span class="line"><span class="keyword">int</span> nextCost = cost + a[current][i].second;</span><br><span class="line"><span class="comment">// 기존의 최소 비용보다 더 저렴하다면 교체한다.</span></span><br><span class="line"><span class="keyword">if</span> (nextCost &lt; dist[next]) &#123;</span><br><span class="line">dist[next] = nextCost;</span><br><span class="line">pq.push(make_pair(nextCost, next));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v &gt;&gt; e;</span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fill</span>(dist, &amp;dist[v + <span class="number">1</span>], INF);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (e--) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, w;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">a[x].push_back(make_pair(y, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dijkstar(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[i] == INF) <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dist[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1753&quot;&gt;&lt;a href=&quot;#Problem-1753&quot; class=&quot;headerlink&quot; title=&quot;Problem 1753&quot;&gt;&lt;/a&gt;Problem 1753&lt;/h1&gt;&lt;h2 id=&quot;최단경로&quot;&gt;&lt;a href=&quot;#최단경로&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring - IoC 컨테이너, DI</title>
    <link href="https://kyu9341.github.io/java/2020/05/13/java_spring_IOC_DI/"/>
    <id>https://kyu9341.github.io/java/2020/05/13/java_spring_IOC_DI/</id>
    <published>2020-05-12T23:12:28.000Z</published>
    <updated>2020-05-12T23:48:06.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC-컨테이너-DI"><a href="#Spring-IoC-컨테이너-DI" class="headerlink" title="Spring - IoC 컨테이너, DI"></a>Spring - IoC 컨테이너, DI</h2><h3 id="IoC-Inversion-of-Control-제어의-역전"><a href="#IoC-Inversion-of-Control-제어의-역전" class="headerlink" title="IoC(Inversion of Control - 제어의 역전)"></a>IoC(Inversion of Control - 제어의 역전)</h3><ul><li><p>Inversion of Control : 의존 관계 주입(Dependency Injection)이라고도 하며, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법을 말함.</p><ul><li>작업을 수행하는 쪽에서 Object를 생성하는 제어 흐름의 개념을 거꾸로 뒤집는다.</li><li>IoC 에서는 Object가 자신이 사용할 Object를 생성하거나 선택하지 않는다.</li><li>또한 Object는 자신이 어떻게 생성되고 어떻게 사용되는지 알 수 없다.</li><li>모든 Object는 제어 권한을 위임받는 특별한 Object에 의해서 만들어지고 사용된다.</li></ul></li><li><p>제어의 역전이란 객체의 생성에서부터 생명주기의 관리까지 모든 객체애 대한 제어권이 바뀌었다는 것을 의미한다.</p></li><li><p>스프링이 모든 의존성 객체를 스프링이 실행될 때 다 만들어 주고 필요한 곳에 주입시켜줌으로써 Bean들은 싱글톤 패턴의 틀징을 가지며, 제어의 흐름을 사용자가 컨트롤하는 것이 아니라 스프링에게 맡겨 작업을 처리하게 된다.</p></li><li><p>목적</p><ul><li>객체 의존관계의 결합도를 낮추고 유지보수성을 향상시키기 위해</li></ul></li></ul><h3 id="IoC-구현-방법"><a href="#IoC-구현-방법" class="headerlink" title="IoC 구현 방법"></a>IoC 구현 방법</h3><h4 id="DL-Dependency-Lookup-의존성-검색"><a href="#DL-Dependency-Lookup-의존성-검색" class="headerlink" title="DL(Dependency Lookup) - 의존성 검색"></a>DL(Dependency Lookup) - 의존성 검색</h4><ul><li>저장소에 저장되어 있는 빈(Bean)에 접근하기 위해 개발자들이 컨테이너에서 제공하는 API를 이용하여 사용하고자 하는 빈을 Lookup하는 것<h4 id="DI-Dependency-Injection-의존성-주입"><a href="#DI-Dependency-Injection-의존성-주입" class="headerlink" title="DI(Dependency Injection) - 의존성 주입"></a>DI(Dependency Injection) - 의존성 주입</h4></li><li>각 계층 사이, 각 클래스 사이에 필요로 하는 의존 관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것</li><li>DL을 사용하면 컨테이너의 종속성이 생기게 되는데 이를 줄이기 위해 DI를 사용한다.<ul><li>Setter Injection : setter를 이용하여 클래스 사이의 의존 관계를 연결<ul><li>객체를 생성 후 의존성을 삽입하는 방식이기 때문에 구현 시 좀 더 유연하게 사용 가능</li><li>setter를 통하여 필요한 값이 할당되기 전까지는 객체를 사용할 수 없다.</li></ul></li><li>Constructor Injection : 생성자를 이용하여 클래스 사이의 의존 관계를 연결<ul><li>생성자에 파라미터를 지정함으로써 생성하고자 하는 객체가 필요로 하는 것을 명확하게 알 수 있다.</li><li>setter메서드를 사용하지 않으므로 간단하게 필드를 불변 값으로 지정이 가능하다.</li><li>생성자의 파라미터가 많을 경우 코드가 복잡해 보일 수 있다.</li></ul></li></ul></li></ul><hr><h3 id="컨테이너란"><a href="#컨테이너란" class="headerlink" title="컨테이너란?"></a>컨테이너란?</h3><ul><li>컨테이너는 보통 인스턴스의 생명주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 제공하는 것이다.</li><li>컨테이너는 적절한 설정만 되어있다면 작성된 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.</li></ul><h4 id="BeanFactory-빈팩토리"><a href="#BeanFactory-빈팩토리" class="headerlink" title="BeanFactory (빈팩토리)"></a>BeanFactory (빈팩토리)</h4><ul><li>애플리케이션 컴포넌트의 중앙 저장소, 스프링의 IoC를 담당하는 핵심 컨테이너.</li><li>빈 설정 소스로부터 빈 정의를 읽어들이고, 빈을 구성하고 제공한다.</li></ul><h4 id="ApplicationContext-애플리케이션-컨텍스트"><a href="#ApplicationContext-애플리케이션-컨텍스트" class="headerlink" title="ApplicationContext (애플리케이션 컨텍스트)"></a>ApplicationContext (애플리케이션 컨텍스트)</h4><ul><li>BeanFactory기능에 다양한 추가기능을 제공한다. (BeanFactory를 상속)<ul><li>국제화가 지원되는 텍스트 메시지 관리 기능</li><li>이벤트 발행 기능</li><li>리소스 로딩 기능</li></ul></li><li>대부분의 경우 BeanFactory보다는 ApplicationContext을 주로 사용한다.</li></ul><h4 id="빈-Bean-스프링-빈"><a href="#빈-Bean-스프링-빈" class="headerlink" title="빈(Bean) - 스프링 빈"></a>빈(Bean) - 스프링 빈</h4><ul><li>스프링 IoC 컨테이너가 관리하는 객체</li><li>스프링에서 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트</li><li>여러 annotation을 사용하여 일반적인 객체를 Bean으로 등록할 수 있고, Bean에 등록된 객체들을 쉽게 주입받아 사용 가능하다.</li><li>의존성 주입을 하기 위해서는 Bean으로 등록되어야 한다. (의존성 주입은 Bean끼리만 가능하다.)</li><li>라이프사이클 인터페이스를 이용 가능하다.</li></ul><blockquote><p>참조<br><a href="https://www.inflearn.com/course/spring-framework_core/dashboard" target="_blank" rel="external nofollow noopener noreferrer">https://www.inflearn.com/course/spring-framework_core/dashboard</a><br><a href="https://limmmee.tistory.com/13" target="_blank" rel="external nofollow noopener noreferrer">https://limmmee.tistory.com/13</a><br><a href="https://isstory83.tistory.com/91" target="_blank" rel="external nofollow noopener noreferrer">https://isstory83.tistory.com/91</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC-컨테이너-DI&quot;&gt;&lt;a href=&quot;#Spring-IoC-컨테이너-DI&quot; class=&quot;headerlink&quot; title=&quot;Spring - IoC 컨테이너, DI&quot;&gt;&lt;/a&gt;Spring - IoC 컨테이너, DI&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2665번 미로만들기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/12/algorithm2665/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/12/algorithm2665/</id>
    <published>2020-05-12T07:51:12.000Z</published>
    <updated>2020-05-12T07:56:20.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2665"><a href="#Problem-2665" class="headerlink" title="Problem 2665"></a>Problem 2665</h1><h2 id="미로만들기"><a href="#미로만들기" class="headerlink" title="미로만들기"></a>미로만들기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>n×n 바둑판 모양으로 총 n2개의 방이 있다. 일부분은 검은 방이고 나머지는 모두 흰 방이다. 검은 방은 사면이 벽으로 싸여 있어 들어갈 수 없다. 서로 붙어 있는 두 개의 흰 방 사이에는 문이 있어서 지나다닐 수 있다. 윗줄 맨 왼쪽 방은 시작방으로서 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로서 역시 흰 방이다.</p><p>시작방에서 출발하여 길을 찾아서 끝방으로 가는 것이 목적인데, 아래 그림의 경우에는 시작방에서 끝 방으로 갈 수가 없다. 부득이 검은 방 몇 개를 흰 방으로 바꾸어야 하는데 되도록 적은 수의 방의 색을 바꾸고 싶다.</p><p>아래 그림은 n=8인 경우의 한 예이다.</p><p>위 그림에서는 두 개의 검은 방(예를 들어 (4,4)의 방과 (7,8)의 방)을 흰 방으로 바꾸면, 시작방에서 끝방으로 갈 수 있지만, 어느 검은 방 하나만을 흰 방으로 바꾸어서는 불가능하다. 검은 방에서 흰 방으로 바꾸어야 할 최소의 수를 구하는 프로그램을 작성하시오.</p><p>단, 검은 방을 하나도 흰방으로 바꾸지 않아도 되는 경우는 0이 답이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 줄에는 한 줄에 들어가는 방의 수 n(1≤n≤50)이 주어지고, 다음 n개의 줄의 각 줄마다 0과 1이 이루어진 길이가 n인 수열이 주어진다. 0은 검은 방, 1은 흰 방을 나타낸다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫 줄에 흰 방으로 바꾸어야 할 최소의 검은 방의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2665" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2665</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8<br>11100110<br>11010010<br>10011010<br>11101100<br>01000111<br>00110001<br>11011000<br>11000111</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>흰 방으로 바꾸어야 하는 최소 개수만 구하면 되므로 visited배열에 현재 위치까지 오는데 검은 방을 흰 방으로 바꾸어야 하는 최소 개수를 저장한다.</li><li>bfs를 수행하며 더 적은 횟수로 현재 위치에 도달하는 경우만 값을 갱신하며 (n - 1, n - 1)까지 이동한다.</li><li>이후, visited[n - 1][n - 1]을 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> visited[MAX][MAX]; <span class="comment">// 현재 위치까지 최소로 방을 바꾸어야 하는 개수</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">place</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">place(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;x = x;</span><br><span class="line"><span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;place&gt; q;</span><br><span class="line">q.push(place(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front().x;</span><br><span class="line"><span class="keyword">int</span> y = q.front().y;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) &#123; <span class="comment">// 범위 내에서</span></span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span>) &#123; <span class="comment">// 흰 방인 경우</span></span><br><span class="line"><span class="comment">// 아직 방문하지 않았거나 더 적은 횟수로 이동 가능한 경우</span></span><br><span class="line"><span class="keyword">if</span> (visited[nx][ny] == <span class="number">-1</span> || visited[nx][ny] &gt; visited[x][y]) &#123;</span><br><span class="line">visited[nx][ny] = visited[x][y];</span><br><span class="line">q.push(place(nx, ny));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 검은 방인 경우</span></span><br><span class="line"><span class="comment">// 아직 방문하지 않았거나 더 적은 횟수로 이동 가능한 경우</span></span><br><span class="line"><span class="keyword">if</span> (visited[nx][ny] == <span class="number">-1</span> || visited[nx][ny] &gt; visited[x][y] + <span class="number">1</span>) &#123;</span><br><span class="line">visited[nx][ny] = visited[x][y] + <span class="number">1</span>;</span><br><span class="line">q.push(place(nx, ny));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">a[i][j] = str[j] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visited, <span class="number">-1</span>, <span class="keyword">sizeof</span>(visited));</span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; visited[n - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2665&quot;&gt;&lt;a href=&quot;#Problem-2665&quot; class=&quot;headerlink&quot; title=&quot;Problem 2665&quot;&gt;&lt;/a&gt;Problem 2665&lt;/h1&gt;&lt;h2 id=&quot;미로만들기&quot;&gt;&lt;a href=&quot;#미로만들기&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1644번 소수의 연속합</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/12/algorithm1644/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/12/algorithm1644/</id>
    <published>2020-05-11T15:51:12.000Z</published>
    <updated>2020-05-11T15:59:05.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1644"><a href="#Problem-1644" class="headerlink" title="Problem 1644"></a>Problem 1644</h1><h2 id="소수의-연속합"><a href="#소수의-연속합" class="headerlink" title="소수의 연속합"></a>소수의 연속합</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.</p><ul><li>3 : 3 (한 가지)</li><li>41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)</li><li>53 : 5+7+11+13+17 = 53 (두 가지)<br>하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.</li></ul><p>자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1644" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1644</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>에라토스테네스의 체로 n이하의 소수로 이루어진 벡터를 만든다.</p></li><li><p>소수들의 벡터에서 투포인터 알고리즘으로 합이 n이되는 경우의 수를 모두 구한다.</p></li><li><p><strong>[투 포인터 알고리즘]</strong></p></li><li><p>리스트에 순차적으로 접근해야 할 때 두 개의 점을 이용해 위치를 기록하면서 처리하는 기법</p></li></ul><ol><li>시작점(start)와 끝점(end)이 첫 번째 원소의 인덱스(0)을 가리키도록 한다.</li><li>현재 부분 합이 M과 같다면, 카운트한다.</li><li>현재 부분 합이 M보다 작거나 같다면, end를 1증가시킨다.</li><li>현재 부분 합이 M보다 크다면, start를 1증가시킨다.</li><li>모든 경우를 확인할 때까지 2번부터 4번까지의 과정을 반복한다.</li></ol><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">4000000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// 소수이면 false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">check[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 에라토스테네스의 체</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">prime.push_back(i); <span class="comment">// 소수들만 벡터에 추가</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) &#123;</span><br><span class="line">check[j] = <span class="literal">true</span>; <span class="comment">// 소수가 아니면 true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 소수의 벡터에서 투포인터 알고리즘</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; prime.<span class="built_in">size</span>(); start++) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">end</span> &lt; prime.<span class="built_in">size</span>() &amp;&amp; sum &lt; n) &#123;</span><br><span class="line">sum += prime[<span class="built_in">end</span>++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == n) ans++;</span><br><span class="line">sum -= prime[start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1644&quot;&gt;&lt;a href=&quot;#Problem-1644&quot; class=&quot;headerlink&quot; title=&quot;Problem 1644&quot;&gt;&lt;/a&gt;Problem 1644&lt;/h1&gt;&lt;h2 id=&quot;소수의-연속합&quot;&gt;&lt;a href=&quot;#소수의-연속
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2003번 수들의 합 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/12/algorithm2003/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/12/algorithm2003/</id>
    <published>2020-05-11T15:21:12.000Z</published>
    <updated>2020-05-11T15:24:25.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2003"><a href="#Problem-2003" class="headerlink" title="Problem 2003"></a>Problem 2003</h1><h2 id="수들의-합-2"><a href="#수들의-합-2" class="headerlink" title="수들의 합 2"></a>수들의 합 2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i]+A[i+1]+…+A[j-1]+A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1≤N≤10,000), M(1≤M≤300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 경우의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2003" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2003</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2<br>1 1 1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>10 5<br>1 2 3 4 2 5 3 1 1 2</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><strong>[투 포인터 알고리즘]</strong></li><li>리스트에 순차적으로 접근해야 할 때 두 개의 점을 이용해 위치를 기록하면서 처리하는 기법</li></ul><ol><li>시작점(start)와 끝점(end)이 첫 번째 원소의 인덱스(0)을 가리키도록 한다.</li><li>현재 부분 합이 M과 같다면, 카운트한다.</li><li>현재 부분 합이 M보다 작거나 같다면, end를 1증가시킨다.</li><li>현재 부분 합이 M보다 크다면, start를 1증가시킨다.</li><li>모든 경우를 확인할 때까지 2번부터 4번까지의 과정을 반복한다.</li></ol><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start를 차례로 증가시키며 반복</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line"><span class="keyword">while</span> (sum &lt; m &amp;&amp; <span class="built_in">end</span> &lt; n) &#123;</span><br><span class="line"><span class="comment">// end를 가능한 만큼 이동</span></span><br><span class="line">sum += a[<span class="built_in">end</span>++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 부분 합이 m일 때, 카운트 증가</span></span><br><span class="line"><span class="keyword">if</span> (sum == m) &#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">sum -= a[start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2003&quot;&gt;&lt;a href=&quot;#Problem-2003&quot; class=&quot;headerlink&quot; title=&quot;Problem 2003&quot;&gt;&lt;/a&gt;Problem 2003&lt;/h1&gt;&lt;h2 id=&quot;수들의-합-2&quot;&gt;&lt;a href=&quot;#수들의-합-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 호텔 방 배정</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/09/programmers_64063/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/09/programmers_64063/</id>
    <published>2020-05-09T04:11:12.000Z</published>
    <updated>2020-05-09T04:38:54.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로그래머스-호텔-방-배정"><a href="#프로그래머스-호텔-방-배정" class="headerlink" title="프로그래머스 - 호텔 방 배정"></a>프로그래머스 - 호텔 방 배정</h1><h2 id="호텔-방-배정"><a href="#호텔-방-배정" class="headerlink" title="호텔 방 배정"></a>호텔 방 배정</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]</p><p>스노우타운에서 호텔을 운영하고 있는 스카피는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 스카피는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.</p><ol><li>한 번에 한 명씩 신청한 순서대로 방을 배정합니다.</li><li>고객은 투숙하기 원하는 방 번호를 제출합니다.</li><li>고객이 원하는 방이 비어 있다면 즉시 배정합니다.</li><li>고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.<br>예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다.</li></ol><p>원하는 방 번호    배정된 방 번호<br>1    1<br>3    3<br>4    4<br>1    2<br>3    5<br>1    6<br>전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.</p><h3 id="제한사항"><a href="#제한사항" class="headerlink" title="[제한사항]"></a>[제한사항]</h3><ul><li>k는 1 이상 1012 이하인 자연수입니다.</li><li>room_number 배열의 크기는 1 이상 200,000 이하입니다.</li><li>room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.</li><li>room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.</li><li>예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="[입출력 예]"></a>[입출력 예]</h3><p>k    room_number    result<br>10    [1,3,4,1,3,1]    [1,3,4,2,5,6]</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://programmers.co.kr/learn/courses/30/lessons/64063" target="_blank" rel="external nofollow noopener noreferrer">https://programmers.co.kr/learn/courses/30/lessons/64063</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>유니온 파인드의 부모를 찾는 방식을 응용하여 원하는 방의 부모로 다음 방의 위치를 저장한다.</li><li>getParent함수를 사용하면 현재 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 찾을 수 있다.</li><li>또한 k의 범위가 10^12이므로 배열을 사용하면 메모리 초과가 날 것이므로 map을 사용하였다.<ul><li>맵에 없는 키 값에 접근하면 0을 받게 되므로 맵의 원하는 방의 번호를 키값으로 하여 접근하였을 때 0이라면 현재 방이 빈 방이라는 뜻이므로 현재 방을 할당하고 맵에 다음 방의 위치를 저장한다.</li><li>만약 원하는 방이 비어있지 않다면 getParent함수로 이어지는 다음 빈 방의 번호를 찾아 그 방을 할당하고, 맵에 그 방의 다음 위치를 저장한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getParent</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m[x] == <span class="number">0</span>) <span class="keyword">return</span> x; <span class="comment">// 다음 방이 비어있는 경우</span></span><br><span class="line"><span class="keyword">return</span> m[x] = getParent(m[x]); <span class="comment">// 다음 빈 방이 나올때 까지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; solution(<span class="keyword">long</span> <span class="keyword">long</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; room_number) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; answer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room_number.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">ll now = room_number[i];</span><br><span class="line"><span class="keyword">if</span> (m[now] == <span class="number">0</span>) &#123; <span class="comment">// 원하는 방번호 배정이 가능한 경우</span></span><br><span class="line">answer.push_back(now);</span><br><span class="line">m[now] = getParent(now + <span class="number">1</span>);  <span class="comment">// 다음 방의 위치 저장</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 불가능한 경우</span></span><br><span class="line">ll next = getParent(now); <span class="comment">// 다음 이어지는 빈 방의 번호를 찾는다.</span></span><br><span class="line">answer.push_back(next);</span><br><span class="line">m[next] = getParent(next + <span class="number">1</span>); <span class="comment">// 찾은 방의 다음 방의 위치 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로그래머스-호텔-방-배정&quot;&gt;&lt;a href=&quot;#프로그래머스-호텔-방-배정&quot; class=&quot;headerlink&quot; title=&quot;프로그래머스 - 호텔 방 배정&quot;&gt;&lt;/a&gt;프로그래머스 - 호텔 방 배정&lt;/h1&gt;&lt;h2 id=&quot;호텔-방-배정&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1976번 여행 가자</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/09/algorithm1976/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/09/algorithm1976/</id>
    <published>2020-05-08T16:11:12.000Z</published>
    <updated>2020-05-08T16:39:12.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1976"><a href="#Problem-1976" class="headerlink" title="Problem 1976"></a>Problem 1976</h1><h2 id="여행-가자"><a href="#여행-가자" class="headerlink" title="여행 가자"></a>여행 가자</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.</p><p>도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때(중복 가능) 가능한지 여부를 판별하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N * N 행렬을 통해 임의의 두 도시가 연결되었는지에 관한 정보가 주어진다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1717" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1717</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>3<br>0 1 0<br>1 0 1<br>0 1 0<br>1 2 3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>YES</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>유니온 파인드를 사용하여 주어지는 도시의 연결 정보에 따라 두 도시의 부모를 합친다.</li><li>이 후, 모든 도시가 같은 부모를 가지는지 확인하여 같은 부모를 가진다면 여행이 가능한 것이다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> parent[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 노드의 부모를 찾는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> parent[x] = getParent(parent[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 노드의 부모를 합치는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = getParent(x);</span><br><span class="line">y = getParent(y);</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) parent[y] = x;</span><br><span class="line"><span class="keyword">else</span> parent[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 노드의 부모가 같은지 확인하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = getParent(x);</span><br><span class="line">y = getParent(y);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 도시의 연결 정보에 따라 부모를 합친다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> input;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line"><span class="keyword">if</span> (input) &#123;</span><br><span class="line">unionParent(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모든 도시가 같은 부모를 가지는지 확인</span></span><br><span class="line"><span class="keyword">int</span> prev_parent;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> route;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; route;</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; prev_parent != parent[route]) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev_parent = parent[route];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1976&quot;&gt;&lt;a href=&quot;#Problem-1976&quot; class=&quot;headerlink&quot; title=&quot;Problem 1976&quot;&gt;&lt;/a&gt;Problem 1976&lt;/h1&gt;&lt;h2 id=&quot;여행-가자&quot;&gt;&lt;a href=&quot;#여행-가자&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1717번 집합의 표현</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/09/algorithm1717/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/09/algorithm1717/</id>
    <published>2020-05-08T15:11:12.000Z</published>
    <updated>2020-05-08T15:45:25.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1717"><a href="#Problem-1717" class="headerlink" title="Problem 1717"></a>Problem 1717</h1><h2 id="집합의-표현"><a href="#집합의-표현" class="headerlink" title="집합의 표현"></a>집합의 표현</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>초기에 {0}, {1}, {2}, … {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.</p><p>집합을 표현하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n(1≤n≤1,000,000), m(1≤m≤100,000)이 주어진다. m은 입력으로 주어지는 연산의 개수이다. 다음 m개의 줄에는 각각의 연산이 주어진다. 합집합은 0 a b의 형태로 입력이 주어진다. 이는 a가 포함되어 있는 집합과, b가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 1 a b의 형태로 입력이 주어진다. 이는 a와 b가 같은 집합에 포함되어 있는지를 확인하는 연산이다. a와 b는 n 이하의 자연수 또는 0이며 같을 수도 있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>1로 시작하는 입력에 대해서 한 줄에 하나씩 YES/NO로 결과를 출력한다. (yes/no 를 출력해도 된다)</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1717" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1717</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7 8<br>0 1 3<br>1 1 7<br>0 7 6<br>1 7 1<br>0 3 7<br>0 4 2<br>0 1 1<br>1 1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>NO<br>NO<br>YES</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>유니온 파인드 알고리즘의 기본 문제이다.</li><li>합집합 연산(0)은 유니온 파인드에서 두 부모를 합치는 연산을 수행하고,</li><li>두 원소가 같은 집합에 포함되어 있는지 여부는 두 노드의 부모가 같은지를 확인하면 된다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> parent[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 노드의 부모를 구하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> parent[x] = getParent(parent[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 노드의 부모를 합치는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = getParent(x);</span><br><span class="line">y = getParent(y);</span><br><span class="line"><span class="keyword">if</span> (x &lt; y) parent[y] = x;</span><br><span class="line"><span class="keyword">else</span> parent[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 노드의 부모가 일치하는지 확인하는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = getParent(x);</span><br><span class="line">y = getParent(y);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> op, a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">0</span>) &#123; <span class="comment">// 0인 경우 부모를 합친다.</span></span><br><span class="line">unionParent(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) &#123; <span class="comment">// 1인 경우 부모가 일치하는지 확인한다.</span></span><br><span class="line"><span class="keyword">if</span> (findParent(a, b)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1717&quot;&gt;&lt;a href=&quot;#Problem-1717&quot; class=&quot;headerlink&quot; title=&quot;Problem 1717&quot;&gt;&lt;/a&gt;Problem 1717&lt;/h1&gt;&lt;h2 id=&quot;집합의-표현&quot;&gt;&lt;a href=&quot;#집합의-표현&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 징검다리 건너기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/08/programmers_64062/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/08/programmers_64062/</id>
    <published>2020-05-08T13:11:12.000Z</published>
    <updated>2020-05-08T13:22:55.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로그래머스-징검다리-건너기"><a href="#프로그래머스-징검다리-건너기" class="headerlink" title="프로그래머스 - 징검다리 건너기"></a>프로그래머스 - 징검다리 건너기</h1><h2 id="징검다리-건너기"><a href="#징검다리-건너기" class="headerlink" title="징검다리 건너기"></a>징검다리 건너기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]</p><p>카카오 초등학교의 니니즈 친구들이 라이언 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. 라이언 선생님은 니니즈 친구들이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.</p><ul><li>징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.</li><li>디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.</li><li>단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.<br>니니즈 친구들은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.<br>니니즈 친구들은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.</li></ul><p>디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.</p><h3 id="제한사항"><a href="#제한사항" class="headerlink" title="[제한사항]"></a>[제한사항]</h3><p>징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.<br>stones 배열의 크기는 1 이상 200,000 이하입니다.<br>stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.<br>k는 1 이상 stones의 길이 이하인 자연수입니다.</p><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="[입출력 예]"></a>[입출력 예]</h3><p>stones    k    result<br>[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]    3    3</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://programmers.co.kr/learn/courses/30/lessons/64062" target="_blank" rel="external nofollow noopener noreferrer">https://programmers.co.kr/learn/courses/30/lessons/64062</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있으므로</li><li>연속되는 k개의 돌의 숫자가 건너려는 인원 수보다 작지 않은 최대의 경우가 정답이 된다.</li><li>인원 수는 최대 2억이므로 인원 수를 기준으로 이분 탐색을 수행한다.<ul><li>현재 인원 수가 돌의 숫자보다 더 큰 경우가 k번 이상 연속된다면 불가능하므로 false를 리턴하고</li><li>돌의 숫자가 0이되는 경우가 k번 이상 연속되지 않는다면 가능하므로 true를 리턴하도록 함수를 작성한다.</li><li>true인 경우 더 큰 인원으로 가능한지 확인하고 false인 경우 더 적은 인원인 경우를 확인한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stones, <span class="keyword">int</span> k, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="comment">// 현재 인원 수가 돌의 숫자보다 더 큰 경우가 k번 이상 연속된다면 불가능</span></span><br><span class="line"><span class="keyword">if</span> (stones[i] &lt; mid) &#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 돌의 숫자가 0이되는 경우가 k번 이상 연속되지 않는다면 가능</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stones, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> right = * max_element(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 징검다리를 건너는 인원 수를 기준으로 이분탐색</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(stones, k, mid)) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (answer &lt; mid) &#123;</span><br><span class="line">answer = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로그래머스-징검다리-건너기&quot;&gt;&lt;a href=&quot;#프로그래머스-징검다리-건너기&quot; class=&quot;headerlink&quot; title=&quot;프로그래머스 - 징검다리 건너기&quot;&gt;&lt;/a&gt;프로그래머스 - 징검다리 건너기&lt;/h1&gt;&lt;h2 id=&quot;징검다리-건너기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 불량 사용자</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/08/programmers_64064/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/08/programmers_64064/</id>
    <published>2020-05-08T10:01:12.000Z</published>
    <updated>2020-05-08T10:03:18.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로그래머스-불량-사용자"><a href="#프로그래머스-불량-사용자" class="headerlink" title="프로그래머스 - 불량 사용자"></a>프로그래머스 - 불량 사용자</h1><h2 id="불량-사용자"><a href="#불량-사용자" class="headerlink" title="불량 사용자"></a>불량 사용자</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>개발팀 내에서 이벤트 개발을 담당하고 있는 무지는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 프로도 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 ‘*‘ 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 ‘*‘ 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 ‘*‘ 문자를 사용하였습니다.<br>무지와 프로도는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다.</p><p>예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면</p><p>응모자 아이디<br>frodo<br>fradi<br>crodo<br>abc123<br>frodoc<br>다음과 같이 불량 사용자 아이디 목록이 전달된 경우,</p><p>불량 사용자<br>fr<em>d</em><br>abc1**<br>불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다.</p><p>제재 아이디<br>frodo<br>abc123<br>제재 아이디<br>fradi<br>abc123<br>이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.</p><h3 id="제한사항"><a href="#제한사항" class="headerlink" title="[제한사항]"></a>[제한사항]</h3><ul><li>user_id 배열의 크기는 1 이상 8 이하입니다.</li><li>user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.<ul><li>응모한 사용자 아이디들은 서로 중복되지 않습니다.</li><li>응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.</li></ul></li><li>banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.</li><li>banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.<ul><li>불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 ‘*‘ 로만 이루어져 있습니다.</li><li>불량 사용자 아이디는 ‘*‘ 문자를 하나 이상 포함하고 있습니다.</li><li>불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.</li></ul></li><li>제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><p>user_id    banned_id    result<br>[“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]    [“fr<em>d</em>“, “abc1<strong>“]    2<br>[“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]    [“*rodo”, “*rodo”, “****</strong>“]    2<br>[“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]    [“fr<em>d</em>“, “*rodo”, “<strong>**</strong>“, “<strong>**</strong>“]    3</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://programmers.co.kr/learn/courses/30/lessons/64064" target="_blank" rel="external nofollow noopener noreferrer">https://programmers.co.kr/learn/courses/30/lessons/64064</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>불량 사용자 아이디에 가능한 유저 후보를 cand벡터의 해당하는 인덱스에 담는다.</li><li>이후 가능한 후보들 중에서 중복되지 않는 경우를 구한다.<ul><li>가능한 경우에 res라는 set에 insert하고 재귀를 수행하여 가능한 제제 아이디 목록을 구한다.</li><li>set은 자동으로 정렬이 되므로 res를 s라는 set<string>을 담는 set에 넣어 중복인 경우가 없도록 한다.</string></li></ul></li><li>s의 size를 answer에 넣어 반환한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cand[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 가능한 후보들 중에서 중복되지 않는 경우를 구한다.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> banned_size, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; res)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == banned_size) &#123;</span><br><span class="line">s.insert(res); <span class="comment">// set을 set에 넣어 중복되는 경우가 없도록 한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cand[index].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (m[cand[index][i]]) <span class="keyword">continue</span>; <span class="comment">// 이미 선택된 user_id인 경우 건너뜀</span></span><br><span class="line">res.insert(cand[index][i]);</span><br><span class="line">m[cand[index][i]] = <span class="literal">true</span>;</span><br><span class="line">go(index + <span class="number">1</span>, banned_size, res);</span><br><span class="line">m[cand[index][i]] = <span class="literal">false</span>;</span><br><span class="line">res.erase(cand[index][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; user_id, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; banned_id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 불량 사용자 아이디에 가능한 유저 후보를 cand벡터의 해당하는 인덱스에 담는다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; banned_id.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; user_id.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (banned_id[i].<span class="built_in">size</span>() != user_id[j].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">bool</span> check = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; banned_id[i].<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (banned_id[i][k] == <span class="string">'*'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (banned_id[i][k] != user_id[j][k]) &#123;</span><br><span class="line">check = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check) &#123;</span><br><span class="line">cand[i].push_back(user_id[j]); <span class="comment">// 가능한 후보인 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_id.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">m[user_id[i]] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">go(<span class="number">0</span>, banned_id.<span class="built_in">size</span>(), res);</span><br><span class="line"></span><br><span class="line">answer = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로그래머스-불량-사용자&quot;&gt;&lt;a href=&quot;#프로그래머스-불량-사용자&quot; class=&quot;headerlink&quot; title=&quot;프로그래머스 - 불량 사용자&quot;&gt;&lt;/a&gt;프로그래머스 - 불량 사용자&lt;/h1&gt;&lt;h2 id=&quot;불량-사용자&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 튜플</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/08/programmers_64065/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/08/programmers_64065/</id>
    <published>2020-05-08T06:11:12.000Z</published>
    <updated>2020-05-08T07:43:25.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로그래머스-튜플"><a href="#프로그래머스-튜플" class="headerlink" title="프로그래머스 - 튜플"></a>프로그래머스 - 튜플</h1><h2 id="튜플"><a href="#튜플" class="headerlink" title="튜플"></a>튜플</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.</p><ul><li><code>(a1, a2, a3, ..., an)</code><br>튜플은 다음과 같은 성질을 가지고 있습니다.</li></ul><ol><li>중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)</li><li>원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)</li><li>튜플의 원소 개수는 유한합니다.</li></ol><p>특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://programmers.co.kr/learn/courses/30/lessons/64065" target="_blank" rel="external nofollow noopener noreferrer">https://programmers.co.kr/learn/courses/30/lessons/64065</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>주어진 문자열로 이루어진 집합을 벡터로 변환한다.</li><li>벡터의 크기순으로 오름차순 정렬을 한다.<ul><li>그러면 크기가 1인 벡터부터 튜플의 원소의 개수까지 차례로 존재할 것이다.</li></ul></li><li>check배열에 수의 중복을 체크하여 중복이 아닌 수가 나온다면 answer에 추가한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="comment">// 문자열로 된 집합을 벡터로 변환</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">""</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">2</span>) &#123;</span><br><span class="line">tmp.push_back(stoi(num));</span><br><span class="line">num = <span class="string">""</span>;</span><br><span class="line">a.push_back(tmp);</span><br><span class="line">tmp.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">cnt--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">','</span>) &#123;</span><br><span class="line">tmp.push_back(stoi(num));</span><br><span class="line">num = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">num += s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solution(<span class="built_in">string</span> s) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; answer;</span><br><span class="line">init(s); <span class="comment">// 문자열을 벡터로 변환</span></span><br><span class="line"><span class="comment">// 벡터의 크기 순으로 오름차순 정렬</span></span><br><span class="line">sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; u, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v) &#123;</span><br><span class="line"><span class="keyword">return</span> u.<span class="built_in">size</span>() &lt; v.<span class="built_in">size</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 크기가 1인 벡터부터 중복이 아닌 수가 나오는 경우 answer에 추가</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!check[a[i][j]]) &#123;</span><br><span class="line">answer.push_back(a[i][j]);</span><br><span class="line">check[a[i][j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로그래머스-튜플&quot;&gt;&lt;a href=&quot;#프로그래머스-튜플&quot; class=&quot;headerlink&quot; title=&quot;프로그래머스 - 튜플&quot;&gt;&lt;/a&gt;프로그래머스 - 튜플&lt;/h1&gt;&lt;h2 id=&quot;튜플&quot;&gt;&lt;a href=&quot;#튜플&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Java - 제네릭(Generic)</title>
    <link href="https://kyu9341.github.io/java/2020/05/08/java_Generic/"/>
    <id>https://kyu9341.github.io/java/2020/05/08/java_Generic/</id>
    <published>2020-05-07T16:12:28.000Z</published>
    <updated>2020-05-07T16:37:09.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-제네릭-Generic"><a href="#Java-제네릭-Generic" class="headerlink" title="Java - 제네릭(Generic)"></a>Java - 제네릭(Generic)</h2><ul><li>제네릭(Generic)은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 말한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> T info;</span><br><span class="line">&#125;</span><br><span class="line">Person&lt;String&gt; p1 = <span class="keyword">new</span> Person&lt;String&gt;();</span><br><span class="line">Person&lt;StringBuilder&gt; p2 = <span class="keyword">new</span> Person&lt;StringBuilder&gt;();</span><br></pre></td></tr></table></figure><ul><li>위와 같이 사용한다면 외부에서 생성한 객체의 타입을 &lt;&gt;에 정의함으로써 Person클래스의 info라는 필드의 타입이 정의되는 것이다.<ul><li>p1으로 객체를 생성한다면 info의 데이터 타입은 String이 되는 것이고,</li><li>p2로 객체를 생성한다면  info의 데이터 타입은 StringBuilder이 되는 것이다.</li></ul></li></ul><hr><ul><li><code>&lt;T&gt;</code>의 위치에는 레퍼런스 형만 올 수 있고, 기본 데이터 타입((primitive type) =&gt; int, char 등..)은 제네릭으로 사용할 수 없다.(기본 데이터 타입은 객체가 아님)</li><li>따라서, 기본 데이터 타입을 객체인 것처럼 만들 수 있는 객체를 제공하는 wrapper 클래스를 사용한다.<ul><li><code>int -&gt; Integer</code>, <code>double -&gt; Double</code> …와 같이 사용</li><li><code>Integer id = new Integer(1);</code> 와 같이 생성하여 생성자의 매개변수로 넘길 수 있다.</li><li><code>p1.id.intValue()</code>와 같이 wrapper 클래스(Integer)의 메서드를 사용하여 wrapper 클래스가 담고 있는 원시 데이터 타입으로 반환 받을 수 있다.</li></ul></li></ul><h3 id="제네릭의-생략"><a href="#제네릭의-생략" class="headerlink" title="제네릭의 생략"></a>제네릭의 생략</h3><ul><li>다음과 같은 경우 제네릭은 생략 가능하다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T info;</span><br><span class="line">    <span class="keyword">public</span> S id;</span><br><span class="line">    Person(T info, S id)&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EmployeeInfo ei = <span class="keyword">new</span> EmployeeInfo(<span class="number">1</span>);</span><br><span class="line">        Integer id = <span class="number">10</span>;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(ei, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>이 경우, 이미 ei와 id의 타입을 자바가 알고 있기 때문에 제네릭을 생략할 수 있다.</li></ul><h3 id="제네릭의-제한"><a href="#제네릭의-제한" class="headerlink" title="제네릭의 제한"></a>제네릭의 제한</h3><ul><li><code>&lt;T extends Info&gt;</code>와 같은 형태로 사용<ul><li><code>Info</code>클래스 또는 인터페이스를 상속받는 클래스의 데이터 타입인 경우로 제한한다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeInfo</span> <span class="keyword">extends</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rank;</span><br><span class="line">    EmployeeInfo(<span class="keyword">int</span> rank)&#123;</span><br><span class="line">       <span class="keyword">this</span>.rank = rank;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.rank;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Info</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T info;</span><br><span class="line">    Person(T info)&#123;</span><br><span class="line">       <span class="keyword">this</span>.info = info;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person&lt;EmployeeInfo&gt; p1 = <span class="keyword">new</span> Person&lt;EmployeeInfo&gt;(<span class="keyword">new</span> EmployeeInfo(<span class="number">1</span>));</span><br><span class="line">        Person&lt;String&gt; p2 = <span class="keyword">new</span> Person&lt;String&gt;(<span class="string">"부장"</span>); <span class="comment">// 이 경우에는 에러</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><code>Person&lt;EmployeeInfo&gt; p1 = new Person&lt;EmployeeInfo&gt;(new EmployeeInfo(1));</code>와 같이 <code>Info</code>를 상속받는 <code>EmployeeInfo</code>타입인 경우에는 정상적으로 사용이 가능하지만</li><li><code>Person&lt;String&gt; p2 = new Person&lt;String&gt;(&quot;부장&quot;);</code>와 같이 <code>String</code>타입인 경우 에러가 발생하게 된다.</li><li>즉, <code>class Person&lt;T extends Info&gt;{</code>에서 T에는 Info 클래스 혹은 그 자식만이 올 수 있다.</li><li><code>abstract class Info{</code> 같은 경우 추상 클래스가 아니라 일반 클래스 혹인 인터페이스인 경우에도 동일하다.<ul><li><code>Info</code>가 인터페이스라고 해서 <code>T extends Info&gt;</code>의 부분이 implements로 변한다거나 하지는 않는다.</li></ul></li></ul><h3 id="제네릭의-장점"><a href="#제네릭의-장점" class="headerlink" title="제네릭의 장점"></a>제네릭의 장점</h3><ul><li>타입 안정성을 제공한다.(의도하지 않은 타입의 객체를 저장하는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 형변환하여 발생할 수 있는 오류를 줄인다.)</li><li>타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.<ul><li>다룰 객체의 타입을 미리 명시함으로써 형변환을 하지 않아도 되도록 하는 것이다.</li><li>기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴 타입으로 Object타입의 참조 변수를 많이 사용했고, 그로 인해 형변환이 불가피했지만, 이젠 Object타입 대신 원하는 타입을 지정해주기만 하면 되는 것이다.</li></ul></li></ul><blockquote><p>참조<br><a href="https://devbox.tistory.com/entry/Java-%EC%A0%9C%EB%84%A4%EB%A6%AD" target="_blank" rel="external nofollow noopener noreferrer">https://devbox.tistory.com/entry/Java-%EC%A0%9C%EB%84%A4%EB%A6%AD</a><br><a href="https://www.youtube.com/watch?v=YUinFIexEQ4" target="_blank" rel="external nofollow noopener noreferrer">https://www.youtube.com/watch?v=YUinFIexEQ4</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-제네릭-Generic&quot;&gt;&lt;a href=&quot;#Java-제네릭-Generic&quot; class=&quot;headerlink&quot; title=&quot;Java - 제네릭(Generic)&quot;&gt;&lt;/a&gt;Java - 제네릭(Generic)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;제네
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>프로그래머스 - 크레인 인형뽑기 게임</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/08/programmers_64061/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/08/programmers_64061/</id>
    <published>2020-05-07T15:11:12.000Z</published>
    <updated>2020-05-07T15:37:25.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로그래머스-크레인-인형뽑기-게임"><a href="#프로그래머스-크레인-인형뽑기-게임" class="headerlink" title="프로그래머스 - 크레인 인형뽑기 게임"></a>프로그래머스 - 크레인 인형뽑기 게임</h1><h2 id="크레인-인형뽑기-게임"><a href="#크레인-인형뽑기-게임" class="headerlink" title="크레인 인형뽑기 게임"></a>크레인 인형뽑기 게임</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.<br>죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.</p><p>게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.</p><p>만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.</p><p>크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)</p><p>게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.</p><h3 id="제한사항"><a href="#제한사항" class="headerlink" title="[제한사항]"></a>[제한사항]</h3><ul><li>board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.</li><li>board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.<ul><li>0은 빈 칸을 나타냅니다.</li><li>1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.</li></ul></li><li>moves 배열의 크기는 1 이상 1,000 이하입니다.</li><li>moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.</li></ul><h3 id="입출력-예"><a href="#입출력-예" class="headerlink" title="입출력 예"></a>입출력 예</h3><p>board    moves    result<br>[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]    [1,5,3,5,1,2,1,4]    4</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://programmers.co.kr/learn/courses/30/lessons/64061" target="_blank" rel="external nofollow noopener noreferrer">https://programmers.co.kr/learn/courses/30/lessons/64061</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>크레인의 위치를 현재 moves배열의 위치의 맨 위부터 0이 아닌 수를 만날 때까지(인형) 하나씩 내려온다.</li><li>인형을 만난 경우 스택(바구니)에 넣어준다.<ul><li>이 때, 바구니의 맨 위(s.top())에 현재 인형과 같은 인형이 있다면 s.pop()을 하여 두 인형을 제거하고 answer에 2를 누적한다.</li><li>같은 인형이 아니라면 스택에 푸쉬를 한다.</li><li>인형을 뽑은 후에 뽑은 자리는 0으로 바꿔주고 현재 반복문을 나간다.</li></ul></li><li>위의 과정을 반복하여 총 몇 개의 인형이 터졌는지 반환한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; moves)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moves.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line"><span class="keyword">int</span> now = board[j][moves[i] - <span class="number">1</span>];  <span class="comment">// 집게의 현재 위치</span></span><br><span class="line"><span class="keyword">if</span> (now != <span class="number">0</span>) &#123; <span class="comment">// 인형을 만난 경우</span></span><br><span class="line"><span class="keyword">if</span> (!s.empty() &amp;&amp; s.top() == now) &#123; <span class="comment">// 바구니에 같은 인형이 연속으로 담기는 경우</span></span><br><span class="line">s.pop();</span><br><span class="line">answer += <span class="number">2</span>; <span class="comment">// 2개 터짐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s.push(now);</span><br><span class="line">&#125;</span><br><span class="line">board[j][moves[i] - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 인형을 뽑은 자리는 0으로 채움</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;프로그래머스-크레인-인형뽑기-게임&quot;&gt;&lt;a href=&quot;#프로그래머스-크레인-인형뽑기-게임&quot; class=&quot;headerlink&quot; title=&quot;프로그래머스 - 크레인 인형뽑기 게임&quot;&gt;&lt;/a&gt;프로그래머스 - 크레인 인형뽑기 게임&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17144번 미세먼지 안녕!</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/06/algorithm17144/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/06/algorithm17144/</id>
    <published>2020-05-06T02:51:12.000Z</published>
    <updated>2020-05-06T03:49:44.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17144"><a href="#Problem-17144" class="headerlink" title="Problem 17144"></a>Problem 17144</h1><h2 id="미세먼지-안녕"><a href="#미세먼지-안녕" class="headerlink" title="미세먼지 안녕!"></a>미세먼지 안녕!</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다.</p><p>공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 Ar,c이다.</p><p>1초 동안 아래 적힌 일이 순서대로 일어난다.</p><ol><li>미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다.<ul><li>(r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다.</li><li>인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다.</li><li>확산되는 양은 Ar,c/5이고 소수점은 버린다.</li><li>(r, c)에 남은 미세먼지의 양은 Ar,c - (Ar,c/5)×(확산된 방향의 개수) 이다.</li></ul></li><li>공기청정기가 작동한다.<ul><li>공기청정기에서는 바람이 나온다.</li><li>위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다.</li><li>바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다.</li><li>공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다.<br>다음은 확산의 예시이다.</li></ul></li></ol><p>왼쪽과 오른쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다.</p><p>인접한 네 방향으로 모두 확산이 일어난다.</p><p>공기청정기가 있는 칸으로는 확산이 일어나지 않는다.</p><p>공기청정기의 바람은 다음과 같은 방향으로 순환한다.</p><p>방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 R, C, T (6 ≤ R, C ≤ 50, 1 ≤ T ≤ 1,000) 가 주어진다.</p><p>둘째 줄부터 R개의 줄에 Ar,c (-1 ≤ Ar,c ≤ 1,000)가 주어진다. 공기청정기가 설치된 곳은 Ar,c가 -1이고, 나머지 값은 미세먼지의 양이다. -1은 2번 위아래로 붙어져 있고, 가장 윗 행, 아랫 행과 두 칸이상 떨어져 있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 T초가 지난 후 구사과 방에 남아있는 미세먼지의 양을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17144" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17144</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7 8 1<br>0 0 0 0 0 0 0 9<br>0 0 0 0 3 0 0 8<br>-1 0 5 0 0 0 22 0<br>-1 8 0 0 0 0 0 0<br>0 0 0 0 0 10 43 0<br>0 0 5 0 15 0 0 0<br>0 0 40 0 0 0 20 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>188</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>미세먼지를 확산시키는 함수 spread()를 만든다.<ul><li>4방향으로 확산이 일어나지만 공기청정기의 칸과 벽으로는 확산이 되지 않는다.</li><li>따라서, 공기청정기와 벽인 경우를 제외하고 (현재 위치의 양 / 5) 를 하여 옆 칸으로 퍼뜨리고 확산된 양 만큼만 현재 칸에서 빼준다.</li><li>이 때, 옆 칸에서 확산이 일어난 뒤 그 결과를 가지고 현재 칸에서 확산이 되면 안되기 때문에 확산을 한번에 일어나게 한다.</li><li>현재 칸에 줄어든 값만 저장한 뒤,</li><li>tmp배열에 각 칸에서 확산되어 퍼진 미세먼지의 양을 누적한 뒤 한번에 원래의 배열에 더해준다.</li></ul></li><li>확산시키는 함수를 구현하였으니 공기청정기에 의해 미세먼지를 이동시키는 함수를 구현한다.<ul><li>미세먼지의 이동을 구현하기 위해 공기청정기와 가까운 칸부터 시작하여 공기청정기의 바람이 나오는 부분까지 땡겨주는 식으로 이동시킨다.</li></ul></li><li>이 후 t초 만큼 확산과 이동을 반복한 뒤 미세먼지의 합을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> tmp[MAX][MAX]; <span class="comment">// 한번에 확산이 이루어지게 하기 위해 사용할 임시 배열</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> r, c, t;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cleaner; <span class="comment">// 공기청정기 위치</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="comment">// 출력 함수</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; r; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; c; y++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[x][y] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wind</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 위칸 공기청정기 동작</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cleaner[<span class="number">0</span>] - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 0열 아래로 이동</span></span><br><span class="line">a[i][<span class="number">0</span>] = a[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c - <span class="number">1</span>; i++) &#123; <span class="comment">// 0행 왼쪽으로 이동</span></span><br><span class="line">a[<span class="number">0</span>][i] = a[<span class="number">0</span>][i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cleaner[<span class="number">0</span>]; i++) &#123; <span class="comment">// c - 1열 위로 이동</span></span><br><span class="line">a[i][c - <span class="number">1</span>] = a[i + <span class="number">1</span>][c - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">// 공기청정기 윗부분 행 오른쪽으로 이동</span></span><br><span class="line">a[cleaner[<span class="number">0</span>]][i] = a[cleaner[<span class="number">0</span>]][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">a[cleaner[<span class="number">0</span>]][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래칸 공기청정기 동작</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cleaner[<span class="number">1</span>] + <span class="number">1</span>; i &lt; r - <span class="number">1</span>; i++) &#123; <span class="comment">// 0열 위로 이동</span></span><br><span class="line">a[i][<span class="number">0</span>] = a[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c - <span class="number">1</span>; i++) &#123; <span class="comment">// r - 1행 왼쪽으로 이동</span></span><br><span class="line">a[r - <span class="number">1</span>][i] = a[r - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">1</span>; i &gt; cleaner[<span class="number">1</span>]; i--) &#123; <span class="comment">// c - 1열 아래로 이동</span></span><br><span class="line">a[i][c - <span class="number">1</span>] = a[i - <span class="number">1</span>][c - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = c - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">// 공기청정기 아랫부분 행 오른쪽으로 이동</span></span><br><span class="line">a[cleaner[<span class="number">1</span>]][i] = a[cleaner[<span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">a[cleaner[<span class="number">1</span>]][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 미세먼지 확산</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; r; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; c; y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[k];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[k];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= r || ny &gt;= c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">tmp[nx][ny] += a[x][y] / <span class="number">5</span>;</span><br><span class="line">sum += a[x][y] / <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a[x][y] -= sum; <span class="comment">// 확산된 양만큼 빼줌</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; r; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; c; y++) &#123;</span><br><span class="line">a[x][y] += tmp[x][y]; <span class="comment">// 확산된 양을 한번에 더해줌</span></span><br><span class="line">tmp[x][y] = <span class="number">0</span>; <span class="comment">// tmp 초기화</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">-1</span>) cleaner.push_back(i); <span class="comment">// 공기 청정기 위치 저장</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line">spread(); <span class="comment">// 확산</span></span><br><span class="line">wind(); <span class="comment">// 이동</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; r; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">ans += a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">ans += <span class="number">2</span>; <span class="comment">// 공기 청정기 제거</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17144&quot;&gt;&lt;a href=&quot;#Problem-17144&quot; class=&quot;headerlink&quot; title=&quot;Problem 17144&quot;&gt;&lt;/a&gt;Problem 17144&lt;/h1&gt;&lt;h2 id=&quot;미세먼지-안녕&quot;&gt;&lt;a href=&quot;#미세
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>스프링 부트 - 자동 로그인 (RememberMe)</title>
    <link href="https://kyu9341.github.io/java/2020/05/06/java_springBootAutoLogin/"/>
    <id>https://kyu9341.github.io/java/2020/05/06/java_springBootAutoLogin/</id>
    <published>2020-05-05T16:12:28.000Z</published>
    <updated>2020-05-12T15:18:15.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="스프링-부트-자동-로그인-RememberMe"><a href="#스프링-부트-자동-로그인-RememberMe" class="headerlink" title="스프링 부트 - 자동 로그인 (RememberMe)"></a>스프링 부트 - 자동 로그인 (RememberMe)</h2><ul><li>로그인을 하면 자동으로 JSESSEIONID가 생성된다.<ul><li>JSESSEIONID는 웹 브라우저와 서버와의 연결고리이다.</li></ul></li><li>기본 세션의 timeout 값은 30분이다.(톰캣)</li></ul><h5 id="세션이-만료되더라도-로그인을-유지하고-싶을-때-사용하는-방법"><a href="#세션이-만료되더라도-로그인을-유지하고-싶을-때-사용하는-방법" class="headerlink" title="세션이 만료되더라도 로그인을 유지하고 싶을 때 사용하는 방법"></a>세션이 만료되더라도 로그인을 유지하고 싶을 때 사용하는 방법</h5><ul><li><p>Remember-me는 쿠키를 사용한다. 인증을 하면, 쿠키에 암호화한 인증 정보를 담아둔다. 이 값은 세션이 만료되었거나 세션이 없는 경우 같이 보내온 Remembe-me 쿠키가 있으면 그 쿠키에 있는 인증정보를 인증을 시도한다.</p></li><li><p>인증을 성공하면, 새로운 세션 id와 쿠키가 발급된다.</p></li><li><p><strong>해시 기반의 쿠키</strong> - 사용자의 username, password를 암호화(해싱)하여 쿠키에 담아둔다.</p><ul><li>그러면 요청에 해당하는 세션을 찾지 못할 때, 함께 보내온 RememberMe 쿠키가 있다면 그 쿠기에 들어있는 인증 정보로 인증을 시도한다.</li><li>그 username, password로 인증이 되면 새로운 세션ID와 쿠키가 발급이 되는 것이다.</li><li>이 쿠키가 탈취당한다면 그 계정은 탈취당한 것과 같다.</li><li><code>http.rememberMe().key(&quot;asfasasdf&quot;)</code> 와 같이 사용 가능</li></ul></li><li><p>조금 더 안전한 방법</p><ul><li>쿠키 안에 랜덤한 문자열(토큰)을 만들어 같이 저장하고 매번 인증할 때마다 바꾼다.</li><li>username, 토큰</li><li>쿠키가 탈취당한 경우 새롭게 인증을 하면 탈취당한 쿠키는 더 이상 사용이 불가능 하다.</li><li>하지만 해커가 탈취한 쿠키로 먼저 인증을 하면 해커의 쿠키만 유효하게 된다.</li><li>이 방법은 스프링 부트에서 지원하지 않음.</li></ul></li><li><p>조금 더 개선한 방법</p><ul><li>username, 토큰(랜덤, 매번 바뀜), 시리즈(랜덤, 고정)</li><li>쿠키가 탈취 당한 경우, 희생자는 <strong>유효하지 않은 토큰</strong> 과 <strong>유효한 시리즈와 Username</strong> 으로 접속하게 된다.</li><li>이 경우, 쿠키가 탈취당해 누군가에 의해 사용되었다는 뜻이 되므로</li><li>모든 토큰을 삭제하여 해커가 더 이상 탈취한 쿠키를 사용하지 못하도록 방지할 수 있다.</li><li>이렇게 되면 form기반의 로그인 창으로만 로그인을 하여 인증이 가능하게 된다.</li></ul></li><li><p><code>SecurityConfig.java</code> 에서 다음과 같이 사용 가능</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">// 스프링 시큐리티 설정을 직접하겠다는 뜻</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccountService accountService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.rememberMe()</span><br><span class="line">                .userDetailsService(accountService)</span><br><span class="line">                .tokenRepository(tokenRepository());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">tokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// JDBC 기반의 tokenRepository 구현체</span></span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource); <span class="comment">// dataSource 주입</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>JdbcTokenRepositoryImpl</code>가 사용하는 테이블이 있어야 한다.</p></li><li><p>해당 스키마가 생성될 수 있도록 매핑이 되는 엔티티가 필요하다.</p></li></ul><ul><li><code>PersistentLogins.java</code> : 쿠키 값을 사용하기 위한 엔티티<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"persistent_logins"</span>)</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentLogins</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">private</span> String series;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, length = <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, length = <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_used"</span>, nullable = <span class="keyword">false</span>, length = <span class="number">64</span>)</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime lastUsed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>login.html</code>에 로그인 유지 체크박스를 추가해준다.<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group form-check"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">id</span>=<span class="string">"rememberMe"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span> <span class="attr">for</span>=<span class="string">"rememberMe"</span> <span class="attr">aria-describedby</span>=<span class="string">"rememberMeHelp"</span>&gt;</span>로그인 유지<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>참조<br><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-JPA-%EC%9B%B9%EC%95%B1/dashboard" target="_blank" rel="external nofollow noopener noreferrer">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-JPA-%EC%9B%B9%EC%95%B1/dashboard</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;스프링-부트-자동-로그인-RememberMe&quot;&gt;&lt;a href=&quot;#스프링-부트-자동-로그인-RememberMe&quot; class=&quot;headerlink&quot; title=&quot;스프링 부트 - 자동 로그인 (RememberMe)&quot;&gt;&lt;/a&gt;스프링 부트 - 자
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>객체 지향 프로그래밍 (Object Oriented Programming)</title>
    <link href="https://kyu9341.github.io/java/2020/05/06/java_OOP/"/>
    <id>https://kyu9341.github.io/java/2020/05/06/java_OOP/</id>
    <published>2020-05-05T15:12:28.000Z</published>
    <updated>2020-05-05T16:30:20.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-지향-프로그래밍-Object-Oriented-Programming"><a href="#객체-지향-프로그래밍-Object-Oriented-Programming" class="headerlink" title="객체 지향 프로그래밍 (Object Oriented Programming)"></a>객체 지향 프로그래밍 (Object Oriented Programming)</h2><h3 id="객체-클래스-인스턴스-개념"><a href="#객체-클래스-인스턴스-개념" class="headerlink" title="객체, 클래스, 인스턴스 개념"></a>객체, 클래스, 인스턴스 개념</h3><h4 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h4><ul><li>실제로 존재하는 것. 사물 또는 개념, 구현할 대상</li><li>클래스에 선언된 모양 그대로 생성된 실체</li><li>객체는 모든 인스턴스를 대표하는 포괄적 의미를 갖는다.</li><li>oop관점에서 클래스 타입으로 선언되었을 때 객체라고 부른다.</li></ul><h4 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h4><ul><li>객체를 정의해 놓은 것 (설계도, 틀)</li><li>객체를 생성하는데 사용</li></ul><h4 id="인스턴스"><a href="#인스턴스" class="headerlink" title="인스턴스"></a>인스턴스</h4><ul><li>설계도를 바탕으로 구현된 구체적인 실체</li><li>객체를 소프트웨어에 실제화하면 그것을 인스턴스라고 부른다.</li><li>oop관점에서 객체가 메모리에 할당되어 실제로 사용될 때 인스턴스라고 부른다.</li><li>인스턴스는 어떤 원본(추상적인 개념)으로부터 생성된 복제본을 의미한다.</li></ul><hr><h3 id="객체지향의-네-가지-특징"><a href="#객체지향의-네-가지-특징" class="headerlink" title="객체지향의 네 가지 특징"></a>객체지향의 네 가지 특징</h3><h4 id="추상화"><a href="#추상화" class="headerlink" title="추상화"></a>추상화</h4><ul><li>추상화는 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법</li><li>추상화는 모델링이라고 표현한다. 어떤 실체들에서 관심있는 공통적인 특성을 뽑아내어 하나의 분류로 만드는 것이다.</li></ul><h4 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h4><ul><li>비슷한 속성과 메소드를 하나의 클래스로 묶는 것.</li><li>객체의 내용 중 숨기고 싶은 부분을 외부에서 접근하지 못하도록 할 수 있다.(정보 은닉이 가능)</li><li>접근제어(public, private, protected)와 같은 내용에 의해 구현된다.<ul><li>접근 권한을 통해 제공되며 원하지 않는 외부의 접근으로부터 내부의 데이터, 함수를 보호</li></ul></li></ul><h4 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h4><ul><li>클래스의 멤버와 함수를 다른 클래스에 물려주거나 물려받는 것.</li><li>코드의 재사용을 증대시킬 수 있다. (코드의 중복을 없앤다.)</li></ul><h4 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h4><ul><li>서로 다른 클래스의 객체가 같은 메시지를 받았을 때, 각자의 방식으로 동작하는 능력.</li><li>형태가 같지만 다른 기능을 하는 것을 의미</li><li>오버라이딩으로 구현 가능</li></ul><blockquote><p>참조<br><a href="https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html</a><br><a href="https://victorydntmd.tistory.com/117" target="_blank" rel="external nofollow noopener noreferrer">https://victorydntmd.tistory.com/117</a><br><a href="https://gmlwjd9405.github.io/2018/07/05/oop-features.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/07/05/oop-features.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;객체-지향-프로그래밍-Object-Oriented-Programming&quot;&gt;&lt;a href=&quot;#객체-지향-프로그래밍-Object-Oriented-Programming&quot; class=&quot;headerlink&quot; title=&quot;객체 지향 프로그래밍 (O
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14891번 톱니바퀴</title>
    <link href="https://kyu9341.github.io/algorithm/2020/05/01/algorithm14891/"/>
    <id>https://kyu9341.github.io/algorithm/2020/05/01/algorithm14891/</id>
    <published>2020-05-01T01:51:12.000Z</published>
    <updated>2020-05-01T02:00:57.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14891"><a href="#Problem-14891" class="headerlink" title="Problem 14891"></a>Problem 14891</h1><h2 id="톱니바퀴"><a href="#톱니바퀴" class="headerlink" title="톱니바퀴"></a>톱니바퀴</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다.</p><p>이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다.</p><p>톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자.</p><p>두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다.</p><p>위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다.</p><p>톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다.</p><p>다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다.</p><ul><li>1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점</li><li>2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점</li><li>3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점</li><li>4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점</li></ul><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14891" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14891</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10101111<br>01111101<br>11001110<br>00000010<br>2<br>3 -1<br>1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>7</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>11111111<br>11111111<br>11111111<br>11111111<br>3<br>1 1<br>2 1<br>3 1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>15</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>10001011<br>10000011<br>01011011<br>00111101<br>5<br>1 1<br>2 1<br>3 1<br>4 1<br>1 -1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>6</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>10010011<br>01010011<br>11100011<br>01010101<br>8<br>1 1<br>2 1<br>3 1<br>4 1<br>1 -1<br>2 -1<br>3 -1<br>4 -1</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>5</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>2차원 배열에 톱니바퀴의 현재 상태를 담는다.</li><li>톱니바퀴를 회전시키는 함수(rotate)를 작성한다.<ul><li>톱니바퀴의 번호와 방향을 받아 회전시키는 작업을 수행한다.</li></ul></li><li>현재 톱니바퀴가 회전하면 좌우로 이어진 톱니바퀴들이 연쇄적으로 영향을 받기 때문에 좌우로 각각 영향을 받는 마지막 톱니바퀴의 번호를 구한다.</li><li>좌우로 각각 구한 번호까지 톱니바퀴를 회전시킨다.<ul><li>이 때, 톱니바퀴의 회전 방향은 옆 톱니바퀴의 반대 방향이므로 한 칸 이동할 때마다 톱니바퀴의 방향이 바뀌도록 방향 변수에 -1을 곱하여 누적한다.</li></ul></li><li>마지막으로 입력으로 들어왔던 톱니바퀴를 회전시킨다.</li><li>위의 과정을 반복하고 점수를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>][<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 톱니바퀴를 회전시키는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> dir)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 시계 방향 회전</span></span><br><span class="line"><span class="keyword">if</span> (dir == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a[num - <span class="number">1</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">a[num - <span class="number">1</span>][i] = a[num - <span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">a[num - <span class="number">1</span>][<span class="number">0</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 반 시계 방향 회전</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dir == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = a[num - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">a[num - <span class="number">1</span>][i] = a[num - <span class="number">1</span>][i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">a[num - <span class="number">1</span>][<span class="number">7</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">a[i][j] = str[j] - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line"><span class="keyword">int</span> num, dir;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num &gt;&gt; dir;</span><br><span class="line"><span class="keyword">int</span> right = num; <span class="comment">// 오른쪽 톱니바퀴 확인</span></span><br><span class="line"><span class="keyword">int</span> left = num; <span class="comment">// 왼쪽 톱니바퀴 확인</span></span><br><span class="line"><span class="keyword">int</span> right_dir = dir; <span class="comment">// 오른쪽 톱니바퀴의 회전방향</span></span><br><span class="line"><span class="keyword">int</span> left_dir = dir; <span class="comment">// 왼쪽 톱니바퀴의 회전방향</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 왼쪽으로 이동하며 함께 회전하는 톱니바퀴를 구한다.</span></span><br><span class="line"><span class="keyword">while</span> (left &gt; <span class="number">1</span> &amp;&amp; a[left - <span class="number">1</span>][<span class="number">6</span>] != a[left - <span class="number">2</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">left--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 톱니바퀴 회전</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt; left; i--) &#123;</span><br><span class="line">left_dir * = <span class="number">-1</span>; <span class="comment">// 이전 톱니바퀴와 반대 방향으로 회전</span></span><br><span class="line">rotate(i - <span class="number">1</span>, left_dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 오른쪽으로 이동하며 함께 회전하는 톱니바퀴를 구한다.</span></span><br><span class="line"><span class="keyword">while</span> (right &lt; <span class="number">4</span> &amp;&amp; a[right - <span class="number">1</span>][<span class="number">2</span>] != a[right][<span class="number">6</span>]) &#123;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 톱니바퀴 회전</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &lt; right; i++) &#123;</span><br><span class="line">right_dir * = <span class="number">-1</span>;  <span class="comment">// 이전 톱니바퀴와 반대 방향으로 회전</span></span><br><span class="line">rotate(i + <span class="number">1</span>, right_dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rotate(num, dir); <span class="comment">// 현재 회전시키는 톱니바퀴 회전</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">ans += <span class="built_in">pow</span>(<span class="number">2</span>, i); <span class="comment">// 점수 구하기</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14891&quot;&gt;&lt;a href=&quot;#Problem-14891&quot; class=&quot;headerlink&quot; title=&quot;Problem 14891&quot;&gt;&lt;/a&gt;Problem 14891&lt;/h1&gt;&lt;h2 id=&quot;톱니바퀴&quot;&gt;&lt;a href=&quot;#톱니바퀴&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>스프링 부트 - 로그인 및 사용자 인증 정보 참조</title>
    <link href="https://kyu9341.github.io/java/2020/04/30/java_springBootLogin/"/>
    <id>https://kyu9341.github.io/java/2020/04/30/java_springBootLogin/</id>
    <published>2020-04-29T15:12:28.000Z</published>
    <updated>2020-05-12T23:44:56.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="현재-인증된-사용자-정보-참조"><a href="#현재-인증된-사용자-정보-참조" class="headerlink" title="현재 인증된 사용자 정보 참조"></a>현재 인증된 사용자 정보 참조</h2><ul><li>스프링 시큐리티의 스프링 웹 MVC 지원<ul><li><code>@AuthenticationPrincipal</code> : 핸들러 매개변수로 현재 인증된 <strong>Principal</strong> 을 참조할 수 있다.</li><li><strong>Principal</strong> 은 인증 시 authentication에 들어있는 첫 번째 파라미터이다. 아래의 <code>account.getNickname()</code>에 해당.</li></ul></li><li><code>AccountService.java</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    UsernamePasswordAuthenticationToken token = <span class="keyword">new</span> UsernamePasswordAuthenticationToken( <span class="comment">// 토큰 생성</span></span><br><span class="line">            account.getNickname(),</span><br><span class="line">            account.getPassword(),</span><br><span class="line">            List.of(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_USER"</span>)));</span><br><span class="line">    <span class="comment">// 로그인 처리</span></span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>@AuthenticationPrincipal</code>은 SpEL을 사용해서 Principal 내부 정보에 접근할 수도 있다.<ul><li><code>@AuthenticationPrincipal(expression = &quot;#this == &#39;anonymousUser&#39; ? null : account&quot;)</code></li><li>익명 인증인 경우에는 null로 설정하고, 아닌 경우에는 account 프로퍼티를 조회해서 설정하라는 뜻.</li></ul></li><li><code>@AuthenticationPrincipal</code>를 사용하면 <code>UserDetailsService</code>에서 return한 객체를 파라미터로 직접 받아 사용할 수 있다.</li></ul><ul><li><code>@AuthenticationPrincipal(expression = &quot;#this == &#39;anonymousUser&#39; ? null : account&quot;)</code>와 같이 매번 파라미터에 붙이기는 번거롭기 때문에 <code>@CurrentUser</code>라는 커스텀 어노테이션을 생성한다.</li><li><code>CurrentUser.java</code> : 어노테이션 생성<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 런타임 까지 유지</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">// 타겟은 파라미터에만 붙이겠다.</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="comment">// 익명 사용자인 경우에는 null로, 익명 사용자가 아닌 경우에는 실제 account 객체로</span></span><br><span class="line"><span class="comment">// Principal 을 다이나믹 하게 꺼내기 위해 @CurrentUser 생성</span></span><br><span class="line"><span class="meta">@AuthenticationPrincipal</span>(expression = <span class="string">"#this == 'anonymousUser' ? null : account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>MainController.java</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="comment">// 익명 사용자인 경우에는 null 로, 익명 사용자가 아닌 경우에는 실제 account 객체로</span></span><br><span class="line">    <span class="comment">// Principal 을 다이나믹 하게 꺼내기 위해 @CurrentUser 생성</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(@CurrentUser Account account, Model model)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account != <span class="keyword">null</span>)&#123; <span class="comment">// null 이 아니면 인증을 한 사용자</span></span><br><span class="line">            model.addAttribute(account);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>익명 사용자인 경우에는 null을, 익명 사용자가 아닌 경우에는 실제 account 객체를 가져온다.</li><li>하지만 지금 로그인 할 때 사용한 Principal에는 Account라는 프로퍼티가 없다.</li><li>따라서 Account라는 프로퍼티를 가지고 있는 중간 역할을 해줄 수 있는 객체가 필요하다.</li><li>핸들러에서 현재 로그인한 유저의 정보가 필요할 때 위와 같이 사용할 수 있다.</li></ul><ul><li><code>UserAccount.java</code> : 스프링 시큐리티가 다루는 유저 정보와 우리의 도메인에서 다루는 유저 정보 사이의 갭을 매꿔주는 일종의 어댑터 역할<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAccount</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123; <span class="comment">// 스프링 시큐리티의 User를 상속</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">// 스프링 시큐리티가 다루는 유저 정보를 우리가 가지고 있는 도메인의 유저 정보와 연동</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(account.getNickname(), account.getPassword(), List.of(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_USER"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>스프링 시큐리티의 User를 상속받는다.</li><li>UserAccount의 멤버는 Account 객체만이 존재한다.</li><li>생성자의 내부에서 User 클래스의 생성자를 호출하여 username, password, role을 세팅한다.</li></ul><ul><li><code>AccountService.java</code> 의  Principal에 위에서 생성한 AccountUser 객체를 넣는다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UsernamePasswordAuthenticationToken token = <span class="keyword">new</span> UsernamePasswordAuthenticationToken( <span class="comment">// 토큰 생성</span></span><br><span class="line">                <span class="keyword">new</span> UserAccount(account), <span class="comment">// Principal 객체설정</span></span><br><span class="line">                account.getPassword(),</span><br><span class="line">                List.of(<span class="keyword">new</span> SimpleGrantedAuthority(<span class="string">"ROLE_USER"</span>)));</span><br><span class="line">        <span class="comment">// 로그인 처리</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>로그인을 하게 되면 <code>new UserAccount(account)</code>가 인증된 Principal로 간주된다.</li></ul><h2 id="로그인-로그아웃"><a href="#로그인-로그아웃" class="headerlink" title="로그인 / 로그아웃"></a>로그인 / 로그아웃</h2><ul><li>스프링 시큐리티 로그인/로그아웃 설정</li><li><code>SecurityConfig.java</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin()</span><br><span class="line">        .loginPage(<span class="string">"/login"</span>)  <span class="comment">// 커스텀한 로그인 페이지를 보여줄 url</span></span><br><span class="line">        .permitAll(); <span class="comment">// 로그인 폼에 대한 접근 권한</span></span><br><span class="line">http.logout()</span><br><span class="line">        .logoutSuccessUrl(<span class="string">"/"</span>); <span class="comment">// 로그아웃 성공 시 이동할 url</span></span><br></pre></td></tr></table></figure></li><li>위와 같이 설정하고 <code>login.html</code>의 form에서 <code>th:action=&quot;@{/login}&quot; method=&quot;post&quot;</code>와 같이 설정한다면 post로 가는 <code>/login</code> 요청을 <code>formLogin</code>을 처리하는 시큐리티가 처리해준다.<ul><li>따로 <code>/login</code> post를 처리하는 핸들러를 만들 필요가 없음.<ul><li>PasswordEncoder도 Bean으로 등록이 되어있다면 자동으로 사용이 된다. (하나만 있는 경우)</li></ul></li><li>알아서 username과 password를 가지고 로그인을 처리한다. 이 때, 데이터베이스에 저장된 정보를 참조하여 인증을 하여야 하기 때문에 데이터베이스를 조회할 수 있는 <code>UserDetailsService</code>를 구현해야 한다.</li></ul></li></ul><ul><li><code>UserDetailsService</code> 구현<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccountRepository accountRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String emailOrNickname)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        Account account = accountRepository.findByEmail(emailOrNickname);</span><br><span class="line">        <span class="keyword">if</span>(account == <span class="keyword">null</span>)&#123; <span class="comment">// 이메일로 찾지 못한 경우 닉네임으로 찾는다.</span></span><br><span class="line">            account = accountRepository.findByNickname(emailOrNickname);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(account == <span class="keyword">null</span>)&#123; <span class="comment">// 닉네임으로도 찾지 못한다면 에러를 던짐</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(emailOrNickname);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Principal 에 해당하는 객체를 리턴한다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>loadUserByUsername()</code><ul><li>상세 정보를 조회하는 메서드이며, 사용자 계정정보와 권한을 갖는 <code>UserDetails</code>인터페이스를 반환해야 한다.</li><li>매개변수는 로그인 시 입력한 아이디이다. 엔티티의 PK를 뜻하는 것이 아니고, 유저를 식별할 수 있는 어떠한 값을 의미한다. 스프링 시큐리티에서는 username라는 이름으로 사용한다.<ul><li>로그인 form에서 아이디에 해당하는 값의 name=”nsername”으로 요청해야 한다.</li></ul></li></ul></li><li><code>UserDetailsService</code>타입의 빈이 하나만 있으면 스프링 시큐리티에 따로 설정이 필요없다. 자동으로 저 빈을 사용한다.</li><li><code>UserDetailsService</code>에서 return하는 객체는 <code>UserDetails</code>타입이어야 한다.</li><li>따라서 <code>UserDetails</code>를 구현하는 <code>User</code>클래스를 상속받은 <code>UserAccount</code>를 리턴한다.</li></ul><blockquote><p>참조<br><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-JPA-%EC%9B%B9%EC%95%B1/dashboard" target="_blank" rel="external nofollow noopener noreferrer">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-JPA-%EC%9B%B9%EC%95%B1/dashboard</a><br><a href="https://pupupee9.tistory.com/137" target="_blank" rel="external nofollow noopener noreferrer">https://pupupee9.tistory.com/137</a><br><a href="https://victorydntmd.tistory.com/328" target="_blank" rel="external nofollow noopener noreferrer">https://victorydntmd.tistory.com/328</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;현재-인증된-사용자-정보-참조&quot;&gt;&lt;a href=&quot;#현재-인증된-사용자-정보-참조&quot; class=&quot;headerlink&quot; title=&quot;현재 인증된 사용자 정보 참조&quot;&gt;&lt;/a&gt;현재 인증된 사용자 정보 참조&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;스프링 시큐리티
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1987번 알파벳</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/29/algorithm1987/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/29/algorithm1987/</id>
    <published>2020-04-28T15:51:12.000Z</published>
    <updated>2020-04-28T16:26:10.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1987"><a href="#Problem-1987" class="headerlink" title="Problem 1987"></a>Problem 1987</h1><h2 id="알파벳"><a href="#알파벳" class="headerlink" title="알파벳"></a>알파벳</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.</p><p>말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.</p><p>좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1987" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1987</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2 4<br>CAAB<br>ADCB</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>map에 모든 알파벳 대문자를 키로, 벨류를 false로 초기화한다.</li><li>dfs를 수행하며 현재까지 어떤 칸을 지나왔는지 체크하고, 아직 한 번도 지나오지 않은 알파벳인 경우에만 이동한다.</li><li>cnt로 현재까지 이동한 횟수를 카운트하여 최대로 지나온 칸 수를 저장한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">ans = <span class="built_in">max</span>(ans, cnt); <span class="comment">// 이동한 최댓값을 구함</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; r &amp;&amp; ny &lt; c) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m[a[nx][ny]]) &#123; <span class="comment">// 아직 한번도 밟지 않은 알파벳인 경우</span></span><br><span class="line">m[a[nx][ny]] = <span class="literal">true</span>; <span class="comment">//  방문 처리</span></span><br><span class="line">dfs(nx, ny, cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m[a[x][y]] = <span class="literal">false</span>; <span class="comment">// 방문 처리 해제</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">a.resize(r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map에 모든 알파벳 대문자를 키로, 벨류를 false로 초기화</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">m.insert(make_pair(<span class="string">'A'</span> + i, <span class="literal">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">m[a[<span class="number">0</span>][<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1987&quot;&gt;&lt;a href=&quot;#Problem-1987&quot; class=&quot;headerlink&quot; title=&quot;Problem 1987&quot;&gt;&lt;/a&gt;Problem 1987&lt;/h1&gt;&lt;h2 id=&quot;알파벳&quot;&gt;&lt;a href=&quot;#알파벳&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

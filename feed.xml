<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-02-17T03:25:57.877Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 16929번 Two Dots</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/</id>
    <published>2020-02-17T03:24:28.000Z</published>
    <updated>2020-02-17T03:25:57.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16929"><a href="#Problem-16929" class="headerlink" title="Problem 16929"></a>Problem 16929</h1><h2 id="Two-Dots"><a href="#Two-Dots" class="headerlink" title="Two Dots"></a>Two Dots</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>Two Dots는 Playdots, Inc.에서 만든 게임이다. 게임의 기초 단계는 크기가 N×M인 게임판 위에서 진행된다.</p><p>각각의 칸은 색이 칠해진 공이 하나씩 있다. 이 게임의 핵심은 같은 색으로 이루어진 사이클을 찾는 것이다.</p><p>다음은 위의 게임판에서 만들 수 있는 사이클의 예시이다.</p><p>점 k개 d1, d2, …, dk로 이루어진 사이클의 정의는 아래와 같다.</p><ul><li>모든 k개의 점은 서로 다르다.</li><li>k는 4보다 크거나 같다.</li><li>모든 점의 색은 같다.</li><li>모든 1 ≤ i ≤ k-1에 대해서, di와 di+1은 인접하다. 또, dk와 d1도 인접해야 한다. 두 점이 인접하다는 것은 각각의 점이 들어있-는 칸이 변을 공유한다는 의미이다.</li></ul><p>게임판의 상태가 주어졌을 때, 사이클이 존재하는지 아닌지 구해보자.</p><p>2 ≤ N, M ≤ 50</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판의 크기 N, M이 주어진다. 둘째 줄부터 N개의 줄에 게임판의 상태가 주어진다. 게임판은 모두 점으로 가득차 있고, 게임판의 상태는 점의 색을 의미한다. 점의 색은 알파벳 대문자 한 글자이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>사이클이 존재하는 경우에는 “Yes”, 없는 경우에는 “No”를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 4<br>AAAA<br>ABCA<br>AAAA</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>Yes</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 4<br>AAAA<br>ABCA<br>AADA</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>No</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>Yes</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>Yes</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>No</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>문제에서 주어진 조건에 맞는 사이클이 형성되는지 찾는 문제이다. dfs를 통해 해결할 수 있다.</p></li><li><p>방문 여부를 체크할 배열과 탐색을 시작한 점부터 이동한 거리를 나타낼 배열을 선언한다.</p></li><li><p>인접한 같은 색깔의 점인 경우 dfs를 수행한다.</p><ul><li>이때, 사이클을 이루는지 여부를 확인하는 방법은 다음과 같다.<ul><li>cnt변수를 탐색을 진행할 때마다 1씩 증가시킨다.</li><li>처음 방문하게 되는 점의 dist배열에 현재 cnt를 저장한다.</li><li>재귀를 수행할 때 이미 방문했던 노드이며, cnt - dist[x][y] &gt;= 4 인 경우 사이클이 형성된다.</li></ul></li></ul></li><li><p>사이클이 형성되지 않는 경우</p></li></ul><p><img src="https://kyu9341.github.io/img/cycle2.png" alt="cycle"></p><ul><li>사이클이 형성되는 경우</li></ul><p><img src="https://kyu9341.github.io/img/cycle1.png" alt="cycle"></p><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> color[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">// 시작점부터 이동한 거리</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 게임판의 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check[x][y]) <span class="comment">// 이미 방문했던 노드인데</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt - dist[x][y] &gt;= <span class="number">4</span>) <span class="comment">// 이동 횟수에서 현재 위치에 저장된 시작점과의 거리 차가 4 이상 = 싸이클</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line">dist[x][y] = cnt; <span class="comment">// 현재 x,y가 시작점에서 몇번 이동했는지 저장, 시작점은 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (color[nx][ny] == color[x][y]) <span class="comment">// 같은 색깔의 점인 경우(방문여부는 관계x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(nx, ny, cnt + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">color[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"No"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>))</span><br><span class="line">ans = <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16929&quot;&gt;&lt;a href=&quot;#Problem-16929&quot; class=&quot;headerlink&quot; title=&quot;Problem 16929&quot;&gt;&lt;/a&gt;Problem 16929&lt;/h1&gt;&lt;h2 id=&quot;Two-Dots&quot;&gt;&lt;a href=&quot;#T
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1707번 이분 그래프</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/</id>
    <published>2020-02-15T11:05:15.000Z</published>
    <updated>2020-02-16T04:44:13.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1707"><a href="#Problem-1707" class="headerlink" title="Problem 1707"></a>Problem 1707</h1><h2 id="이분-그래프"><a href="#이분-그래프" class="headerlink" title="이분 그래프"></a>이분 그래프</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.</p><p>그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V(1≤V≤20,000)와 간선의 개수 E(1≤E≤200,000)가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호가 빈 칸을 사이에 두고 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1707" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1707</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2<br>3 2<br>1 3<br>2 3<br>4 4<br>1 2<br>2 3<br>3 4<br>4 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>YES<br>NO</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그래프를 다음과 같이 A와 B로 나눌 수 있으면 <strong>이분 그래프</strong> 라고 한다.</li></ul><p><img src="https://kyu9341.github.io/img/bipartite_graph.png" alt="bipartite_graph"></p><ul><li>A에 포함된 정점끼리 연결된 간선이 없음</li><li>B에 포함된 정점끼리 연결된 간선이 없음</li><li>모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에</li></ul><hr><ul><li><p>check배열을 bool타입 대신 int형으로 선언하여 방문하지 않은 노드는 0, 방문한 노드인데 1번 그룹이라면 1, 2번 그룹이라면 2로 저장한다.</p><ul><li>(dfs or bfs)를 통해 탐색을 수행하며 다음 노드로 넘어가면 그룹을 바꿔서 지정해준다. 이때 다음에 방문한 노드가 같은 그룹에 속한 노드라면 이분 그래프가 아니다.</li></ul></li><li><p>(dfs or bfs)에서 다음 노드가 방문하지 않은 노드라면 다음 노드로 재귀 호출하며 현재 1번 그룹이라면 다음은 2번을 넘겨주고 현재 2번이라면 1번을 넘겨준다.</p></li><li><p>다음 노드가 방문을 했던 노드인데 현재 노드와 같은 그룹이라면 이분 그래프가 아니다.</p></li><li><p>각 테스트케이스를 시작할 때마다 인접 노드와 방문 내역을 초기화 해야한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">20001</span>];</span><br><span class="line"><span class="keyword">int</span> check[<span class="number">20001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 0 : 방문 x, 1 : 1번 그룹에 포함, 2 : 2번 그룹에 포함</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c)</span> <span class="comment">// c : 다음 방문할 노드의 그룹 ( 1 or 2 ) , 이분그래프이면 true, 아니면 false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = c; <span class="comment">// c 그룹 방문 처리</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i]; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (!check[next]) <span class="comment">// 다음 정점을 방문 안했으면 동작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dfs(next, <span class="number">3</span> - c)) <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// false를 리턴받았으면 false리턴</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[next] == check[node]) <span class="comment">// 다음 정점이 이미 방문했던 정점인데 현재 정점과 같은 그룹이면 이분그래프가 아님</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">check[start] = c; <span class="comment">// 그룹 지정</span></span><br><span class="line">q.push(start); <span class="comment">// 첫 노드 push</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">3</span> - check[node];</span><br><span class="line">check[next] = c; <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1로 방문 처리</span></span><br><span class="line">q.push(next); <span class="comment">// 방문처리하며 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[node] == check[next])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].<span class="built_in">clear</span>(); <span class="comment">// 인접 노드 초기화</span></span><br><span class="line">check[i] = <span class="number">0</span>; <span class="comment">// 방문 내역 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">a[n].push_back(m);</span><br><span class="line">a[m].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) <span class="comment">// 모든 정점을 확인하여 이분 그래프가 아닌 경우가 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="number">0</span>) <span class="comment">// 아직 방문 안한 노드에 대해서 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bfs(i, <span class="number">1</span>) == <span class="literal">false</span>) <span class="comment">// dfs(i, 1) 도 가능</span></span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1707&quot;&gt;&lt;a href=&quot;#Problem-1707&quot; class=&quot;headerlink&quot; title=&quot;Problem 1707&quot;&gt;&lt;/a&gt;Problem 1707&lt;/h1&gt;&lt;h2 id=&quot;이분-그래프&quot;&gt;&lt;a href=&quot;#이분-그래프&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11726번 2xn타일링</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/</id>
    <published>2020-02-08T06:45:13.000Z</published>
    <updated>2020-02-17T15:35:03.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11726"><a href="#Problem-11726" class="headerlink" title="Problem 11726"></a>Problem 11726</h1><h2 id="2xn타일링"><a href="#2xn타일링" class="headerlink" title="2xn타일링"></a>2xn타일링</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><p>아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11726" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11726</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>9</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>55</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>먼저 메모이제이션 할 배열 d[]를 선언한다.</p></li><li><p>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</p><ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li></ul></li><li><p>즉, 2xn 크기의 직사각형을 채우는 방법의 수는</p></li><li><p>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수</p></li><li><p>d[n] = d[n - 1] + d[n - 2]</p></li><li><p>피보나치 수열과 같은 형태로 점화식이 만들어진다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="comment">// n이 d[1] = 1, d[2] = 2이므로</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 구한 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling(n - <span class="number">1</span>) + tiling(n - <span class="number">2</span>); <span class="comment">// d[n] = d[n - 1] + d[n - 2]</span></span><br><span class="line">d[n] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>];</span><br><span class="line">d[i] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11726&quot;&gt;&lt;a href=&quot;#Problem-11726&quot; class=&quot;headerlink&quot; title=&quot;Problem 11726&quot;&gt;&lt;/a&gt;Problem 11726&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링&quot;&gt;&lt;a href=&quot;#2xn
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1463번 1로 만들기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/</id>
    <published>2020-02-08T05:30:51.000Z</published>
    <updated>2020-02-17T15:24:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1463"><a href="#Problem-1463" class="headerlink" title="Problem 1463"></a>Problem 1463</h1><h2 id="1로-만들기"><a href="#1로-만들기" class="headerlink" title="1로 만들기"></a>1로 만들기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p><ol><li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li><li>X가 2로 나누어 떨어지면, 2로 나눈다.</li><li>1을 뺀다.</li></ol><p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1463" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1463</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>10</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>먼저 메모이제이션 할 배열 d[]를 선언한다.</li><li>점화식 d[n] = n을 1로 만드는 최소 연산 횟수 를 정의한다.<ul><li>[n을 n / 3으로 만드는 연산 횟수 : 1번], [n/3을 1로 만드는 연산 횟수 : d[n / 3]번]  //  1번 + d[n / 3]번</li><li>n -&gt; [n / 2] -&gt; 1  //  1번 + d[n / 2]번</li><li>n -&gt; [n - 1] -&gt; 1  //  1번 + d[n - 1]번</li><li>=&gt; d[n] = min(d[n / 3], d[n / 2], d[n - 1]) + 1</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000001</span>]; <span class="comment">// d[n] : n을 1로 만드는 최소 연산 횟수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식 구현</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 1을 만든 경우 d[1] = 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 수행했던 연산인 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n]; <span class="comment">// 메모이제이션</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = go(n - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 최솟값을 더 편하게 구하기 위해 먼저 처리</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 2로 나누어 떨어지는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp; <span class="comment">// 새로운 방식이 더 적은 연산을 필요로 하면 바꿔줌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 초기값 지정</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">3</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1463&quot;&gt;&lt;a href=&quot;#Problem-1463&quot; class=&quot;headerlink&quot; title=&quot;Problem 1463&quot;&gt;&lt;/a&gt;Problem 1463&lt;/h1&gt;&lt;h2 id=&quot;1로-만들기&quot;&gt;&lt;a href=&quot;#1로-만들기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 10799번 쇠막대기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/06/algorithm10799/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/06/algorithm10799/</id>
    <published>2020-02-05T23:48:41.000Z</published>
    <updated>2020-02-05T23:49:55.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-10799"><a href="#Problem-10799" class="headerlink" title="Problem 10799"></a>Problem 10799</h1><h2 id="쇠막대기"><a href="#쇠막대기" class="headerlink" title="쇠막대기"></a>쇠막대기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.</p><p>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.<br>각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.<br>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.<br>아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.</p><p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.</p><p>레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.<br>쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다.<br>위 예의 괄호 표현은 그림 위에 주어져 있다.</p><p>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다.</p><p>쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/10799" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/10799</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>()(((()())(())()))(())</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>17</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>(((()(()()))(())()))(()())</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>24</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><p>이전에 풀어보았던 괄호 문제와 비슷한듯 싶어<br>스택을 이용하면 될듯 싶었다. 접근 방식은 아래와 같았다.</p><ul><li>하나의 막대기를 n개의 레이저로 자르면 -&gt; n + 1 개의 조각 생성</li><li>각각의 막대기에 몇 개의 레이저가 가해지는지 확인하여 모두 더하면 됨<ul><li>먼저 괄호를 보고 레이저와 막대기를 구분해야 했다.</li><li>레이저는 () 이므로 문자열의 현재 인덱스와 다음 인덱스를 보고 레이저가 맞다면</li><li>레이저가 통과하는 모든 막대기에 레이저 수를 하나씩 증가시킨다.(배열을 이용하여 n번째 막대기에 가해지는 레이저의 수를 raser[n]으로 지정하였다.)</li><li>레이저인 경우 위와 같이 처리하고 건너뛰고, 레이저가 아니라면 ‘(‘일 때 스택에 push, ‘)’일 때 pop을 하여 현재 스택의 사이즈를 보고 어떤 막대기인지를 판단했다.</li><li>이제 raser[]에 담긴 수를 확인하여 막대기마다 n + 1을 해 누적하면 되는데,</li><li>이것을 괄호가 닫힐 때 정산을 하면 된다.</li><li>결과를 출력할 변수에 raser[s.size()]+1 을 누적시키면 가장 위에 있는 막대기 중 하나에 발사되는 레이저 수를 구하게 되는 것이다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> input; <span class="comment">// 입력 문자열</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"></span><br><span class="line">getline(<span class="built_in">cin</span>, input);</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = input.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> raser[<span class="number">100000</span>] = &#123;&#125;; <span class="comment">// 막대기에 발사된 레이저의 수</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] == <span class="string">'('</span> &amp;&amp; input[i + <span class="number">1</span>] == <span class="string">')'</span>) <span class="comment">// 레이저인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">raser[j]++; <span class="comment">// 스택의 사이즈(겹쳐진 막대기 수) 모두 1씩 증가</span></span><br><span class="line">&#125;</span><br><span class="line">i++; <span class="comment">// 문자 두 개를 확인했으니 한칸 넘어감</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 막대기의 시작 or 끝인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.push(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (input[i] == <span class="string">')'</span>) <span class="comment">// 괄호가 닫힐 때 정산</span></span><br><span class="line">&#123;</span><br><span class="line">res += raser[s.<span class="built_in">size</span>()] + <span class="number">1</span>; <span class="comment">// 하나의 막대기에는 n + 1개의 조각이 생성</span></span><br><span class="line">raser[s.<span class="built_in">size</span>()] = <span class="number">0</span>; <span class="comment">// 초기화</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-10799&quot;&gt;&lt;a href=&quot;#Problem-10799&quot; class=&quot;headerlink&quot; title=&quot;Problem 10799&quot;&gt;&lt;/a&gt;Problem 10799&lt;/h1&gt;&lt;h2 id=&quot;쇠막대기&quot;&gt;&lt;a href=&quot;#쇠막대기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) 범위 기반 for문</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/19/C++range-based%20for%20statement/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/19/C++range-based%20for%20statement/</id>
    <published>2020-01-19T11:33:41.000Z</published>
    <updated>2020-01-19T12:39:10.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="범위-기반-for문-range-based-for-statement"><a href="#범위-기반-for문-range-based-for-statement" class="headerlink" title="범위 기반 for문 (range-based for statement)"></a>범위 기반 for문 (range-based for statement)</h2><p>일반적인 for문은 다음과 같은 형태이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[n] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 C++ 11에서는 범위기반 for문 이라는 새로운 형태의 루프를 도입하여 더 간결하게 배열 등의 모든 요소를 반복하는 방법을 제공한다.</p><p>범위 기반 for문의 기본 문법은 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(element_declaration : <span class="built_in">array</span>)</span><br><span class="line">statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위의 기본 for문을 범위 기반 for문으로 표현하면 다음과 같다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[n] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래는 auto키워드를 이용하여 자동으로 적절한 자료형을 지정함.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 일반 for문을 간단하게 표현할 수 있다. 위의 방식들은 각 원소의 참조를 x에 값이 복사되어 사용되기 때문에 원본이 훼손되지는 않지만 원소를 수정할 수 없다. 또한 복사하는데 비용도 발생한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아래와 같이 사용하면 arr의 모든 원소는 10으로 변경된다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : arr)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const로 지정하면 원소를 복사하지 않고 원본도 훼손되지 않기 때문에 자료의 안전성을 갖춘다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>참조<br><a href="https://docs.microsoft.com/ko-kr/cpp/cpp/range-based-for-statement-cpp?view=vs-2019" target="_blank" rel="external nofollow noopener noreferrer">https://docs.microsoft.com/ko-kr/cpp/cpp/range-based-for-statement-cpp?view=vs-2019</a><br><a href="https://boycoding.tistory.com/210" target="_blank" rel="external nofollow noopener noreferrer">https://boycoding.tistory.com/210</a><br><a href="https://blockdmask.tistory.com/319" target="_blank" rel="external nofollow noopener noreferrer">https://blockdmask.tistory.com/319</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;범위-기반-for문-range-based-for-statement&quot;&gt;&lt;a href=&quot;#범위-기반-for문-range-based-for-statement&quot; class=&quot;headerlink&quot; title=&quot;범위 기반 for문 (range-ba
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) 입력 함수 - cin, cin.get(), getline()</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/17/C++getline()/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/17/C++getline()/</id>
    <published>2020-01-17T14:23:55.000Z</published>
    <updated>2020-01-19T00:26:24.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><ul><li>&lt;iostream&gt;에 포함되어 있다.</li><li>표준 입력 버퍼에서 개행 문자를 제외한 값을 가져온다.</li><li>공백이나 개행 입력 시 공백 이전까지의 값만 결과로 받아들인다.</li><li>개행 문자를 입력 버퍼에 남겨둔다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정수</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br></pre></td></tr></table></figure><p>위와 같이 사용이 가능하다.<br>이때 hello 같은 문자열이라면 문제 없이 입력을 받지만 Hello World!와 같이 띄어쓰기가 포함된 문장이라면 Hello 까지 밖에 입력이 되지 않을 것이다.<br>cin의 &gt;&gt; 연산자에서는 공백문자에서 입력을 끊기 때문인데, 이러한 문제를 해결하기 위해서 getline()이라는 함수를 사용한다.</p><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p>getline()함수는 두 가지가 존재하는데 각가 다른 라이브러리에 존재한다. istream 라이브러리에 속한 cin.getline()함수와 string 라이브러리에 속하는 getline()함수가 있다.</p><ul><li><strong>istream 라이브러리의 cin.getline()</strong><ul><li>문자 배열이며 마지막 글자가 ‘\0’(terminator)인 c-string을 입력 받는데 사용</li><li>n-1개의 문자 개수만큼 읽어와 str에 저장 (n번째 문자는 NULL(‘\0’)로 바꾼다.)</li><li>세 번째 인자인 delim은 별도로 지정해주지 않으면 엔터(‘\n’)로 인식</li><li>delim을 지정해주면 그 제한자(delim)문자 직전까지 읽어서 str에 저장</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(<span class="keyword">char</span>* str, streamsize n);</span><br><span class="line"><span class="built_in">cin</span>.getline(<span class="keyword">char</span>* str, streamsize n, <span class="keyword">char</span> dlim);</span><br></pre></td></tr></table></figure><p>cin.getline(변수 주소, 최대 입력 가능 문자수, 종결 문자);<br>ex) cin.getline(str, 100);</p><ul><li><strong>string 라이브러리의 getline()</strong><ul><li>최대 문자 수를 입력하지 않아도 됨.</li><li>원하는 구분자(delimiter)를 만날 때 까지 모든 문자열을 입력 받아 하나의 string 객체에 저장</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getline(istream&amp; is, <span class="built_in">string</span> str);</span><br><span class="line">getline(istream&amp; is, <span class="built_in">string</span> str, <span class="keyword">char</span> dlim);</span><br></pre></td></tr></table></figure><p>getline(입력스트림 오브젝트, 문자열을 저장할 string객체, 종결 문자);<br>ex) getline(cin, str);</p><h3 id="주의"><a href="#주의" class="headerlink" title="주의"></a>주의</h3><p>getline() 함수를 사용할 때 주의할 점이 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br></pre></td></tr></table></figure><p>위와 같은 상황을 보자. 위 코드대로 실행을 하면 n을 입력 받은 후 문자열을 입력받지 않고 바로 다음 코드로 넘어가게 된다. 이유는 버퍼에 정수 값을 입력한 뒤 누른 엔터(‘\n’)가 그대로 남아있어 getline()에 들어가기 때문이다. 이를 해결하기 위해 <strong>cin.ignore()</strong> 라는 함수를 사용할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br></pre></td></tr></table></figure><p> 위와 같이 변경하면 cin.ingore()가 입력 버퍼의 모든 내용을 제거해주어 getline()이 정상적으로 동작할 수 있다.</p><p> 추가적으로 cin.ignore() 함수에 대해 알아보자면<br> cin.ignore(int n, char dlim);<br> cin.ignore(읽어들일 문자의 개수, 종결 문자);<br> 와 같은 형태로도 사용이 가능하다.</p><h2 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h2><ul><li>표준 입력 버퍼에서 문자를 하나만 가져온다.</li><li>문자 하나만 입력이 가능하며 공백과 개행도 입력으로 포함한다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1, ch2;</span><br><span class="line">ch1 = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">ch2 = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><blockquote><p>참조<br><a href="https://jhnyang.tistory.com/107" target="_blank" rel="external nofollow noopener noreferrer">https://jhnyang.tistory.com/107</a><br><a href="https://luyin.tistory.com/334" target="_blank" rel="external nofollow noopener noreferrer">https://luyin.tistory.com/334</a><br><a href="https://woodforest.tistory.com/168" target="_blank" rel="external nofollow noopener noreferrer">https://woodforest.tistory.com/168</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cin&quot;&gt;&lt;a href=&quot;#cin&quot; class=&quot;headerlink&quot; title=&quot;cin&quot;&gt;&lt;/a&gt;cin&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;iostream&amp;gt;에 포함되어 있다.&lt;/li&gt;
&lt;li&gt;표준 입력 버퍼에서 개행 문자를 제외한 값을
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) STL sort()함수</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/12/C++STLsort/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/12/C++STLsort/</id>
    <published>2020-01-12T04:56:25.000Z</published>
    <updated>2020-01-17T14:23:49.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL-sort-함수"><a href="#STL-sort-함수" class="headerlink" title="STL sort() 함수"></a>STL sort() 함수</h2><p><algorithm> 헤더파일에서 제공하는 STL로서 주어진 범위 내에서 원소들을 정렬한다. 이때 정렬하는 방식을 사용자가 정의할 수 있고, 동일한 원소에 대해서는 그 순서가 보장되지 않는다. std::sort는 숫자 뿐만 아니라 대소 비교가 가능한 모든 원소에 대해서 정렬을 수행할 수 있다. 즉 int뿐 아니라 char, string 역시 정렬이 가능하며 사용자가 정의한 객체 역시 연산자 오버로딩을 정의하면 정렬이 가능하다.</algorithm></p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>2개 혹은 3개의 argument를 필요로 하는데, 첫 번째 두 개의 argument는 iterator로서 정렬하는 범위를 나타낸다. sort(start, end)</li><li>퀵 정렬을 기반으로 함수가 구현되어 있다. 평균 시간 복잡도 : O(NlogN)</li><li>세 번째 argument를 넣지 않으면 default로 오름차순 정렬이 수행된다.</li><li>사용자 정의 함수를 만들어 세 번째 인자로 넣어 정렬 기준을 정의할 수 있다.</li><li>기본적으로 두 개의 객체를 비교해서 첫 번째가 두 번째보다 작으면 true, 아니면 false를 반환한다.</li></ul><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><ul><li><strong>default - 오름차순 정렬</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">7</span> &#125;;</span><br><span class="line">sort(arr, arr + <span class="number">10</span>);</span><br><span class="line">printArray(arr, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>출력</strong></p><div style="width: 200px; height: 80px;">  <img src="https://kyu9341.github.io/img/sort1.png" style="width: 200px  ; height: 80px;"></div></blockquote></li></ul><ul><li><strong>내림차순 정렬</strong><br>내림차순 정렬은 세 번째 인자로 함수를 정의하여 사용할 수도 있고, <functional> 헤더파일에 선언되어 있는 greater&lt;자료형&gt;() 을 전달하여 내림차순으로 정렬을 수행할 수 있다.<br>(less&lt;자료형&gt;()은 오름차순 정렬을 해주지만 default와 동일하므로 생략한다.)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">desc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 내림차순 정렬을 수행할 비교 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">int</span>)time(<span class="literal">NULL</span>)); <span class="comment">// 시드 값 설정</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> vsize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vsize; i++)</span><br><span class="line">vec.push_back(rand() % <span class="number">10</span> + <span class="number">1</span>); <span class="comment">// 벡터에 1 ~ 10의 난수 삽입</span></span><br><span class="line"><span class="comment">// N ~ (M+N-1) 까지 난수 생성 : rand() % M + N</span></span><br><span class="line"></span><br><span class="line">printArray(vec, vsize);</span><br><span class="line">sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// [vec.begin(), vec.end()) 내림차순 정렬</span></span><br><span class="line">  <span class="comment">// greater&lt;int&gt;() 대신 desc를 넣어도 같은 결과</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printArray(vec, vsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>출력</strong></p><div style="width: 200px; height: 80px;">  <img src="https://kyu9341.github.io/img/sort2.png" style="width: 200px  ; height: 80px;"></div></blockquote></functional></li></ul><ul><li><strong>기준을 지정하여 정렬 - compare함수</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="built_in">vector</span>&lt;Student&gt; &amp;vec, <span class="keyword">int</span> n)</span> <span class="comment">//  출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[ 이름 : "</span> &lt;&lt; vec[i].name &lt;&lt; <span class="string">", 나이 : "</span> &lt;&lt; vec[i].age &lt;&lt; <span class="string">", 점수 : "</span> &lt;&lt; vec[i].score &lt;&lt; <span class="string">" ]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Student a, Student b)</span> <span class="comment">// 내림차순 정렬을 수행할 비교 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.score == b.score) <span class="comment">// 점수가 같으면 -&gt; 나이가 적은 순</span></span><br><span class="line"><span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 점수가 다르면 -&gt; 점수 높은 순(내림차순)</span></span><br><span class="line"><span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vec;</span><br><span class="line"><span class="keyword">int</span> vsize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vec.push_back(Student(<span class="string">"kwon"</span>, <span class="number">25</span>, <span class="number">100</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"kim"</span>, <span class="number">24</span>, <span class="number">88</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"shin"</span>, <span class="number">29</span>, <span class="number">97</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"jung"</span>, <span class="number">27</span>, <span class="number">75</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"park"</span>, <span class="number">22</span>, <span class="number">88</span>)); <span class="comment">// 점수가 같으면 나이가 적은 순</span></span><br><span class="line"></span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), compare);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>출력</strong></p><div style="width: 250px; height: 200px;">  <img src="https://kyu9341.github.io/img/sort3.png" style="width: 250px  ; height: 200px;"></div></blockquote></li></ul><ul><li><strong>연산자 오버로딩을 통한 정렬(operator overloading)</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 오버로딩 '&lt;' (클래스 내부)</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Student&amp; student)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;age &lt; student.age; <span class="comment">// 나이 오름차순으로 정렬</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="built_in">vector</span>&lt;Student&gt;&amp; vec, <span class="keyword">int</span> n)</span> <span class="comment">//  출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[ 이름 : "</span> &lt;&lt; vec[i].name &lt;&lt; <span class="string">", 나이 : "</span> &lt;&lt; vec[i].age &lt;&lt; <span class="string">", 점수 : "</span> &lt;&lt; vec[i].score &lt;&lt; <span class="string">" ]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vec;</span><br><span class="line"><span class="keyword">int</span> vsize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vec.push_back(Student(<span class="string">"kwon"</span>, <span class="number">25</span>, <span class="number">100</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"kim"</span>, <span class="number">24</span>, <span class="number">88</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"shin"</span>, <span class="number">29</span>, <span class="number">97</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"jung"</span>, <span class="number">27</span>, <span class="number">75</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"park"</span>, <span class="number">22</span>, <span class="number">88</span>));</span><br><span class="line"></span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>출력</strong></p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/sort4.png" style="width: 250px    ; height: 200px;"></div></blockquote><blockquote><p>참조<br><a href="https://www.acmicpc.net/blog/view/22" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/blog/view/22</a><br><a href="https://hongku.tistory.com/153" target="_blank" rel="external nofollow noopener noreferrer">https://hongku.tistory.com/153</a><br><a href="https://blockdmask.tistory.com/178" target="_blank" rel="external nofollow noopener noreferrer">https://blockdmask.tistory.com/178</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;STL-sort-함수&quot;&gt;&lt;a href=&quot;#STL-sort-함수&quot; class=&quot;headerlink&quot; title=&quot;STL sort() 함수&quot;&gt;&lt;/a&gt;STL sort() 함수&lt;/h2&gt;&lt;p&gt;&lt;algorithm&gt; 헤더파일에서 제공하는 STL로서 
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>크루스칼(Kruskal Algorithm) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/09/algorithmKruskal/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/09/algorithmKruskal/</id>
    <published>2020-01-09T11:21:30.000Z</published>
    <updated>2020-01-12T13:36:20.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="크루스칼-Kruskal-Algorithm"><a href="#크루스칼-Kruskal-Algorithm" class="headerlink" title="크루스칼(Kruskal Algorithm)"></a>크루스칼(Kruskal Algorithm)</h2><p>크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘이다. 즉, 최소 비용 신장 트리를 만들기 위한 대표적인 알고리즘이라고 할 수 있다. 흔히 여러 개의 도시가 있을 때 각 도시의 도로를 이용해 비용을 최소한으로 연결하고자 할 때 실제로 적용되는 알고리즘이다.</p><p>아래의 그래프를 보면 노드는 7개이고 간선의 갯수는 11개이다.</p><div style="width: 410px; height: 620px;">    <img src="https://kyu9341.github.io/img/kruskal1.png" style="width: 410px    ; height: 620px;"></div><p>위와 같은 그래프를 최소한의 비용으로 연결만 하고자 한다면 어떻게 해야할까?</p><p>일단 모든 노드를 최대한 적은 비용으로 연결만 시키면 되는 것이기 때문에 모든 간선의 정보를 오름차순으로 정렬하여 비용이 적은 간선부터 하나씩 그래프에 포함시키면 될 것이다.</p><ul><li><p>노드 1</p><ul><li>(1, 7) [12]</li><li>(1, 4) [28]</li><li>(1, 2) [67]</li><li>(1, 5) [17]</li></ul></li><li><p>노드 2</p><ul><li>(2, 4) [24]</li><li>(2, 5) [62]</li></ul></li><li><p>노드 3</p><ul><li>(3, 5) [20]</li><li>(3, 6) [37]</li></ul></li><li><p>노드 4</p><ul><li>(4, 7) [13]</li></ul></li><li><p>노드 3</p><ul><li>(5, 6) [45]</li><li>(5, 7) [73]</li></ul></li></ul><p>우선 위와 같이 간선의 정보들을 저장한다. 노드 1부터 노드 7까지 연결된 모든 간선을 정보를 저장한 것이다. 6, 7이 정보가 없는 이유는 이미 다른 노드들의 간선 정보에 모두 포함되었기 때문이다. 이렇게 총 11개의 간선 정보를 간선의 비용을 기준으로 오름차순 정렬을 수행해보자.</p><ul><li>정렬된 간선 정보<ul><li>(1, 7) [12]</li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><p>이제 다음과 같은 규칙에 따라 그래프를 연결하면 된다.</p><ol><li>정렬된 순서에 맞게 그래프에 포함시킨다.</li><li>포함시키기 전에는 사이클 테이블을 확인한다.</li><li>사이클을 형성하는 경우 간선을 포함하지 않는다.</li></ol><p>여기서 사이클은 그래프가 서로 연결되어 아래와 같이 사이클을 형성하는 경우이다. 최소 비용 신장 트리에서는 사이클이 발생하면 안된다. 모든 노드를 연결하기만 하면 되는데 사이클이 발생한다는 것은 이미 연결된 노드끼리 다시 연결한다는 뜻이기 때문이다.</p><div style="width: 300px; height: 400px;">    <img src="https://kyu9341.github.io/img/kruskal2.png" style="width: 300px    ; height: 400px;"></div><p>사이클이 발생의 여부는 저번 포스팅의 Union-Find 알고리즘을 적용하여 구할 수 있다.</p><p>초기 상태는 다음과 같을 것이다.</p><ul><li>정렬된 간선 정보<ul><li>(1, 7) [12]</li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><ul><li>사이클 테이블<table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table></li></ul><p>이제 첫 번째 간선부터 시작하면</p><h5 id="첫-번째-간선-선택"><a href="#첫-번째-간선-선택" class="headerlink" title="첫 번째 간선 선택"></a>첫 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 170px; height: 150px;">      <img src="https://kyu9341.github.io/img/kruskal3.png" style="width: 170px      ; height: 150px;">  </div></li></ul><h5 id="두-번째-간선-선택"><a href="#두-번째-간선-선택" class="headerlink" title="두 번째 간선 선택"></a>두 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li>(1, 7) [12]</li><li><strong>(4, 7) [13]</strong></li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">5</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 280px; height: 180px;">      <img src="https://kyu9341.github.io/img/kruskal4.png" style="width: 280px      ; height: 180px;">  </div></li></ul><h5 id="세-번째-간선-선택"><a href="#세-번째-간선-선택" class="headerlink" title="세 번째 간선 선택"></a>세 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 300px;">      <img src="https://kyu9341.github.io/img/kruskal5.png" style="width: 300px      ; height: 300px;">  </div></li></ul><h5 id="네-번째-간선-선택"><a href="#네-번째-간선-선택" class="headerlink" title="네 번째 간선 선택"></a>네 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal6.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="다섯-번째-간선-선택"><a href="#다섯-번째-간선-선택" class="headerlink" title="다섯 번째 간선 선택"></a>다섯 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal7.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="여섯-번째-간선-선택"><a href="#여섯-번째-간선-선택" class="headerlink" title="여섯 번째 간선 선택"></a>여섯 번째 간선 선택</h5><ul><li>정렬된 간선 정보<ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><p>이 때 1과 4가 이미 연결되어 있으므로 무시하고 넘어간다. 사이클 테이블의 값이 서로 동일한 것을 보면 된다.</p><ul><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal7.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="일곱-번째-간선-선택"><a href="#일곱-번째-간선-선택" class="headerlink" title="일곱 번째 간선 선택"></a>일곱 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li><strong>(3, 6) [37]</strong></li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal8.png" style="width: 300px      ; height: 400px;">  </div></li></ul><p>위와 같이 사이클 테이블의 값이 모두 1이 되며 최소 비용 신장 트리가 완성된 것을 볼 수 있다. 나머지 남은 4개의 간선은 모두 연결되어 있으므로 스킵하여 다음과 같이 완성된다.</p><h5 id="완성"><a href="#완성" class="headerlink" title="완성"></a>완성</h5><ul><li>정렬된 간선 정보<ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li><strong>(3, 6) [37]</strong></li><li><del>(5, 6) [45]</del></li><li><del>(2, 5) [62]</del></li><li><del>(1, 2) [67]</del></li><li><del>(5, 7) [73]</del></li></ul></li></ul><ul><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal9.png" style="width: 300px      ; height: 400px;">  </div></li></ul><p>따라서 총 비용은 12 + 13 + 17 + 20 + 24 + 37 = 123 이 된다. 코드로 구현해 보면 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> // 하나의 간선 정보를 담는 클래스</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">2</span>]; <span class="comment">// 서로 연결된 두 개의 노드 정보</span></span><br><span class="line"><span class="keyword">int</span> distance; <span class="comment">// 비용 정보</span></span><br><span class="line">Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> distance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;node[<span class="number">0</span>] = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;node[<span class="number">1</span>] = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;distance = distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Edge &amp;edge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;distance &lt; edge.distance; <span class="comment">// 거리가 작은 간선이 먼저 출력</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부모 노드를 찾는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="keyword">return</span> x; <span class="comment">// 부모 노드가 자신인 경우 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> parent[x] = getParent(parent, parent[x]);</span><br><span class="line"><span class="comment">// 부모 노드의 값과 자신이 다르다면 재귀 호출</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 부모 노드를 합치는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) parent[b] = a; <span class="comment">// 더 작은 값을 부모 노드로 지정</span></span><br><span class="line"><span class="keyword">else</span> parent[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 같은 부모를 가지는지 확인</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 같은 부모를 가진다면 1을 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 다르다면 0리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> node = <span class="number">7</span>; <span class="comment">// 노드의 개수</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">line</span> = <span class="number">11</span>; <span class="comment">// 간선의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; v; <span class="comment">// 간선 정보를 담을 벡터</span></span><br><span class="line"><span class="comment">// 11개의 간선 정보를 벡터에 담음</span></span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">7</span>, <span class="number">12</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">28</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">67</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">5</span>, <span class="number">17</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">62</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">20</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">3</span>, <span class="number">6</span>, <span class="number">37</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">45</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">5</span>, <span class="number">7</span>, <span class="number">73</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 간선의 비용을 기준으로 오름차순 정렬</span></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 각 정점이 포함된 그래프가 어디인지 저장</span></span><br><span class="line"><span class="keyword">int</span> parent[node];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 합계</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123; <span class="comment">// 사이클이 발생하지 않는 경우 그래프에 포함</span></span><br><span class="line"><span class="keyword">if</span> (!findParent(parent, v[i].node[<span class="number">0</span>] - <span class="number">1</span>, v[i].node[<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">&#123; <span class="comment">// parent[]는 0부터 시작했기 때문에 각 노드 번호에서 1을 빼줘야 일치함</span></span><br><span class="line">sum += v[i].distance; <span class="comment">// 연결한 노드의 거리를 누적</span></span><br><span class="line">unionParent(parent, v[i].node[<span class="number">0</span>] - <span class="number">1</span>, v[i].node[<span class="number">1</span>] - <span class="number">1</span>); <span class="comment">// 연결되었으므로 부모를 합침</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 합계 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/kruskal10.png" style="width: 100px     ; height: 50px;"> </div><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230994142" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230994142</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;크루스칼-Kruskal-Algorithm&quot;&gt;&lt;a href=&quot;#크루스칼-Kruskal-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;크루스칼(Kruskal Algorithm)&quot;&gt;&lt;/a&gt;크루스칼(Kruskal Algori
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>합집합 찾기(Union-Find) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/05/algorithmUnion-Find/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/05/algorithmUnion-Find/</id>
    <published>2020-01-05T05:59:47.000Z</published>
    <updated>2020-01-10T09:00:18.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="합집합-찾기-Union-Find"><a href="#합집합-찾기-Union-Find" class="headerlink" title="합집합 찾기(Union-Find)"></a>합집합 찾기(Union-Find)</h2><ul><li>Union-Find는 대표적인 그래프 알고리즘이며 서로소 집합(Disjoint-Set) 알고리즘이라고도 부른다.</li><li>여러 개의 노드가 존재할 때 두 개의 노드를 선택해서 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.</li><li>Union-Find는 두 가지 연산으로 이루어져 있다.<ul><li>Find() : x가 어떤 집합에 포함디어 있는지 찾는 연산</li><li>Union() : x와 y가 포함되어 있는 집합을 합치는 연산</li></ul></li></ul><p>다음의 그림을 보자</p>  <div style="width: 430px; height: 400px;">      <img src="https://kyu9341.github.io/img/uf1.png" style="width: 430px      ; height: 400px;">  </div><p>위와 같이 여러 개의 노드가 서로 자유분방하게 존재한다고 생각해보자. 이와 같이 모두 연결되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있을 때를 다음과 같이 표현할 수 있다. 모든 값이 자기 자신을 가리키도록 만드는 것이다. 아래 표에서 첫 행은 노드 번호를 의미하고 두 번째 행은 부모 노드 번호를 의미한다. 즉, 자신이 어떠한 부모 노드에 포함되어 있는지를 의미한다.</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table>  <div style="width: 430px; height: 400px;">      <img src="https://kyu9341.github.io/img/uf2.png" style="width: 430px      ; height: 400px;">  </div><p>이 때 위와 같이 1과 2가 연결되었다고 해보자. 이러한 연결성을 프로그래밍 언어로 어떻게 표현할 수 있을 지에 대한 내용이 Union-Find라고 생각하면 된다.</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table><p>  1과 2의 연결성을 위와 같이 표현할 수 있다. 2번째 인덱스의 값에 1이 들어가는 것이다. 이렇게 부모를 합칠 때는 <strong>일반적으로 더 작은 값 쪽으로</strong> 합치게 된다. 이것을 Union()이라고 볼 수 있다.</p>  <div style="width: 430px; height: 400px;">      <img src="https://kyu9341.github.io/img/uf3.png" style="width: 430px      ; height: 400px;">  </div><p>이제 위와 같이 2와 3도 연결되었다면</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table><p>위와 같이 표현할 수 있는데, 여기서는 1과 3이 연결되었는지 어떻게 파악할 수 있을까? 1과 3은 부모가 각각 1과 2로 다르기 때문에 부모 노드만 보고는 한번에 파악할 수 없다. 그렇기 때문에 <strong>재귀 함수</strong> 가 사용된다.</p><p>3의 부모를 찾기 위해서 먼저 3이 가리키는 2를 찾는다. 2는 부모인 1을 가리키고 있으므로 3의 부모는 1이 되는 것이다. 이러한 과정은 재귀적으로 수행될 때 효과적으로 표현할 수 있다. 그래서 결과적으로 합침(Union)연산이 모두 수행되고 나면 다음과 같이 표가 구성된다.</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table><p>노드 1, 2, 3의 부모가 모두 1이기 때문에 이 세 가지 노드는 모두 같은 그래프에 속한다고 할 수 있다. 이것이 Union-Find이다. Find알고리즘은 두 개의 노드의 부모 노드를 확인하여 현재 같은 집합에 속하는지를 확인하는 알고리즘이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부모 노드를 찾는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="keyword">return</span> x; <span class="comment">// 부모 노드가 자신인 경우 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> parent[x] = getParent(parent, parent[x]);</span><br><span class="line"><span class="comment">// 부모 노드의 값과 자신이 다르다면 재귀 호출</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 부모 노드를 합치는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) parent[b] = a; <span class="comment">// 더 작은 값을 부모 노드로 지정</span></span><br><span class="line"><span class="keyword">else</span> parent[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 같은 부모를 가지는지 확인</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 같은 부모를 가진다면 1을 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 다르다면 0리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b; <span class="comment">// 연결을 확인할 두 노드 번호</span></span><br><span class="line"><span class="keyword">int</span> parent[<span class="number">11</span>]; <span class="comment">// 각 노드의 부모를 담을 배열 (인덱스 : 자식 노드, 값 : 부모 노드)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line">unionParent(parent, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">unionParent(parent, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"연결되어 있는지 확인할 노드 번호 : "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"와 "</span> &lt;&lt; b &lt;&lt; <span class="string">"의 연결 여부 : "</span> &lt;&lt; findParent(parent, a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/uf.png" style="width: 300px     ; height: 100px;"> </div><p>위와 같은 상태에서는 1과 3이 연결되어 있는 것을 볼 수 있으며 unionParent()함수를 사용하여 다른 노드의 부모 노드를 연결하면 연결한 노드의 연결 여부가 정상적으로 출력되는 것을 확인할 수 있을 것이다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230967614" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230967614</a><br><a href="https://brenden.tistory.com/33?category=747314" target="_blank" rel="external nofollow noopener noreferrer">https://brenden.tistory.com/33?category=747314</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;합집합-찾기-Union-Find&quot;&gt;&lt;a href=&quot;#합집합-찾기-Union-Find&quot; class=&quot;headerlink&quot; title=&quot;합집합 찾기(Union-Find)&quot;&gt;&lt;/a&gt;합집합 찾기(Union-Find)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Un
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>깊이 우선 탐색(Depth First Search, DFS) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/03/algorithmDFS/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/03/algorithmDFS/</id>
    <published>2020-01-03T06:11:01.000Z</published>
    <updated>2020-01-11T06:03:32.807Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 깊이 우선 탐색에 대해 알아보자.</p><h2 id="깊이-우선-탐색-Depth-First-Search-DFS"><a href="#깊이-우선-탐색-Depth-First-Search-DFS" class="headerlink" title="깊이 우선 탐색(Depth First Search, DFS)"></a>깊이 우선 탐색(Depth First Search, DFS)</h2><blockquote><p>깊이 우선 탐색(depth-first search: DFS)은 맹목적 탐색방법의 하나로 탐색트리의 최근에 첨가된 노드를 선택하고, 이 노드에 적용 가능한 동작자 중 하나를 적용하여 트리에 다음 수준(level)의 한 개의 자식노드를 첨가하며, 첨가된 자식 노드가 목표노드일 때까지 앞의 자식 노드의 첨가 과정을 반복해 가는 방식이다.<br>출처 : 위키백과</p></blockquote><p>깊이 우선 탐색(Depth First Search)은 탐색을 함에 있어서 보다 깊은 것을 우선적으로 탐색하는 알고리즘이다. 이러한 깊이 우선 탐색은 맹목적으로 각 노드를 탐색할 때 주로 사용된다. <strong>너비 우선 탐색(Breadth First Search)</strong> 에서는 큐(Queue)가 사용되었다면 <strong>깊이 우선 탐색(Depth First Search)</strong> 에서는 스택(Stack)이 사용된다. 더하여 사실 스택을 사용하지 않아도 구현이 가능하다는 특징이 있다. 컴퓨터는 구조적으로 항상 스택의 원리를 사용하기 때문이다.</p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>자기 자신을 호출하는 순환 알고리즘의 형태를 가진다.</li><li>그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.</li></ul><p>다음의 그림을 보자</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/bfs1.png" style="width: 460px    ; height: 460px;"></div><p>DFS는 맨 처음에 시작 노드(Start Node)를 스택에 삽입하면서 시작한다. 또한 시작 노드를 방문했다고 <strong>방문 처리</strong> 를 해주도록 한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs1.png" style="width: 460px    ; height: 460px;"></div><p>이제 BFS는 다음과 같은 알고리즘에 의해 동작한다.</p><ol><li>스택의 최상단 노드를 확인한다.</li><li>최상단 노드에게 방문하지 않은 인접 노드가 있으면 그 노드를 스택에 넣고 방문처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 뺀다.</li></ol><p>위의 1번과 2번을 계속해서 반복하면 된다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs3.png" style="width: 460px    ; height: 460px;"></div><p>스택에 있던 최상단 노드가 1번 노드이므로 인접한 노드 중 방문하지 않은 2번 노드를 삽입한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs4.png" style="width: 460px    ; height: 460px;"></div><p>이후에 2번 노드의 인접 노드 중 방문하지 않은 노드인 3번 노드를 스택에 삽입한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs5.png" style="width: 460px    ; height: 460px;"></div><p>이어서 3번 노드의 인접 노드 중 방문하지 않은 6번 노드를 스택에 삽입</p> <div style="width: 460px; height: 460px;">     <img src="https://kyu9341.github.io/img/dfs6.png" style="width: 460px     ; height: 460px;"> </div><p>6번 노드의 인접 노드 중 방문하지 않은 7번 노드를 삽입</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs8.png" style="width: 460px    ; height: 460px;"></div><p>7번 노드, 6번 노드, 3번 노드는 인접 노드를 모두 방문하였기 때문에 스택에서 빠져나오게 된다. 이후에 2번 노드를 보았을 때 인접 노드인 4번 노드를 아직 방문하지 않았으므로 스택에 넣는다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs9.png" style="width: 460px    ; height: 460px;"></div><p>결과적으로 4번 노드의 인접 노드인 5번 노드가 스택에 들어가고 이후에 스택에서 하나씩 다 노드들이 빠져나오게 된다. 결과적으로 다음 그림과 같다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs10.png" style="width: 460px    ; height: 460px;"></div><p>따라서 방문 경로는 1 - 2 - 3 - 6 - 7 - 4 - 5 이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">8</span>]; <span class="comment">// 방문한 노드인지 기록</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">8</span>]; <span class="comment">// 그래프를 표현할 벡터</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x]) <span class="keyword">return</span>; <span class="comment">// 방문했던 노드면 리턴</span></span><br><span class="line">c[x] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[x].<span class="built_in">size</span>(); i++) <span class="comment">// 각 벡터에 연결된 노드 수만큼 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = a[x][i]; <span class="comment">// 현재 노드</span></span><br><span class="line">dfs(y); <span class="comment">// 재귀 함수로 스택을 구현</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1과 2를 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">2</span>);</span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1과 3을 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2와 3을 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 4를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">4</span>);</span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 5를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3과 6을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">6</span>);</span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3과 7을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 4와 5를 연결</span></span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 6과 7을 연결</span></span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// BFS 수행</span></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/dfs.png" style="width: 300px     ; height: 100px;"> </div><p>결과는 위와 같이  1 - 2 - 3 - 6 - 7 - 4 - 5 의 순서로 탐색이 된 것을 확인할 수 있다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230945092" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230945092</a><br><a href="https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89</a><br><a href="https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 깊이 우선 탐색에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;깊이-우선-탐색-Depth-First-Search-DFS&quot;&gt;&lt;a href=&quot;#깊이-우선-탐색-Depth-First-Search-DFS&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>너비 우선 탐색(Breadth First Search, BFS) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/03/algorithmBFS/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/03/algorithmBFS/</id>
    <published>2020-01-03T02:58:21.000Z</published>
    <updated>2020-01-11T06:07:22.564Z</updated>
    
    <content type="html"><![CDATA[<p>드디어 정렬 알고리즘이 끝나고 탐색 알고리즘이다. 이번 포스팅에서는 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘에 대해 알아보자.</p><h2 id="너비-우선-탐색-Breadth-First-Search-BFS"><a href="#너비-우선-탐색-Breadth-First-Search-BFS" class="headerlink" title="너비 우선 탐색(Breadth First Search, BFS)"></a>너비 우선 탐색(Breadth First Search, BFS)</h2><blockquote><p>너비 우선 탐색(Breadth-first search, BFS)은 맹목적 탐색방법의 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다. 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서도 너비 우선 검색을 적용한다. OPEN List 는 큐를 사용해야만 레벨 순서대로 접근이 가능하다.<br>출처 : 위키백과</p></blockquote><p>너비 우선 탐색은 맹목적인 탐색을 하고자 할 때 사용할 수 있는 탐색 기법이다. 최단 경로를 찾아준다는 점에서 최단길이를 보장해야 할 때 많이 사용된다.</p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.</li><li>BFS는 재귀적으로 동작하지 않는다.</li><li>그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.</li><li>BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(Queue)를 사용한다.</li></ul><p>다음의 그림을 보자</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/bfs1.png" style="width: 460px    ; height: 460px;"></div><p>BFS는 맨 처음에 시작 노드(Start Node)를 큐에 삽입하면서 시작한다. 또한 시작 노드를 방문했다고 <strong>방문 처리</strong> 를 해주도록 한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/bfs2.png" style="width: 460px    ; height: 460px;"></div><p>이제 BFS는 다음과 같은 알고리즘에 의해 동작한다.</p><ol><li>큐에서 하나의 노드를 꺼낸다.</li><li>해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입한다.</li></ol><p>위의 1번과 2번을 계속해서 반복하면 된다.</p><div style="width: 460px; height: 530px;">    <img src="https://kyu9341.github.io/img/bfs3.png" style="width: 460px    ; height: 530px;"></div><p>먼저 시작 노드 1을 큐에서 꺼냈다. 그리고 주변 노드인 2와 3이 모두 방문된 적이 없으므로 큐에 넣어준다. 결과는 위와 같다.</p><div style="width: 460px; height: 530px;">    <img src="https://kyu9341.github.io/img/bfs4.png" style="width: 460px    ; height: 530px;"></div><p>큐에서 2를 꺼낸 직후에는 그 인접한 노드 1, 3, 4, 5 중에서 1과 3은 이미 방문한 적이 있으므로 패스하고 4와 5를 큐에 삽입한다.</p><div style="width: 460px; height: 530px;">    <img src="https://kyu9341.github.io/img/bfs5.png" style="width: 460px    ; height: 530px;"></div><p> 이후에 노드 3을 큐에서 꺼낸 뒤 인접한 노드인 6과 7을 삽입한다. 노드 1과 노드 2는 방문한 적이 있으므로 6과 7만 큐에 넣어주면 된다. 따라서 위와 같이 기본적으로 모든 노드가 방문처리가 되었다. 이제 남은 노드들을 큐에서 꺼내주기만 하면 된다.</p> <div style="width: 570px; height: 530px;">     <img src="https://kyu9341.github.io/img/bfs6.png" style="width: 570px     ; height: 530px;"> </div><p>차례대로 꺼내면 위와 같이 된다. 큐에서 꺼낸 순서를 보면 1, 2, 3, 4, 5, 6, 7이다. 아무렇게나 탐색하는 것이 아니라 이와 같이 1부터 ‘가까운’ 노드들 부터 탐색이 이루어진다는 점에서 너비 우선 탐색이라고 한다. 거리가 먼 노드인 4, 5, 6, 7은 가장 마지막에 탐색이 이루어지게 된다. C++코드로 구현하게 되면 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">8</span>]; <span class="comment">// 방문한 노드인지 기록</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">8</span>]; <span class="comment">// 그래프를 표현할 벡터</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(start); <span class="comment">// 첫 번째 노드 큐에 삽입</span></span><br><span class="line">c[start] = <span class="literal">true</span>; <span class="comment">// 시작 노드 방문 처리</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); <span class="comment">// 맨 앞의 원소 저장</span></span><br><span class="line">q.pop(); <span class="comment">// 맨 앞의 원소 삭제</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[x].<span class="built_in">size</span>(); i++) <span class="comment">// 각 벡터에 연결된 노드 수만큼 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = a[x][i]; <span class="comment">// 현재 노드</span></span><br><span class="line"><span class="keyword">if</span> (!c[y]) <span class="comment">// 방문했었는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(y); <span class="comment">// 아직 방문하지 않은 노드들을 큐에 삽입</span></span><br><span class="line">c[y] = <span class="literal">true</span>; <span class="comment">// 해당 원소 방문 처리</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1과 2를 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">2</span>);</span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1과 3을 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2와 3을 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 4를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">4</span>);</span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 5를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3과 6을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">6</span>);</span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3과 7을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 4와 5를 연결</span></span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 6과 7을 연결</span></span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// BFS 수행</span></span><br><span class="line">bfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/bfs.png" style="width: 300px     ; height: 100px;"> </div><p>결과는 위와 같이 1 2 3 4 5 6 7의 순서로 탐색이 된 것을 확인할 수 있다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230944971" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230944971</a><br><a href="https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89</a><br><a href="https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;드디어 정렬 알고리즘이 끝나고 탐색 알고리즘이다. 이번 포스팅에서는 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;너비-우선-탐색-Breadth-First-Search-BFS&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) STL (라이브러리)</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/03/C3/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/03/C3/</id>
    <published>2020-01-03T01:52:18.000Z</published>
    <updated>2020-01-12T05:01:00.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL-이란"><a href="#STL-이란" class="headerlink" title="STL 이란?"></a>STL 이란?</h2><ul><li>Standard Template Library의 약자로서 C++에서 제공하는 템플릿 기반 표준 라이브러리이다.</li><li>프로그램에 필요한 자료구조와 알고리즘을 Template로 제공하는 라이브러리</li><li>STL라이브러리는 크게 STL 컨테이너(Container)와 STL 알고리즘(Algorithm)으로 구성되어 있다.</li></ul><h3 id="STL-컨테이너-Container"><a href="#STL-컨테이너-Container" class="headerlink" title="STL 컨테이너(Container)"></a>STL 컨테이너(Container)</h3><p>STL 컨테이너는 데이터를 보관하고 관리하기 위한 여러가지 기능을 제공한다.</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><ul><li>동적 배열이므로 배열의 크기를 변경할 수 있다.</li><li>임의 접근이 가능하며, 뒤에서의 삽입이 빠르다.</li><li>삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1)보장</li><li>Java의 ArrayList와 동일하다고 볼 수있다.</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>연결리스트이므로 데이터를 순차적으로 접근하고 관리할 때 유용하다.</li><li>위치에 관계없이 삽입과 삭제가 빠르다.</li><li>삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1)보장</li></ul><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><ul><li>덱, 데크라고 한다.</li><li>임의 접근이 가능하며 앞과 뒤에서의 삽입이 빠르다.</li><li>삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1)보장</li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul><li>특정 키(key)로 데이터를 접근하고 관리할 수 있다.</li><li>키로 값에 접근하며 삽입과 삭제가 빠르다.</li><li>삽입, 삭제, 탐색 모두 O(log n) 보장</li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li>원소를 순서대로 관리하며 소속 검사와 삽입, 삭제가 빠르다.</li><li>중복된 원소를 허용하지 않는다.</li><li>삽입, 삭제, 탐색 모두 O(log n) 보장</li></ul><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><ul><li>top에서만 삽입과 삭제가 가능하다.</li><li>LIFO(Last In First Out)방식으로 데이터를 삽입, 삭제한다.(후입선출)</li><li>삽입, 삭제 O(1) 보장</li></ul><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><ul><li>삽입은 뒤쪽에서, 삭제는 앞쪽에서 수행한다.</li><li>FIFO(First In First Out)방식으로 데이터를 삽입, 삭제한다.(선입선출)</li><li>삽입, 삭제 O(1) 보장</li></ul><p>STL 컨테이너는 데이터를 저장하는 방식과 삽입, 정렬, 삭제하는 관리 방식에 따라 크게 세 가지 부류로 나눠볼 수 있다.</p><ul><li><p>순차 컨테이너</p><ul><li>데이터를 순차적으로 저장하는 가장 일반적인 컨테이너</li><li>삽입된 데이터를 저장할 때 별도의 제약이나 관리 규칙을 갖지 않는다.</li><li>임의의 위치에 원소를 삽입하거나 삭제할 수 있다.</li><li>vector, list, deque 등이 속한다.</li></ul></li><li><p>연관 컨테이너</p><ul><li>데이터를 무조건 저장만 하는 것이 아니라 일정한 규칙에 따라서 데이터를 관리하는 컨테이너</li><li>정렬이나 해시 등의 방법을 통해 삽입되는 데이터를 항상 일정한 기준에 맞는 위치에 저장하므로 검색 속도가 빠르다.</li><li>set, map 등이 속한다.</li></ul></li><li><p>어댑터 컨테이너</p><ul><li>순차 컨테이너를 변형하여 데이터를 미리 정해진 방식에 따라 관리한다.</li><li>데이터를 삽입하고 제거하는 순서가 항상 컨테이너의 규칙에 의해 결정된다.</li><li>stack, queue, priority_queue 등이 속한다.</li></ul></li></ul><p>STL 컨테이너는 공통적으로 <strong>iterator 클래스를 제공</strong> 한다.<br>iterator는 반복자라고도 하는데 마치 포인터처럼 STL컨테이너의 특정 위치를 나타내는 역할을 한다.</p><ul><li>++연산자를 이용해 다음 원소를 가리키도록 변경할 수 있고, * 연산자를 통해 해당 원소에 접근할 수 도 있다.</li><li>list.begin(), list.end()와 같은 함수를 제공하는대 begin은 컨테이너의 가장 처음, end는 컨테이너의 마지막 위치를 가리킨다.</li></ul><h3 id="STL-알고리즘-Algorithm"><a href="#STL-알고리즘-Algorithm" class="headerlink" title="STL 알고리즘(Algorithm)"></a>STL 알고리즘(Algorithm)</h3><p>STL 알고리즘은 STL이 제공하는 범용 함수를 말한다.<br>정렬이나 검색처럼 프로그램에 구현에 자주 사용되는 기능을 함수 템플릿으로 준비해둔 것.</p><p>STL 알고리즘은 크게 네 가지로 분류 할 수 있다.</p><ul><li><p>변경 불가 시퀀스 알고리즘 (find, for_each)</p></li><li><p>변경 가능 시퀀스 알고리즘 (copy, generate, remove, replace, fill, swap, reverse, transform)</p></li><li><p>정렬 관련 알고리즘 (sort, binary_search, merge)</p></li><li><p>범용 수치 알고리즘 (accumulate, inner_product)</p></li></ul><blockquote><p>참조<br><a href="https://wonjayk.tistory.com/208?category=535160" target="_blank" rel="external nofollow noopener noreferrer">https://wonjayk.tistory.com/208?category=535160</a><br><a href="https://blockdmask.tistory.com/67?category=249379" target="_blank" rel="external nofollow noopener noreferrer">https://blockdmask.tistory.com/67?category=249379</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;STL-이란&quot;&gt;&lt;a href=&quot;#STL-이란&quot; class=&quot;headerlink&quot; title=&quot;STL 이란?&quot;&gt;&lt;/a&gt;STL 이란?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Standard Template Library의 약자로서 C++에서 제공하는 템플릿
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>계수 정렬(Counting Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/02/algorithmCountingSort/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/02/algorithmCountingSort/</id>
    <published>2020-01-02T06:19:40.000Z</published>
    <updated>2020-01-03T01:33:48.615Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>계수 정렬(Counting Sort)</strong> 에 대해 알아보겠다. 지금까지 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬을 공부해 보았다. 이 중 가장 빠른 정렬 알고리즘의 시간 복잡도는 O(N*logN)이었다. 이번에 배울 계수 정렬은 시간 복잡도가 O(N)이다. 하지만 데이터의 범위에 대해 조건이 있는 경우만 아주 빠른 속도를 보여준다.</p><h2 id="계수-정렬-Counting-Sort"><a href="#계수-정렬-Counting-Sort" class="headerlink" title="계수 정렬(Counting Sort)"></a>계수 정렬(Counting Sort)</h2><blockquote><ul><li>원소간 비교하지 않고 각 원소가 .몇개 등장하는지 갯수를 세어 정렬하는 방식이다.</li><li>모든 원소는 양의 정수이다.</li><li>시간 복잡도는 O(n + k)로 퀵 정렬, 병합정렬에 비해 일반적으로 빠르다.</li><li>정렬을 위한 길이 n의 배열 하나, 계수를 위한 길이 k의 배열 하나. O(n + k)의 공간 복잡도를 가진다.</li></ul></blockquote><p>1, 3, 2, 4, 3, 2, 5, 3, 1, 2, 3, 4, 4, 3, 5, 1, 2, 3, 5, 2, 3, 1, 4, 3, 5, 1, 2, 1, 1, 1</p><hr><p>위와 같은 30개의 데이터를 정렬한다고 하자. 위의 데이터는 1부터 5 사이에 속한다는 특징이 있다. 이를 계수 정렬을 이용하여 정렬해 보도록 하겠다. 계수 정렬은 단순하게 크기를 기준으로 세는 알고리즘이다.</p><p>지금까지는 모든 데이터를 그 자체로 위치를 바꾸어가면서 정렬하는 알고르즘에 대해 공부를 하였다. 이번에 다룰 계수 정렬은 크기를 기준으로 갯수만 세주면 되기 때문에 위치를 바꿀 필요가 없다. 또한 모든 데이터에 한 번씩만 접근하면 된다는 점에서 효율적이다.</p><h6 id="초기-상태"><a href="#초기-상태" class="headerlink" title="초기 상태"></a>초기 상태</h6><p>1 3 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="1번째-상태"><a href="#1번째-상태" class="headerlink" title="1번째 상태"></a>1번째 상태</h6><p><strong>1</strong> 3 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="2번째-상태"><a href="#2번째-상태" class="headerlink" title="2번째 상태"></a>2번째 상태</h6><p><strong>1 3</strong> 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="3번째-상태"><a href="#3번째-상태" class="headerlink" title="3번째 상태"></a>3번째 상태</h6><p><strong>1 3 2</strong> 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="4번째-상태"><a href="#4번째-상태" class="headerlink" title="4번째 상태"></a>4번째 상태</h6><p><strong>1 3 2 4</strong> 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><h6 id="5번째-상태"><a href="#5번째-상태" class="headerlink" title="5번째 상태"></a>5번째 상태</h6><p><strong>1 3 2 4 3</strong> 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>위와 같은 방식으로 해당 크기의 원소를 만나는 경우 숫자를 1씩 더해주면 된다. 이러한 방식을 계속해서 반복하면 다음과 같은 결과가 나온다.</p><h6 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h6><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">8</td><td align="center">6</td><td align="center">8</td><td align="center">4</td><td align="center">4</td></tr></tbody></table><p>이제 크기를 1부터 5까지 해당 숫자만큼 출력을 하면 된다. 즉, 1을 8번 출력하고 2를 6번, 3을 8번, 4를 4번, 5를 4번 출력하면 정렬이 이루어진다.</p><p>1 1 1 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 5 5 5 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count[<span class="number">6</span>]; <span class="comment">// 정렬할 수의 최댓값 + 1만큼 누적합 배열 할당</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">30</span>] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="comment">// 갯수를 카운트할 배열 초기화</span></span><br><span class="line">count[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) <span class="comment">// 각 크기의 갯수 카운트</span></span><br><span class="line">count[<span class="built_in">array</span>[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="comment">// 순서대로 갯수만큼 출력</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= count[i]; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드도 아주 간결하다. 데이터의 크기가 1부터 5 사이인 점에서 반복 또한 5번만 수행하면 된다. 모든 데이터의 크기 범위를 메모리 상에 표현할 수 있다면 O(N)이라는 압도적인 속도로 정렬을 수행할 수 있다는 것이다. 그러나 Counting Sort는 대부분의 상황에서 엄청난 메모리 낭비를 야기할 수 있다. 예를 들어, 1, 1, 3, 100 의 데이터를 정렬하기 위해서는 누적합 배열의 길이를 101로 잡는 메모리 낭비를 하게 된다. 만약 배열의 최댓값으로 10억이 포함되었다면 엄청난 낭비가 될 것이다. 이러한 문제점 때문에 위와 같이 범위가 특정한 상황에서만 주로 사용이 된다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221228361368" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221228361368</a><br><a href="https://yaboong.github.io/algorithms/2018/03/20/counting-sort/" target="_blank" rel="external nofollow noopener noreferrer">https://yaboong.github.io/algorithms/2018/03/20/counting-sort/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;계수 정렬(Counting Sort)&lt;/strong&gt; 에 대해 알아보겠다. 지금까지 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬을 공부해 보았다. 이 중 가장 빠른 정렬 알고리즘의 시간 복
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>힙 정렬(Heap Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/28/algorithmHeapSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/28/algorithmHeapSort/</id>
    <published>2019-12-28T09:53:12.000Z</published>
    <updated>2020-01-11T13:49:32.832Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>힙 정렬(Heap Sort)</strong> 에 대해 알아보겠다. 힙 정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 또한 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기 때문에 반드시 알고 넘어가야 하는 정렬 알고리즘이라고 한다. 힙 정렬은 힙 트리 구조(Heap Tree Structure)를 이용하는 정렬 방법이다.</p><h2 id="힙-정렬-Heap-Sort"><a href="#힙-정렬-Heap-Sort" class="headerlink" title="힙 정렬(Heap Sort)"></a>힙 정렬(Heap Sort)</h2><blockquote><p>힙 정렬(Heapsort)이란 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법으로서, 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다. 최대 힙을 구성하여 정렬하는 방법은 아래 예와 같다.</p><ol><li>n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다.</li><li>최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다.</li><li>가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다.</li><li>2와 3을 반복한다.<br>출처 - 위키백과</li></ol></blockquote><p>우선 힙(Heap)이 무엇인지 알아야 한다. 그리고 힙을 알기 전에 이진 트리(Binary Tree)에 대해 알아야 한다. 이진 트리란 컴퓨터 안에서 데이터를 표현할 때 데이터를 각 노드(Node)에 담은 뒤에 노드를 두 개씩 이어 붙이눈 구조이다. 이 때 트리 구조에 맞게 부모 노드에서 자식 노드로 가지가 뻗힌다. 이진 트리는 모든 노드의 자식 노드가 2개 이하인 노드이다.</p><ul><li><strong>이진 트리</strong> : 모든 노드의 자식 노드가 2개 이하인 트리 구조<div style="width: 380px; height: 380px;">  <img src="https://kyu9341.github.io/img/binarytree.png" style="width: 380px  ; height: 380px;"></div></li></ul><p>흔히 위와 같은 구조를 이진 트리라고 한다. <strong>여기서 트리(Tree)</strong> 라는 것은 말 그대로 가지를 뻗어나가는 것처럼 데이터가 서로 연결되어 있다는 것이다. 트리는 그 형태에 따라 종류가 다양한데 여기서는 위와 같은 이진 트리만 알면 된다. 이제 <strong>완전 이진 트리(Complete Binary Tree)</strong> 에 대해 알아보자.</p><p>완전 이진 트리는 데이터가 루트(Root)노드부터 시작하여 자식 노드가 왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가는 구조의 이진 트리이다. 즉, 완전 이진 트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽히 가득 찬 구조이다.</p><div style="width: 350px; height: 350px;">    <img src="https://kyu9341.github.io/img/cbt.png" style="width: 350px    ; height: 350px;"></div><p>이제 <strong>힙(Geap)</strong> 에 대해 알아보자. 힙은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다. 힙에는 최대 힙과 최소 힙이 존재하는데 최대 힙은 부모 노드가 자식 노드보다 큰 힙이며 최소 힙은 부모 노드가 자식 노드보다 작은 힙이다.</p><div style="width: 900px; height: 400px;">    <img src="https://kyu9341.github.io/img/heap.png" style="width: 900px    ; height: 400px;"></div><p>힙은 위와 같은 구조이며 일단 힙 정렬을 하기 위해서는 정해진 데이터를 힙 구조를 가지도록 만들어야 한다.</p><div style="width: 510px; height: 480px;">    <img src="https://kyu9341.github.io/img/heap1.png" style="width: 510px    ; height: 480px;"></div><p>힙 정렬을 수행하기 위해서는 <strong>힙 생성 알고리즘(Heapify Algorithm)</strong> 을 사용한다. 힙 생성 알고리즘은 특정한 하나의 노드에 대해서 수행하는 것이다. 또한 ‘하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태를 가정한다는 특징’이 있다. 위의 트리에서 5만 최대 힙 정렬을 수행해주면 전체 트리가 최대 힙 구조로 형성되는 상태이다.</p><p>힙 생성 알고리즘은 <strong>특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘</strong> 이다. 또한 위치를 바꾼 뒤에도 여전히 자식이 존재하는 경우 자식이 더이상 존재하지 않을때 까지 자식 중에서 더 큰 자식과 자신의 위치를 바꾸어야 한다. 즉, 위에서 5의 자식인 7과 4 중에서 더 큰 자식인 7과 5의 위치를 바꾸어 주면 된다. 바꾼 결과는 아래와 같다.</p><div style="width: 400px; height: 440px;">    <img src="https://kyu9341.github.io/img/heap2.png" style="width: 400px    ; height: 440px;"></div><p>위와 같이 힙 생성 알고리즘은 전체 트리를 힙 구조를 가지도록 만든다는 점에서 굉장히 중요한 알고리즘이다. 이러한 힙 생성 알고리즘의 시간 복잡도는 몇일까? 한 번 자식 노드로 내려갈 때마다 노드의 갯수가 2배씩 증가한다는 점에서 O(logN)이다. 예를 들어 데이터의 갯수가 1024개라면 10번 정도만 내려가도 된다는 뜻이다.</p><p>이제 예시를 보며 실제 힙 정렬 과정을 수행해보자.</p><p>7 6 5 8 3 5 9 1 6</p><p>위의 데이터를 오름차순으로 정렬한다고 해보자. 기본적으로 이진 트리를 표현하는 가장 쉬운 방법은 배열에 그대로 삽입하는 것이다. 현재 정렬할 데이터의 갯수가 9개이기 때문에 인덱스 0붙터 8까지 차례로 담아주면 된다.</p><table><thead><tr><th align="center"><center>0</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">7</td><td align="center">6</td><td align="center">5</td><td align="center">8</td><td align="center">3</td><td align="center">5</td><td align="center">9</td><td align="center">1</td><td align="center">6</td></tr></tbody></table><p>다시 말해 완전 이진 트리에 삽입이 되는 순서대로 인덱스를 붙여주는 것이다. 위 배열을 완전 이진 트리 형태로 출력하면 다음과 같다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt.png" style="width: 490px    ; height: 410px;"></div><p>말 그대로 배열에 있는 인덱스가 그대로 차례대로 트리로 표현된 것이다. 위와 같은 상황에서 힙 생성 알고리즘을 적용하여 전체 트리를 힙 구조로 만들면 된다. 이 때 데이터의 갯수가 N개 이므로 전체 트리를 힙 구조로 만드는 복잡도는 O(N*logN)이다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt1.png" style="width: 490px    ; height: 410px;"></div><p>그래서 결과적으로는 위와 같이 최대 힙이 구성된다. 이제부터 실제로 우리가 원하던 정렬을 직관적으로 수행할 수 있다. 루트(Root)에 있는 값을 가장 뒤쪽으로 보내면서 힙 트리의 크기를 1씩 빼주는 것이다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt2.png" style="width: 490px    ; height: 410px;"></div><p>위와 같이 9와 6을 바꾼 뒤에 9는 정렬이 완료된 것이므로 빨간색으로 표현한다. 이제 9를 제외하고 나머지 8개 원소를 기준으로 또 힙 생성 알고리즘(Heapify)를 수행한다. 결과는 다음과 같다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt3.png" style="width: 490px    ; height: 410px;"></div><p>이제 다시 가장 큰 숫자인 8이 루트에 존재한다. 이것을 가장 뒤쪽의 원소와 서로 바꾼다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt4.png" style="width: 490px    ; height: 410px;"></div><p>그럼 위와 같이 8과 9가 가장 뒤에 배열되어 정렬된 것을 볼 수 있다. 이제 이 과정을 반복하면 된다. 힙 생성 알고리즘의 시간 복잡도는 O(logN)이고 전체 데이터의 갯수가 N개이므로 결과적으로 힙 정렬의 시간 복잡도는 O(N*logN)이라고 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> heap[number] = &#123; <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">printArray(heap, number);</span><br><span class="line"><span class="comment">// 전체 트리 구조를 최대 힙 구조로 바꾼다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; number; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = i;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> root = (c - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 자기 자신의 부모를 의미</span></span><br><span class="line"><span class="keyword">if</span> (heap[root] &lt; heap[c]) <span class="comment">// 부모보다 자식이 크다면 위치를 바꿈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">c = root; <span class="comment">// 부모의 인덱스로 변환하여 0이 될때까지 올라감</span></span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">printArray(heap, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 크기를 줄여가며 반복적으로 힙을 구성</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = number - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 마지막 인덱스부터 시작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 가장 큰 값을 맨 뒤로 보냄</span></span><br><span class="line"><span class="keyword">int</span> temp = heap[<span class="number">0</span>];</span><br><span class="line">heap[<span class="number">0</span>] = heap[i];</span><br><span class="line">heap[i] = temp;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 자식 중에 더 큰 값 찾기</span></span><br><span class="line"><span class="comment">// 옆의 값과 비교하여 더 큰 값의 인덱스를 c에 지정</span></span><br><span class="line"><span class="keyword">if</span> (heap[c] &lt; heap[c + <span class="number">1</span>] &amp;&amp; c &lt; i - <span class="number">1</span>) <span class="comment">// 범위를 넘지 않는 한에서</span></span><br><span class="line">c++;</span><br><span class="line"><span class="comment">// 루트보다 자식이 더 크다면 교환</span></span><br><span class="line"><span class="keyword">if</span> (heap[root] &lt; heap[c] &amp;&amp; c &lt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">root = c; <span class="comment">// 자식의 인덱스로 변환하여 정렬되지 않은 마지막 인덱스까지 진행</span></span><br><span class="line">&#125; <span class="keyword">while</span> (c &lt; i); <span class="comment">// 정렬된 인덱스 전까지 반복</span></span><br><span class="line">printArray(heap, number);</span><br><span class="line">&#125;</span><br><span class="line">printArray(heap, number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최대 힙을 이용하여 위와 같이 힙 정렬을 작성할 수 있으며 진행 과정은 다음과 같다.</p><div style="width: 200px; height: 200px;">    <img src="https://kyu9341.github.io/img/heapsort.png" style="width: 200px    ; height: 200px;"></div><p>힙 정렬은 병합 정렬과 다르게 별도로 추가적인 배열이 필요하지 않다는 점에서 메모리 측면에서 매우 효율적이다. 또한 항상 O(N*logN)을 보장할 수 있다는 점에서 아주 강력한 알고리즘이다. 하지만 단순히 속도만 놓고 비교하면 퀵 정렬이 평균적으로 더 빠르기 때문에 힙 정렬이 일반적으로 많이 사용되지는 않는다고 한다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221228342808" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221228342808</a><br><a href="https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC</a><br><a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;힙 정렬(Heap Sort)&lt;/strong&gt; 에 대해 알아보겠다. 힙 정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 또한 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기 때문에 반드
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>병합 정렬(Merge Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/27/algorithmMergeSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/27/algorithmMergeSort/</id>
    <published>2019-12-27T11:44:19.000Z</published>
    <updated>2020-01-11T14:44:03.097Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>병합 정렬(Merge Sort)</strong> 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 ‘분할 정복’방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.</p><p>퀵 정렬은 피벗 값에 따라서 편향되게 분할할 가능성이 있다는 점에서 최악의 경우 O(N^2)의 시간 복잡도를 가지지만 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(N*logN)을 보장한다.</p><h2 id="병합-정렬-Merge-Sort"><a href="#병합-정렬-Merge-Sort" class="headerlink" title="병합 정렬(Merge Sort)"></a>병합 정렬(Merge Sort)</h2><blockquote><p>합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다. 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다. 존 폰 노이만이 1945년에 개발했다. 하향식 합병 정렬에 대한 자세한 설명과 분석은 1948년 초 헤르만 골드스타인과 폰 노이만의 보고서에 등장하였다.<br>합병 정렬은 다음과 같이 작동한다.</p><ol><li>리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는</li><li>분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.</li><li>정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.</li><li>결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.</li><li>복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.</li></ol><p>출처 - 위키백과</p></blockquote><p>병합 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할한 뒤에 각자계산하고 나중에 합치는 방법을 채택한다. 즉, 기본 아이디어는 일단 정확히 반으로 나누고 나중에 정렬하는 것이다.</p><div style="width: 750px; height: 500px;">    <img src="https://kyu9341.github.io/img/mergeSort.png" style="width: 750px    ; height: 500px;"></div>이미지 출처 : https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html<p>위의 그림처럼 초기 상태의 배열에서 각각 절반씩 계속해서 나누어 크기가 1인 배열로 나눈다. 이후 다시 크기가 1인 배열 두 개씩 병합하며 정렬을 수행한다.(1단계) 그럼 크기가 2인 배열 4개가 되었을 것이고, 4개의 배열은 정렬이 되어있다. 다시 4개의 배열을 두 개씩 병합하여 크기가 4인 배열 2개가 되고, 이 과정에서 정렬이 수행된다.(2단계) 마지막으로 크기가 4인 배열 2개를 병합하여 크기가 8인 배열로 돌아가며 정렬이 된다.(3단계) 이러한 과정으로 진행이 되는데 이때 병합되는 과정은 3단계로 이루어진다. 그 이유는 초기 배열의 크기가 8이기 때문에 log(2)8 = 3 단계가 필요한 것이다.</p><p>따라서, 크기가 N인 배열을 정렬한다면 단계는 log(2)N을 유지하게 된다. 또한 데이터의 갯수만큼만 연산하면 되기 때문에 정렬 자체에 필요한 수행시간은 N이다. 결과적으로 총 시간 복잡도는 O(N*logN)이 된다.</p><p>위에서 병합이 되는 순간 정렬이 같이 된다고 했다. 그 과정을 한번 살펴보자.</p><p>1단계에서는 배열의 크기가 1이기 때문에 두 수만 비교하여 작은 수를 앞에 두면 된다.</p><p>2단계에서는 크기가 2인 배열 두 개를 병합하게 되므로 우선 각 배열에서 가장 작은 값을 비교한다. 이때, 각 배열은 정렬되어있는 상태이기 때문에 두 배열의 가장 앞에 있는 값을 서로 비교한다. 위의 그림을 예로 들면 [10, 21]과 [12, 20]에서 먼저 10과 12를 비교하게 되는 것이다. 10이 더 작으므로 10을 새로 만들어질 배열의 맨 앞에 둔다.</p><p> 그럼 [10, 21]이 있던 배열은 21만 남아있는 상태일 것이다. 그럼 21이 가장 작은 원소이므로 21과 [12, 20]이 들어있는 배열의 최솟값 12와 비교를 하여 12가 더 작으므로 새로 만들어질 배열의 두번째 자리에 12가 들어간다. [10, 12, - , - ] 와 같은 상태일 것이며 이제 남은 [ - , 21] 과 [ - , 20]를 비교하여 더 작은 20이 먼저 들어가 [10, 12, 20, 21]과 같이 정렬이 수행된다.</p><p> 3단계에서도 2단계와 마찬가지로 두 배열의 최솟값 부터 비교하게 되며 이 과정이 반복되어 정렬이 완료된다.</p><p> 이러한 과정을 잘 보면 각 부분 집합은 이미 정렬이 된 상태이므로 이미 정렬된 두 배열을 합치는 것은 N번의 연산만 수행하면 된다. 즉 시간 복잡도 O(N)이면 되는 것이다. 즉, 가로축은 N 세로축은 logN이므로 총 시간 복잡도가 O(N*logN)인 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> sorted[number]; <span class="comment">// 정렬 배열은 반드시 전역 변수로 사용(추가적인 배열)</span></span><br><span class="line"><span class="comment">// 정렬을 수행할 때 추가적인 배열이 필요, 필요할 때마다 배열을 생성한다면 비효율적임</span></span><br><span class="line"><span class="comment">// 전역변수로 모든 함수가 공통적으로 사용하도록 하여 메모리 소모를 최소화</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> middle, <span class="keyword">int</span> n)</span> <span class="comment">// 두 개의 정렬된 부분 배열을 이용해 새롭게 정렬된 배열을 생성하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// m : 시작점 , middle : 중간점, n : 끝점</span></span><br><span class="line"><span class="keyword">int</span> i = m; <span class="comment">// 좌측 부분 배열의 시작점</span></span><br><span class="line"><span class="keyword">int</span> j = middle + <span class="number">1</span>; <span class="comment">// 우측 부분 배열의 시작점</span></span><br><span class="line"><span class="keyword">int</span> k = m; <span class="comment">// 새로운 배열의 시작점</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 작은 순서대로 배열에 삽입</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 남은 데이터 삽입</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; middle) <span class="comment">// 왼쪽 배열이 먼저 모두 삽입된 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = j; t &lt;= n; t++) <span class="comment">// 오른쪽 배열을 순서대로 삽입</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 오른쪽 배열이 먼저 모두 삽입된 경우, (j &gt; n)인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = i; t &lt;= middle; t++) <span class="comment">// 왼쪽 배열을 순서대로 삽입</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 정렬된 배열을 실제 배열에 삽입</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = m; t &lt;= n; t++)</span><br><span class="line">a[t] = sorted[t];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> middle;</span><br><span class="line"><span class="comment">// 크기가 1보다 큰 경우</span></span><br><span class="line"><span class="keyword">if</span> (m &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">middle = (m + n) / <span class="number">2</span>;</span><br><span class="line">mergeSort(a, m, middle);</span><br><span class="line">mergeSort(a, middle + <span class="number">1</span>, n);</span><br><span class="line">merge(a, m, middle, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[number] = &#123; <span class="number">21</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">22</span> &#125;;</span><br><span class="line">printArray(arr, number);</span><br><span class="line">mergeSort(arr, <span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line">printArray(arr, number);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/merge.png" style="width: 250px    ; height: 200px;"></div><p>진행 과정을 출력해보면 위와 같은 과정으로 진행이 되는 것을 확인할 수 있다.</p><p>병합 정렬을 구현할 때 신경써야 할 부분은 정렬에 사용되는 배열은 전역 변수로 선언해야 한다는 것이다. 만약 함수 안에서 배열을 선언하면 매 번 배열을 선언해야하기 때문에 메모리 낭비가 크다. 이와 같이 병합 정렬은 기존의 데이터를 담을 추가적인 배열 공간이 필요하다는 점에서 메모리 활용이 비효율적인 단점이 있다.</p><p>병합 정렬은 일반적인 경우 퀵 정렬보다 느리지만 어떠한 상황에서도 O(N*logN)을 보장한다는 점에서 아주 효율적인 알고리즘이다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221242106787" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221242106787</a><br><a href="https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC</a><br><a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;병합 정렬(Merge Sort)&lt;/strong&gt; 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 ‘분할 정복’방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>삽입 정렬(Insertion Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/22/algorithmInsertionSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/22/algorithmInsertionSort/</id>
    <published>2019-12-22T02:44:19.000Z</published>
    <updated>2020-01-03T01:21:24.091Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 삽입 정렬에 대해 알아보겠다. 앞서 다루었던 정렬 알고리즘과 같은 시간복잡도인 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속한다.</p><h2 id="삽입-정렬-Selection-Sort"><a href="#삽입-정렬-Selection-Sort" class="headerlink" title="삽입 정렬(Selection Sort)"></a>삽입 정렬(Selection Sort)</h2><blockquote><p>삽입 정렬(揷入整列, insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.</p><p>출처 - 위키백과</p></blockquote><p>삽입 정렬은 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결한다. 다른 정렬 방식들은 무조건 위치를 바꾸는 방식이었다면 삽입 정렬은 필요할 때만 위치를 바꾸게 된다. 이와 같은 특성 때문에 선택 정렬이나 버블 정렬보다 빠르며 특정한 경우에서는 아주 빠르게 동작하기도 한다.</p><p>삽입 정렬은 현재 위치의 숫자가 앞의 숫자들의 어느 위치에 들어갈지 찾아 적절한 위치에 삽입되는 방식이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, index, temp;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = temp;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>삽입 정렬은 위와 같이 구현할 수 있으며 진행 과정은 아래와 같다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/insertsort.png" style="width: 250px    ; height: 200px;"></div><p>중간 과정에도 앞부분은 계속해서 정렬이 되어있는 것을 확인할 수 있다. 삽입 정렬은 앞서 말했듯이 선택 정렬과 버블 정렬보다는 뛰어나지만 최악의 경우는 앞의 정렬 방식과 같은 수만큼 연산이 일어난다. (O(N^2)) 하지만 2 3 4 5 6 7 8 9 10 1 과 같이 거의 정렬이 된 상태의 경우에는 아주 빠른 속도로 정렬이 가능하다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226806398" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226806398</a><br><a href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 삽입 정렬에 대해 알아보겠다. 앞서 다루었던 정렬 알고리즘과 같은 시간복잡도인 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속한다.&lt;/p&gt;
&lt;h2 id=&quot;삽입-정렬-Selection-Sort&quot;&gt;&lt;a href=&quot;#삽입-정렬-Sele
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>퀵 정렬(Quick Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/22/algorithmQuickSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/22/algorithmQuickSort/</id>
    <published>2019-12-22T02:44:19.000Z</published>
    <updated>2020-01-03T01:20:25.295Z</updated>
    
    <content type="html"><![CDATA[<p>이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 그 대표적인 빠른 알고리즘이 <strong>퀵 정렬</strong> 알고리즘이다.</p><h2 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬(Quick Sort)"></a>퀵 정렬(Quick Sort)</h2><blockquote><p>퀵 정렬은 분할 정복(divide and conquer) 방법을 통해 리스트를 정렬한다.</p><ol><li><p>리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗이라고 한다.</p></li><li><p>피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.</p></li><li><p>분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.</p></li></ol><p>재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.</p><p>출처 - 위키백과</p></blockquote><p>퀵 정렬은 대표적인 ‘분할 정복’ 알고리즘으로 평균 속도가 O(N*logN)이다. 이때 logN은 사실상 거의 상수라고 해도 무방할 만큼 작은 수이다.</p><p>예를 들어, 2^10 이 약 1,000 이고 2^20이 약 1,000,000 이므로 N이 1,000,000이라 하더라도</p><div style="width: 100px; height: 20px;">    <img src="http://chart.apis.google.com/chart?cht=tx&chl= log_2N = 20" style="width: 100px; height: 20px;"></div><p>밖에 되지 않는다. 즉, 굉장히 빠르다는 것을 알 수 있다.</p><p>퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬한다. 더 쉽게 말하자면 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눈다.</p><p>일반적으로 퀵 정렬 같은 경우는 피벗 값을 설정할 때 가장 앞에 있는 수를 피벗 값으로 설정한다.</p><p><strong>3</strong> <strong>7</strong> 8 1 5 9 6 10 <strong>2</strong> 4 에서 시작한다고 하면 피벗 값은 3이다.</p><p>이후 <strong>왼쪽에서 오른쪽으로 이동하며 피벗 값보다 큰 값</strong> 을 찾고 <strong>오른쪽부터 왼쪽으로 이동하며 피벗 값보다 작은 값</strong> 을 찾는다. 찾으면 두 값의 위치를 바꾸어준다.</p><p><strong>3</strong> 2 <strong>8 1</strong> 5 9 6 10 7 4</p><p>피벗 값은 3으로 유지하고 같은 방식으로 왼쪽에서 큰 값(8)과 오른쪽에서 작은 값(1)을 구해 바꿔주면</p><p><strong>3</strong> 2 <strong>8 1</strong> 5 9 6 10 7 4</p><p>이 되며 한 번 더 수행하면 마찬가지로 8과 1 인데 엇갈린 상태가 된다. 즉, 작은 값의 인덱스가 큰 값의 인덱스보다 작아지게 되면 엇갈린 상태인 것이다. 이때는 왼쪽에 있는 값(더 작은값)과 피벗 값인 3과 바꿔주면 된다.</p><p>1 2 <strong>3</strong> 8 5 9 6 10 7 4</p><p>여기까지 된다면 3은 정렬이 된 것이고 한 번 분할이 완료된 것이다. 3보다 왼쪽에 있는 수들은 모두 3보다 작고, 3보다 오른쪽에 있는 수들은 모두 3보다 큰 특징을 가진다.</p><p>이제 왼쪽 집합과 오른쪽 집합으로 나누어 피벗 값을 각각 설정하고 다시 퀵 정렬을 수행하게 된다. 왼쪽 집합에서는 1이 피벗 값이고 오른쪽 집합에서는 8이 피벗 값이 된다. 먼저 왼쪽부터 보면 1보다 큰 값은 오른쪽에 있고 작은 값은 없지만 왼쪽에 있다고 가정하고 1이 정렬이 된다.</p><p><strong>1</strong> 2 <strong>3</strong> <strong>8</strong> 5 9 6 10 7 4</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 9 6 10 7 4</p><p>마찬가지로 2도 정렬이 되며 오른쪽 부분을 보면 왼쪽에서부터 8보다 큰 값인 9를 찾고 오른쪽에서부터 8보다 작은 4를 찾게된다. 지금은 엇갈리지 않았으므로 9와 4를 바꿔준다.</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 4 6 10 7 9</p><p>마찬가지로 10과 7을 선택하게 되고 바꿔준다.</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 4 6 7 10 9</p><p>여기서 한번 더 수행하면 7과 10이 엇갈린 상태이므로 7과 8의 위치가 바뀌어</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> 7 5 4 6 <strong>8</strong> 10 9</p><p>위와 같이 다시 8을 기준으로 왼쪽 집합과 오른쪽 집합으로 나뉘어 왼쪽은 8보다 작은 값들만, 오른쪽은 8보다 큰 값들만 모이게 된다.</p><p>이러한 과정을 계속해서 반복하면 모두 정렬이 수행된다.</p><p>퀵 정렬처럼 분할을 하여 연산을 하면 빠른 이유에 대해 조금 더 살펴보면</p><p>1 2 3 4 5 6 7 8 9 10 이 있을 때</p><p>N^2 = 10 * 10 = 100 인 반면</p><p>1 2 3 4 5 -&gt; 5 * 5 = 25</p><p>6 7 8 9 10 -&gt; 5 * 5 = 25</p><p>가 되므로 분할하여 구한 후 더하면 50이 되며 100보다 훨씬 작은 횟수의 연산으로 정렬을 수행할 수 있다. 이것이 분할 정복이 강력한 이유이다.</p><p>이때 2씩 계속해서 나누어지는 과정을 log_(2) N 으로 표현하게 된다.</p><p>즉, 데이터의 개수가 N이고 반씩 쪼개 들어가기 때문에 O(N*log_(2) N)이라고 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> <span class="comment">// start, end -&gt; 부분집합의 시작과 끝 인덱스</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>) <span class="keyword">return</span>; <span class="comment">// 원소가 1개인 경우</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key = start; <span class="comment">// 피벗 값 첫번째 원소의 인덱스</span></span><br><span class="line"><span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) <span class="comment">// 엇갈릴 때까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (data[i] &lt;= data[key]) <span class="comment">// 키 값보다 큰 값을 만날 때까지 이동</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (data[j] &gt;= data[key] &amp;&amp; j &gt; start) <span class="comment">// 키 값보다 작은 값을 만날 때까지 이동</span></span><br><span class="line">&#123; <span class="comment">// 범위를 넘어가지 않도록 j &gt; start를 걸어줌</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt; j) <span class="comment">// 현재 엇갈린 상태면 작은 값(j)을 키 값과 교체</span></span><br><span class="line">&#123;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j] = data[key];</span><br><span class="line">data[key] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 엇갈리지 않은 상태라면 i와 j를 교체</span></span><br><span class="line">&#123;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j] = data[i];</span><br><span class="line">data[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">quickSort(data, start, j - <span class="number">1</span>);</span><br><span class="line">quickSort(data, j + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[number] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">quickSort(data, <span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 : "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 재귀함수를 이용하여 작성할 수 있고 아래와 같이 정렬이 진행된다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/quicksort.png" style="width: 250px    ; height: 200px;"></div><p>퀵 정렬은 평균 시간 복잡도는 O(N*logN)이지만 최악의 경우 시간 복잡도는 O(N^2)이 되기도 한다. 이미 정렬이 되어있는 경우나 거의 정렬이 되어있는 경우에는 퀵 정렬의 효율이 매우 떨어진다. 반면 삽입 정렬은 이런 경우를 빠르게 해결할 수 있다. 즉, 정렬할 데이터의 특성에 따라 적절한 정렬 알고리즘을 사용하는 것이 중요하다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226813382" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226813382</a><br><a href="https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>버블정렬(Bubble Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/21/algorithmBubbleSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/21/algorithmBubbleSort/</id>
    <published>2019-12-21T08:31:15.000Z</published>
    <updated>2020-01-03T01:34:05.214Z</updated>
    
    <content type="html"><![CDATA[<p>저번 포스팅에서는 선택정렬에 대해 공부해보았고 이번에는 버블 정렬에 대해 알아보겠다. 마찬가지로 일련의 숫자들을 오름차순으로 정렬하는 문제이다.</p><h2 id="버블-정렬"><a href="#버블-정렬" class="headerlink" title="버블 정렬"></a>버블 정렬</h2><blockquote><p>거품 정렬(Bubble sort)은 두 인접한 원소를 검사하여 정렬하는 방법이다. 시간 복잡도가 O(n^2)로 상당히 느리지만, 코드가 단순하기 때문에 자주 사용된다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다.</p><p>출처 - 위키백과</p></blockquote><p>버블 정렬 또한 선택 정렬과 같이 아주 직관적인 해결방법인데 바로 가까이에 있는 두 숫자끼리 비교를 하여 더 작은 숫자를 앞으로 보내주는 것을 반복하는 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">9</span> - i; j++) <span class="comment">// 버블정렬은 뒤쪽부터 정렬이 되므로 9-i만큼만 반복하면 된다.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드로 표현할 수 있고 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 버블 정렬은 뒤쪽부터 정렬이 수행되는 것을 확인할 수 있다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/bubblesort.png" style="width: 250px    ; height: 200px;"></div><p>이제 시간복잡도를 확인해 보자. 버블 정렬도 선택 정렬과 마찬가지로 10 + 9 + 8 + 7 + 6 + 5 + .. + 1 만큼 연산을 수행하므로 O(N^2)으로 동일하지만 버블 정렬은 각 싸이클마다 모두 자리를 바꿔주는 연산을 수행하기 때문에 선택 정렬보다 훨씬 비효율적이고 정렬 알고르즘 중에 가장 느린 알고리즘이다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226803544" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226803544</a><br><a href="https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번 포스팅에서는 선택정렬에 대해 공부해보았고 이번에는 버블 정렬에 대해 알아보겠다. 마찬가지로 일련의 숫자들을 오름차순으로 정렬하는 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;버블-정렬&quot;&gt;&lt;a href=&quot;#버블-정렬&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>선택정렬(Selection Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/21/algorithmSelectionSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/21/algorithmSelectionSort/</id>
    <published>2019-12-21T05:12:42.000Z</published>
    <updated>2020-01-03T01:20:10.232Z</updated>
    
    <content type="html"><![CDATA[<p>이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주기 때문이라고 한다. 그래서 여러가지의 정렬 알고리즘을 먼저 배우고 알고리즘의 시간 복잡도에 대해 단계적으로 이해해 보자.</p><h2 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬(Selection Sort)"></a>선택 정렬(Selection Sort)</h2><blockquote><h3 id="선택-정렬"><a href="#선택-정렬" class="headerlink" title="선택 정렬"></a>선택 정렬</h3><p>선택 정렬은 제자리 정렬 알고리즘의 하나로, 다음와 같은 순서로 이루어진다.</p><ol><li>주어진 리스트 중에 최소값을 찾는다</li><li>그 값을 맨 앞에 위치한 값과 교체한다.(패스)</li><li>맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.</li></ol><p>출처 - 위키백과</p></blockquote><p>위의 설명처럼 선택 정렬은 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘이다. 예를 들어, 3 1 2 5 4 라는 순서의 숫자들을 오름차순으로 정렬한다고 생각해보자. 먼저 리스트의 최솟값을 구하여 가장 앞의 숫자와 위치를 바꾸게 되면 1이 최솟값이므로 3과 자리를 바꾸어 1 3 2 5 4 가 된다. 다음 1을 뺀 나머지의 리스트의 최솟값은 2 이므로 3과 자리를 바꾸어 1 2 3 5 4가 되고, 다음은 3이 최솟값이므로 넘어가서 같은 과정을 반복하면 1 2 3 4 5 로 오름차순 정렬이 끝나게 된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, <span class="built_in">min</span>, index, temp; <span class="comment">// min : 최솟값, index : 최솟값의 인덱스</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">min</span>) <span class="comment">// 최솟값을 구함</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = <span class="built_in">array</span>[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp = <span class="built_in">array</span>[i]; <span class="comment">// 최솟값과 자리 바꾸기</span></span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">min</span>;</span><br><span class="line"><span class="built_in">array</span>[index] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 선택정렬을 작성할 수 있다. 또한 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 선택 정렬은 앞쪽부터 정렬이 수행되는 것을 확인할 수 있다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/selectionsort.png" style="width: 250px    ; height: 200px;"></div><p>이제 선택 정렬을 수행하는데에 얼마만큼의 시간이 걸리는지를 시간복잡도로 표현할 수 있는데 계산 방법은 다음과 같다.</p><p> 1 2 3 4 5 6 7 8 9 10 의 10개의 수를 정렬한다고 생각하면</p><p> 10 + 9 + 8 + … + 1 의 수 만큼 비교연산을 수행해야 한다. 즉, 10 * (10 + 1) / 2 = 55</p><p> 이것을 등차수열의 식에 의해 표현하면 <strong>N * (N + 1) / 2</strong> 로 표현할 수 있다. 즉, 이 알고리즘의 수행시간을 앞의 수식처럼 표현할 수가 있다는 것이다. 이때 일반적으로 컴퓨터에서는 2로 나눈다거나 1을 더한다거나 하는 것은 N이 매우 커지는 경우에는 무시할 수 있기 때문에 간단하게 더하거나 나누거나 하는 연산들은 모두 무시를 하게 된다.(가장 큰 차수만 보고 판단) 따라서 위의 수식이 <strong>N * N</strong> 으로 표현 할 수 가있다는 것이다.</p><p> 이것을 O(N * N) =&gt; O(N^2)이라고 표시할 수 있는데 이와 같은 표기법은 특정한 알고리즘의 수행시간을 간략하게 표현하는 방법이며 O(Big-O) 표기법이라 한다.</p><p>일반적으로 정렬 알고리즘에서 N^2의 복잡도는 아주 비효율적이고 느린 속도라고 할 수 있다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226800661" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226800661</a><br><a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

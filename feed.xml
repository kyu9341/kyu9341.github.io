<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-03-26T16:15:08.406Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 18808번 스티커 붙이기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/27/algorithm18808/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/27/algorithm18808/</id>
    <published>2020-03-26T16:10:12.000Z</published>
    <updated>2020-03-26T16:15:08.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-18808"><a href="#Problem-18808" class="headerlink" title="Problem 18808"></a>Problem 18808</h1><h2 id="스티커-붙이기"><a href="#스티커-붙이기" class="headerlink" title="스티커 붙이기"></a>스티커 붙이기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>R혜윤이는 최근에 다양한 대회를 참여하면서 노트북에 붙일 수 있는 스티커들을 많이 받았다. 스티커는 아래와 같이 사각 모눈종이 위에 인쇄되어 있으며, 스티커의 각 칸은 상하좌우로 모두 연결되어 있다. 또한 모눈종이의 크기는 스티커의 크기에 꼭 맞아서, 상하좌우에 스티커가 포함되지 않는 불필요한 행이나 열이 존재하지 않는다.</p><p>아래는 올바른 모눈종이의 예시이다. 주황색 칸은 스티커가 붙은 칸을, 하얀색 칸은 스티커가 붙지 않은 칸을 나타낸다.</p><p>반면 아래는 올바르지 않은 모눈종이의 예시이다. 첫 번째는 윗쪽에 불필요한 행이 있고, 두 번째는 왼쪽에 불필요한 열이 있다. 그리고 세 번째는 스티커의 각 칸이 상하좌우로 모두 연결되어 있지 않다.</p><p>혜윤이는 자신의 노트북에 이 스티커들을 붙이기로 했다. 혜윤이의 노트북은 마침 직사각형 모양이고, 스티커가 인쇄된 모눈종이와 같은 간격으로 격자가 그려져 있다. 혜윤이는 스티커들을 먼저 받았던 것부터 차례대로 격자에 맞춰서 붙이려고 한다.</p><p>혜윤이가 스티커를 붙이는 방법은 다음과 같다.</p><ol><li>스티커를 회전시키지 않고 모눈종이에서 떼어낸다.</li><li>다른 스티커와 겹치거나 노트북을 벗어나지 않으면서 스티커를 붙일 수 있는 위치를 찾는다. 혜윤이는 노트북의 위쪽부터 스티커를 채워 나가려고 해서, 스티커를 붙일 수 있는 위치가 여러 곳 있다면 가장 위쪽의 위치를 선택한다. 가장 위쪽에 해당하는 위치도 여러 곳이 있다면 그중에서 가장 왼쪽의 위치를 선택한다.</li><li>선택한 위치에 스티커를 붙인다. 만약 스티커를 붙일 수 있는 위치가 전혀 없어서 스티커를 붙이지 못했다면, 스티커를 시계 방향으로 90도 회전한 뒤 2번 과정을 반복한다.</li><li>위의 과정을 네 번 반복해서 스티커를 0도, 90도, 180도, 270도 회전시켜 봤음에도 스티커를 붙이지 못했다면 해당 스티커를 붙이지 않고 버린다.</li></ol><p>아래의 예시를 통해 스티커를 붙이는 과정을 이해해보자. 노트북은 세로 5칸, 가로 4칸 크기이고, 혜윤이가 가지고 있는 스티커들은 아래와 같다. 왼쪽에서 오른쪽 순으로 스티커를 붙일 것이다.</p><p>첫 번째 스티커는 회전 없이 온전히 붙일 수 있는 공간이 아래와 같이 6곳이 있다.</p><p>이 중에서 가장 위쪽의 위치, 가능한 가장 위쪽의 위치가 여러 개이면 그 중에서 가장 왼쪽의 위치는 첫 번째이다. 스티커를 붙인 후 노트북의 모양은 아래와 같다.</p><p>두 번째 스티커는 회전 없이 온전히 붙일 수 있는 공간이 없다. 그러나 시계 방향으로 90도 회전한 후에는 붙일 수 있는 공간이 1개 생긴다. 해당 공간에 스티커를 붙인 후 노트북의 모양은 아래와 같다.</p><p>세 번째 스티커는 스티커를 시계방향으로 0, 90, 180, 270도 회전시킨 모양에 대해 전부 확인을 해도 스티커를 붙일 수 있는 공간이 없다. 그러므로 해당 스티커를 붙이지 않고 버린다.</p><p>네 번째 스티커는 스티커를 시계방향으로 0, 90, 180도 회전 시킨 모양에 대해 온전히 붙일 수 있는 공간이 없다. 그러나 시계 방향으로 270도 회전한 후에는 공간이 1개 생긴다. 스티커를 붙인 후 노트북의 모양은 아래와 같다. 최종적으로 노트북의 18칸이 스티커로 채워졌다.</p><p>혜윤이는 스티커를 다 붙인 후의 노트북의 모습이 궁금해졌다. 노트북의 크기와 스티커들이 주어졌을 때 스티커들을 차례대로 붙이고 난 후 노트북에서 몇 개의 칸이 채워졌는지 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 노트북의 세로와 가로 길이를 나타내는 N(1 ≤ N ≤ 40)과 M(1 ≤ M ≤ 40), 그리고 스티커의 개수 K(1 ≤ K ≤ 100)이 한 칸의 빈칸을 사이에 두고 주어진다.</p><p>그 다음 줄부터는 K개의 스티커들에 대한 정보가 주어진다. 각 스티커는 아래와 같은 형식으로 주어진다.</p><p>먼저 i번째 스티커가 인쇄된 모눈종이의 행의 개수와 열의 개수를 나타내는 Ri(1 ≤ Ri ≤ 10)와 Ci(1 ≤ Ci ≤ 10)가 한 칸의 빈칸을 사이에 두고 주어진다.</p><p>다음 Ri개의 줄에는 각 줄마다 모눈종이의 각 행을 나타내는 Ci개의 정수가 한 개의 빈칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0, 1이다. 0은 스티커가 붙지 않은 칸을, 1은 스티커가 붙은 칸을 의미한다.</p><p>문제에서 설명한 것과 같이 스티커는 모두 올바른 모눈종이에 인쇄되어 있다. 구체적으로 스티커의 각 칸은 상하좌우로 모두 연결되어 있고, 모눈종이의 크기는 스티커의 크기에 꼭 맞아서 상하좌우에 스티커에 전혀 포함되지 않는 불필요한 행이나 열이 존재하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 주어진 스티커들을 차례대로 붙였을 때 노트북에서 스티커가 붙은 칸의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/18808" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/18808</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ol><li>스티커를 회전시키지 않고 모눈종이에서 떼어낸다.</li><li>다른 스티커와 겹치거나 노트북을 벗어나지 않으면서 스티커를 붙일 수 있는 위치를 찾는다. 혜윤이는 노트북의 위쪽부터 스티커를 채워 나가려고 해서, 스티커를 붙일 수 있는 위치가 여러 곳 있다면 가장 위쪽의 위치를 선택한다. 가장 위쪽에 해당하는 위치도 여러 곳이 있다면 그중에서 가장 왼쪽의 위치를 선택한다.</li><li>선택한 위치에 스티커를 붙인다. 만약 스티커를 붙일 수 있는 위치가 전혀 없어서 스티커를 붙이지 못했다면, 스티커를 시계 방향으로 90도 회전한 뒤 2번 과정을 반복한다.</li><li>위의 과정을 네 번 반복해서 스티커를 0도, 90도, 180도, 270도 회전시켜 봤음에도 스티커를 붙이지 못했다면 해당 스티커를 붙이지 않고 버린다.</li></ol><hr><ul><li><p>위의 1~4번 과정을 그대로 구현하면 된다.</p></li><li><p>먼저, 스티커를 노트북에 붙이는 함수(attach)와 스티커를 90도 회전시키는 함수(rotate)를 만들었다.</p><ul><li>attach함수는 현재 위치부터 스티커의 범위까지 a[x][y]가 0(스티커가 없는 경우)인 경우에만 스티커를 붙였다.</li><li>rotate함수는 임시 배열에 현재 스티커 배열을 복사하고 스티커 배열을 0으로 초기화 한다.</li><li>90도를 회전하는 것이므로 행과 열이 뒤바뀌게 된다. 회전하기 전 행, 열의 크기를 row-1, col-1이라 한다면<ul><li>(0, 0) -&gt; (0, row - 1)로, (0, 1) -&gt; (1, row - 1), (0, 2) -&gt; (2, row - 1) …</li><li>(1, 0) -&gt; (0, row - 1 -1), (2, 0) -&gt; (0, row - 1 - 2) …</li></ul></li><li>와 같이 이동한다. 즉, 열은 숫자 그대로 행으로 이동하고, 행은 row - 1부터 줄어들며 열로 이동한다.</li></ul></li><li><p>재귀함수를 이용하여 현재 스티커의 모양으로 왼쪽 위부터 스티커를 노트북에 붙일 수 있는지 확인한다.</p><ul><li>노트북의 범위를 돌며 현재 위치부터 스티커의 범위를 확인하여 스티커가 붙은 곳에 스티커를 붙이는 경우 불가능하다고 판별하도록 하였다.</li><li>불가능한 경우 break로 빠져나왔고, 현재 위치부터 스티커의 범위 모두 가능한 경우라면 attach함수로 현재 위치에 스티커를 붙이고 true 를 리턴했다.</li></ul></li><li><p>현재 모양으로 붙일 수 없는 경우 rotate함수로 90도 회전시킨 후, row와 col을 뒤집어 재귀를 수행한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> sticker[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> <span class="comment">// 스티커를 노트북에 붙이는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &lt; i + row; x++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = j; y &lt; j + col; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x][y] == <span class="number">0</span>)</span><br><span class="line">a[x][y] = sticker[x - i][y - j]; <span class="comment">// 노트북의 현재 위치에 붙임</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> <span class="comment">// 90도 회전시키는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">tmp[i][j] = sticker[i][j]; <span class="comment">// 임시 배열에 복사</span></span><br><span class="line"><span class="built_in">memset</span>(sticker, <span class="number">0</span>, <span class="keyword">sizeof</span>(sticker)); <span class="comment">// 스티커 초기화</span></span><br><span class="line"><span class="comment">// 행과 열을 뒤집는다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)</span><br><span class="line">&#123;</span><br><span class="line">sticker[i][j] = tmp[row - <span class="number">1</span> - j][i]; <span class="comment">// 90도 회전</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">attempt</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 모든 방향 확인 후 붙일 수 없다면 false리턴</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> possible = <span class="literal">false</span>; <span class="comment">// 붙일 수 있는지 확인</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= row &amp;&amp; m &gt;= col) <span class="comment">// 노트북 범위에 맞을때만 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">possible = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i + row &lt;= n &amp;&amp; j + col &lt;= m) <span class="comment">// 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; row; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; col; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sticker[x][y] == <span class="number">1</span> &amp;&amp; a[i + x][j + y] == <span class="number">1</span>) <span class="comment">// 스티커가 붙은 곳에 스티커를 붙이는 경우 불가능</span></span><br><span class="line">&#123; <span class="comment">// 붙일 수 없는 경우</span></span><br><span class="line">possible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!possible) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> possible = <span class="literal">false</span>; <span class="comment">// 범위를 벗어나면 불가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (possible) <span class="comment">// 붙일 수 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">attach</span>(i, j, row, col); <span class="comment">// 노트북에 붙이고 true리턴</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!possible) <span class="comment">// 현재 모양으로 붙일 수 없는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">rotate(row, col); <span class="comment">// 90도 회전</span></span><br><span class="line"><span class="keyword">if</span> (attempt(col, row, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 회전하면 row, col이 바뀌므로 바꿔서 재귀</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sticker[i][j];</span><br><span class="line"></span><br><span class="line">attempt(row, col, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">1</span>) ans++; <span class="comment">// 스티커 붙은 칸 카운트</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-18808&quot;&gt;&lt;a href=&quot;#Problem-18808&quot; class=&quot;headerlink&quot; title=&quot;Problem 18808&quot;&gt;&lt;/a&gt;Problem 18808&lt;/h1&gt;&lt;h2 id=&quot;스티커-붙이기&quot;&gt;&lt;a href=&quot;#스티
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14890번 경사로</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/26/algorithm14890/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/26/algorithm14890/</id>
    <published>2020-03-25T17:40:01.000Z</published>
    <updated>2020-03-25T17:42:02.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14890"><a href="#Problem-14890" class="headerlink" title="Problem 14890"></a>Problem 14890</h1><h2 id="경사로"><a href="#경사로" class="headerlink" title="경사로"></a>경사로</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.</p><p>오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.</p><p>다음과 같은 N=6인 경우 지도를 살펴보자.</p><p>이때, 길은 총 2N개가 있으며, 아래와 같다.</p><p>길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.</p><p>경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.<br>낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.<br>경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.<br>아래와 같은 경우에는 경사로를 놓을 수 없다.</p><p>경사로를 놓은 곳에 또 경사로를 놓는 경우<br>낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우<br>낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우<br>경사로를 놓다가 범위를 벗어나는 경우<br>L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.</p><p>경사로를 놓을 수 없는 경우는 아래와 같다.</p><p>위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.</p><p>가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.</p><p>지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14890" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14890</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6 2<br>3 3 3 3 3 3<br>2 3 3 3 3 3<br>2 2 2 3 2 3<br>1 1 1 2 2 2<br>1 1 1 3 3 1<br>1 1 2 3 3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 2<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>7</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 3<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>3</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6 1<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>check_row, check_col 배열에 행, 열 별로 지나갈 수 있는 길인지 여부를 저장한다.<ul><li>초기값을 true로 지정하여 불가능한 경우가 나오면 false로 변경하고 다음 길을 확인하는 방식으로 구현하였다.</li></ul></li><li>높이의 차가 2 이상인 경우는 불가능한 경우이므로 제외시킨다.</li><li>다음 좌표와의 높이 차를 구해 같은 높이인 경우, 높이가 낮아지는 경우, 높아지는 경우를 각각 처리했다.</li><li>cnt에 같은 높이로 이어지는 블록의 수를 기록하여 경사로의 길이와 비교 후 경사로를 놓을 수 있는지 판별하였다.<ul><li>이 때, 내려가는 경사로인 경우에는 높이가 낮아진 이후 같은 높이의 블록 수를 계산해야 하므로 check_d라는 변수에 내려가는 경사로를 거친 상태라면 true로 두어 판별하였다.</li></ul></li><li>경사로의 길이가 1로 입력된 경우 예외가 많아서 처리하기 힘들었다.</li><li>1인 경우의 예외는 코드에 주석으로 설명을 해두었다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> check_row[MAX];</span><br><span class="line"><span class="keyword">bool</span> check_col[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 평지의 수</span></span><br><span class="line">check_row[i] = <span class="literal">true</span>; <span class="comment">// 초기값 true (지나갈 수 있는 상태)</span></span><br><span class="line"><span class="keyword">bool</span> check_d = <span class="literal">false</span>; <span class="comment">// 내려가는 경사로를 거친 상태라면 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[i][j + <span class="number">1</span>] - a[i][j];</span><br><span class="line"><span class="keyword">if</span> (gap &gt; <span class="number">1</span> || gap &lt; <span class="number">-1</span>) <span class="comment">// 높이차가 2 이상이면 불가능한 경우</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gap == <span class="number">0</span>) <span class="comment">// 같은 높이인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++; <span class="comment">// 같은 높이의 개수</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt;= l) <span class="comment">// 내려가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line">&#123;  <span class="comment">// 경사로의 길이가 1인 경우는 예외</span></span><br><span class="line">check_d = <span class="literal">false</span>; <span class="comment">// 평지로 인식</span></span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">1</span>) <span class="comment">// 높이가 높아진 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 경사로가 내려가다가 바로 올라가는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt == <span class="number">1</span>)</span><br><span class="line">&#123;  <span class="comment">// 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능</span></span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">// l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt; <span class="number">1</span>) check_d = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; l) <span class="comment">// 올라가는 경사로를 놓을 수 없는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">1</span>; <span class="comment">// 높이가 바뀌었으므로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">-1</span>) <span class="comment">// 높이가 낮아졌다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 연속으로 내려가는 경사로를 두 번 놓을 수 없음</span></span><br><span class="line">&#123; <span class="comment">// 1은 예외</span></span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">check_d = <span class="literal">true</span>; <span class="comment">// 다음 높이에서 경사로의 길이를 체크</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; j == n - <span class="number">2</span> &amp;&amp; check_d) check_row[i] = <span class="literal">false</span>; <span class="comment">// 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 평지의 수</span></span><br><span class="line">check_col[j] = <span class="literal">true</span>; <span class="comment">// 초기값 true (지나갈 수 있는 상태)</span></span><br><span class="line"><span class="keyword">bool</span> check_d = <span class="literal">false</span>; <span class="comment">// 내려가는 경사로를 거친 상태라면 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[i + <span class="number">1</span>][j] - a[i][j];</span><br><span class="line"><span class="keyword">if</span> (gap &gt; <span class="number">1</span> || gap &lt; <span class="number">-1</span>) <span class="comment">// 높이차가 2 이상이면 불가능한 경우</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gap == <span class="number">0</span>) <span class="comment">// 같은 높이인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++; <span class="comment">// 같은 높이의 개수</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt;= l)  <span class="comment">// 내려가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line">&#123; <span class="comment">// 경사로의 길이가 1인 경우는 예외</span></span><br><span class="line">check_d = <span class="literal">false</span>; <span class="comment">// 다시 평지로 인식</span></span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">1</span>) <span class="comment">// 높이가 높아진 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d)  <span class="comment">// 경사로가 내려가다가 바로 올라가는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능</span></span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">//l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt; <span class="number">1</span>) check_d = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; l) <span class="comment">// 올라가는 경사로를 놓을 수 없는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">1</span>; <span class="comment">// 높이가 바뀌었으므로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">-1</span>) <span class="comment">// 높이가 낮아졌다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 연속으로 내려가는 경사로를 두 번 놓을 수 없음</span></span><br><span class="line">&#123; <span class="comment">// 1은 예외</span></span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">check_d = <span class="literal">true</span>; <span class="comment">// 다음 높이에서 경사로의 길이를 체크</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; i == n - <span class="number">2</span> &amp;&amp; check_d) check_col[j] = <span class="literal">false</span>; <span class="comment">// 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 각 행, 열 별로 지나갈 수 있는 길의 수 체크</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check_row[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "row : " &lt;&lt; i &lt;&lt; '\n'; // 디버깅용</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check_col[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "col : " &lt;&lt; i &lt;&lt; '\n'; // 디버깅용</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14890&quot;&gt;&lt;a href=&quot;#Problem-14890&quot; class=&quot;headerlink&quot; title=&quot;Problem 14890&quot;&gt;&lt;/a&gt;Problem 14890&lt;/h1&gt;&lt;h2 id=&quot;경사로&quot;&gt;&lt;a href=&quot;#경사로&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 15683번 감시</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/25/algorithm15683/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/25/algorithm15683/</id>
    <published>2020-03-24T17:10:12.000Z</published>
    <updated>2020-03-24T17:18:00.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-15683"><a href="#Problem-15683" class="headerlink" title="Problem 15683"></a>Problem 15683</h1><h2 id="감시"><a href="#감시" class="headerlink" title="감시"></a>감시</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.</p><p>1번    2번    3번    4번    5번<br>1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.</p><p>CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.</p><p>CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 ‘#’로 나타내면 아래와 같다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> # <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"># # <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>→    ←    ↑    ↓<br>CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 벽을 감시할 수 없다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 # # # #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="comment"># # 2 #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># # # # # 5</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 # # # #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment"># #</span></span><br><span class="line"><span class="comment"># # # # # 5</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> # # <span class="number">2</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"># # # # # <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> # #</span><br><span class="line"># # # # # <span class="number">5</span></span><br></pre></td></tr></table></figure><p>왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔    왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕    왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔    왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕<br>CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">6</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 2 # 3</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="comment"># 0 #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.</p><p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)</p><p>둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.</p><p>CCTV의 최대 개수는 8개를 넘지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 사각 지대의 최소 크기를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/15683" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/15683</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 6<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 1 0 6 0<br>0 0 0 0 0 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>20</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 6<br>0 0 0 0 0 0<br>0 2 0 0 0 0<br>0 0 0 0 6 0<br>0 6 0 0 2 0<br>0 0 0 0 0 0<br>0 0 0 0 0 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>15</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 6<br>1 0 0 0 0 0<br>0 1 0 0 0 0<br>0 0 1 0 0 0<br>0 0 0 1 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>6</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6 6<br>1 0 0 0 0 0<br>0 1 0 0 0 0<br>0 0 1 5 0 0<br>0 0 5 1 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>2</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>1 7<br>0 1 2 3 4 5 6</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>0</p><h3 id="예제-입력-6"><a href="#예제-입력-6" class="headerlink" title="예제 입력 6"></a>예제 입력 6</h3><p>3 7<br>4 0 0 0 0 0 0<br>0 0 0 2 0 0 0<br>0 0 0 0 0 0 4</p><h3 id="예제-출력-6"><a href="#예제-출력-6" class="headerlink" title="예제 출력 6"></a>예제 출력 6</h3><p>0</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>부르트 포스 문제로 모든 경우를 다 확인해 최솟값을 구하면 된다.</li><li>나는 see라는 함수를 만들어서 현재 좌표에서 현재 방향으로 감시가능한 구역 체크하도록 했다.<ul><li>인자로 좌표, 방향, flag, num 을 받는다.</li><li>flag는 1인 경우 감시 구역을 체크하고 아니라면 체크된 감시 구역을 해제한다.</li><li>여기서 감시구역을 num으로 체크하는데, num은 7부터 감시카메라의 개수만큼 증가한다.</li><li>이렇게 num을 준 이유는 1~6번은 사용중이고, 다른 감시카메라와의 중복 감시구역을 파악하기 위해서다.</li><li>flag가 1이 아니라면, 현재 방향의 num으로 체크된 구역만 0으로 바꾸어 체크를 해제한다.</li></ul></li><li>이후 재귀함수로 입력받은 감시카메라의 개수만큼, 각 감시카메라의 종류가 볼 수 있는 방향을 모두 체크한다.</li><li>모든 감시카메라 확인 후 0인 구역의 개수가 사각지대의 개수이다. 이것의 최솟값을 구한다.</li></ul><hr><ul><li>3번 감시카메라를 착각해서 감시 방향을 3번만 확인하면 된다고 생각하여 이것을 찾아내는데 시간을 많이 썻다.</li><li>3번 감시카메라도 네 방향을 모두 보아야 한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dir, <span class="keyword">int</span> flag, <span class="keyword">int</span> num)</span> <span class="comment">// 현재 좌표에서 현재 방향으로 감시가능한 구역 체크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="comment">// 감시 구역 체크</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">max</span>(n, m); i++) <span class="comment">// 현재 방향으로 벽이 아닌 모든 구역 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir] * i;</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir] * i;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) a[nx][ny] = num; <span class="comment">// 0인 경우 인자로 받은 num으로 넣어서 구분</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 감시 구역 해제</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">max</span>(n, m); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir] * i;</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir] * i;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(a[nx][ny] == num) a[nx][ny] = <span class="number">0</span>; <span class="comment">// num 체크 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// 확인용 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">size</span>) <span class="comment">// 모든 감시카메라 확인 후</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">0</span>)</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; ans) ans = cnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = v[index].first.first;</span><br><span class="line"><span class="keyword">int</span> y = v[index].first.second;</span><br><span class="line"><span class="keyword">int</span> type = v[index].second;</span><br><span class="line"><span class="keyword">int</span> num = index + <span class="number">7</span>; <span class="comment">// 1~6은 사용중</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) <span class="comment">// 1번 경우 네 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 감시구역 체크</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num); <span class="comment">// 체크 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">// 2번 경우 양 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 현재 방향 체크</span></span><br><span class="line">see(x, y, k + <span class="number">2</span>, <span class="number">1</span>, num); <span class="comment">// 한칸 건너 뛰고 반대방향 체크</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">see(x, y, k + <span class="number">2</span>, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) <span class="comment">// 3번 경우 직각 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 현재 방향 체크</span></span><br><span class="line">see(x, y, k + <span class="number">1</span> &gt; <span class="number">3</span> ? <span class="number">0</span> : k + <span class="number">1</span>, <span class="number">1</span>, num); <span class="comment">// 현재 방향과 직각을 이루는 방향 확인</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">see(x, y, k + <span class="number">1</span> &gt; <span class="number">3</span> ? <span class="number">0</span> : k + <span class="number">1</span>, <span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) <span class="comment">// 4번 경우 세 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l == k) <span class="keyword">continue</span>; <span class="comment">// 현재 방향 빼고 나머지 세 방향 확인</span></span><br><span class="line">see(x, y, l, <span class="number">1</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l == k) <span class="keyword">continue</span>;</span><br><span class="line">see(x, y, l, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">5</span>) <span class="comment">// 5번 경우 전 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num);</span><br><span class="line"></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] &gt;= <span class="number">1</span> &amp;&amp; a[i][j] &lt;= <span class="number">5</span>)</span><br><span class="line">&#123; <span class="comment">// 감시카메라의 위치 , 종류 저장</span></span><br><span class="line">v.push_back(make_pair(make_pair(i, j), a[i][j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-15683&quot;&gt;&lt;a href=&quot;#Problem-15683&quot; class=&quot;headerlink&quot; title=&quot;Problem 15683&quot;&gt;&lt;/a&gt;Problem 15683&lt;/h1&gt;&lt;h2 id=&quot;감시&quot;&gt;&lt;a href=&quot;#감시&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14500번 테트로미노</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/24/algorithm14500/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/24/algorithm14500/</id>
    <published>2020-03-23T15:12:12.000Z</published>
    <updated>2020-03-25T05:34:58.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14500"><a href="#Problem-14500" class="headerlink" title="Problem 14500"></a>Problem 14500</h1><h2 id="테트로미노"><a href="#테트로미노" class="headerlink" title="테트로미노"></a>테트로미노</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.</p><p>정사각형은 서로 겹치면 안 된다.<br>도형은 모두 연결되어 있어야 한다.<br>정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.<br>정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.</p><p>아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.</p><p>테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.</p><p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)</p><p>둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14500" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14500</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 5<br>1 2 3 4 5<br>5 4 3 2 1<br>2 3 4 5 6<br>6 5 4 3 2<br>1 2 1 2 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>19</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4 5<br>1 2 3 4 5<br>1 2 3 4 5<br>1 2 3 4 5<br>1 2 3 4 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>20</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 10<br>1 2 1 2 1 2 1 2 1 2<br>2 1 2 1 2 1 2 1 2 1<br>1 2 1 2 1 2 1 2 1 2<br>2 1 2 1 2 1 2 1 2 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>7</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>5가지의 경우 중 ㅜ 모양을 제외한 4가지 경우는 한 점에서 시작하여 3개의 칸을 연속해서 방문하는 형태이므로 dfs를 통해 구할 수 있다.<ul><li>dfs를 사용하여 네 칸을 연속해서 방문하는 경우 네 칸의 최댓값을 구한다.</li></ul></li><li>나머지 ㅜ 모양은 3개의 칸을 연속해서 방문하지 않으므로 경우 dfs로는 구할 수 없다.<ul><li>따라서 반복문에 직접 구현하였다.</li><li>ㅗ, ㅜ 모양인 경우 j + 2 &lt; m 일 때를 기준으로 처리하였고,</li><li>ㅓ, ㅏ 모양인 경우 i + 2 &lt; n 일 때를 기준으로 처리하였다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> <span class="comment">// 한 점에서 시작하여 3개의 칸을 연속해서 확인하는 경우 모두 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; ans) ans = sum; <span class="comment">// 네 칸의 합의 최댓값</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, sum + a[x][y], index + <span class="number">1</span>);</span><br><span class="line">check[nx][ny] = <span class="literal">false</span>; <span class="comment">// 방문 처리 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">check[x][y] = <span class="literal">false</span>; <span class="comment">// 시작점 방문 처리 해제</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// dfs로 구할 수 없는 한 가지 경우 처리</span></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">2</span> &lt; m) <span class="comment">//  ㅗ, ㅜ 모양 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = a[i][j] + a[i][j + <span class="number">1</span>] + a[i][j + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">2</span> &lt; n) <span class="comment">// ㅓ, ㅏ 모양 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = a[i][j] + a[i + <span class="number">1</span>][j] + a[i + <span class="number">2</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14500&quot;&gt;&lt;a href=&quot;#Problem-14500&quot; class=&quot;headerlink&quot; title=&quot;Problem 14500&quot;&gt;&lt;/a&gt;Problem 14500&lt;/h1&gt;&lt;h2 id=&quot;테트로미노&quot;&gt;&lt;a href=&quot;#테트로미
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16234번 인구 이동</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/23/algorithm16234/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/23/algorithm16234/</id>
    <published>2020-03-22T17:31:12.000Z</published>
    <updated>2020-03-22T17:38:39.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16234"><a href="#Problem-16234" class="headerlink" title="Problem 16234"></a>Problem 16234</h1><h2 id="인구-이동"><a href="#인구-이동" class="headerlink" title="인구 이동"></a>인구 이동</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.</p><p>오늘부터 인구 이동이 시작되는 날이다.</p><p>인구 이동은 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.</p><ul><li>국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루동안 연다.</li><li>위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.</li><li>국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.</li><li>연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.</li><li>연합을 해체하고, 모든 국경선을 닫는다.<br>각 나라의 인구수가 주어졌을 때, 인구 이동이 몇 번 발생하는지 구하는 프로그램을 작성하시오.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)</p><p>둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)</p><p>인구 이동이 발생하는 횟수가 2,000번 보다 작거나 같은 입력만 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>인구 이동이 몇 번 발생하는지 첫째 줄에 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16234" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16234</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2 20 50<br>50 30<br>20 40</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>2 40 50<br>50 30<br>20 40</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>0</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>2 20 50<br>50 30<br>30 40</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>1</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>3 5 10<br>10 15 20<br>20 30 25<br>40 22 10</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>2</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>4 10 50<br>10 100 20 90<br>80 100 60 70<br>70 20 30 40<br>50 20 100 10</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>dfs를 통해 현재 국경을 공유하는 나라를 하나의 그룹으로 연합의 그룹번호를 매긴다.</li><li>이후 각 그룹에 속하는 나라의 수를 cnt에 카운트하고, 각 그룹의 속하는 나라의 인구수의 합을 sum에 저장한다.</li><li>또한 벡터v에 같은 그룹에 해당하는 나라끼리 좌표를 저장한다.</li><li>cnt[k]가 2이상이라면 k그룹에 속한 나라끼리 국경을 공유했다는 뜻이 된다.<ul><li>따라서, cnt[k]가 2이상인 경우 v[k]에 저장된 각 나라의 좌표에 접근하여 (sum[k] / cnt[k])를 통해 인구 이동을 계산한다.</li><li>이때, 계산 후에 벡터를 초기화한다.</li></ul></li><li>반복문이 1회 반복될 때마다 인구 이동 횟수를 카운트한다.</li><li>국경을 공유하는 나라가 더 이상 없다면 반복문을 빠져나가고 종료한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> group[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[MAX + <span class="number">1</span>]; <span class="comment">// 각 그룹에 속하는 나라의 수</span></span><br><span class="line"><span class="keyword">int</span> sum[MAX + <span class="number">1</span>]; <span class="comment">// 각 그룹의 속하는 나라의 인구수의 합</span></span><br><span class="line"><span class="keyword">int</span> n, l, r;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> <span class="comment">// dfs를 통해 연합의 그룹번호를 매긴다.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (group[x][y] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">group[x][y] = num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[x][y] - a[nx][ny];</span><br><span class="line"><span class="keyword">if</span> (gap &lt; <span class="number">0</span>) gap = -gap;</span><br><span class="line"><span class="keyword">if</span> (gap &gt;= l &amp;&amp; gap &lt;= r) <span class="comment">//  나라의 인구 차이가 L명 이상, R명 이하라면</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, num); <span class="comment">// 같은 그룹으로 묶는다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(group, <span class="number">0</span>, <span class="keyword">sizeof</span>(group)); <span class="comment">// 그룹 번호 초기화</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (group[i][j] == <span class="number">0</span>) <span class="comment">// 그룹에 속하지 않는 나라인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(i, j, ++num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); <span class="comment">// 각 그룹에 속하는 나라의 수 초기화</span></span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum)); <span class="comment">// 각 그룹의 속하는 나라의 인구수의 합 초기화</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cnt[group[i][j]]++;</span><br><span class="line">sum[group[i][j]] += a[i][j];</span><br><span class="line">v[group[i][j]].push_back(make_pair(i, j)); <span class="comment">// 같은 그룹에 해당하는 나라의 좌표를 저장</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> check = <span class="literal">true</span>; <span class="comment">// 국경선을 공유하는 나라가 있는지 판별</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX; k++) <span class="comment">// 경우는 1부터 10000까지</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[k] &gt;= <span class="number">2</span>) <span class="comment">// 그룹에 속한 나라의 수가 2이상이면 국경을 공유한 것.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[k].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = v[k][i].first;</span><br><span class="line"><span class="keyword">int</span> y = v[k][i].second;</span><br><span class="line"></span><br><span class="line">a[x][y] = sum[k] / cnt[k]; <span class="comment">// 인구 이동 계산</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">check = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">v[k].<span class="built_in">clear</span>(); <span class="comment">// 벡터 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (check) <span class="keyword">break</span>; <span class="comment">// 국경을 공유하는 나라가 없다면 종료</span></span><br><span class="line">ans++; <span class="comment">// 인구 이동 횟수 카운트</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16234&quot;&gt;&lt;a href=&quot;#Problem-16234&quot; class=&quot;headerlink&quot; title=&quot;Problem 16234&quot;&gt;&lt;/a&gt;Problem 16234&lt;/h1&gt;&lt;h2 id=&quot;인구-이동&quot;&gt;&lt;a href=&quot;#인구-이
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14503번 로봇 청소기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/21/algorithm14503/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/21/algorithm14503/</id>
    <published>2020-03-20T17:05:12.000Z</published>
    <updated>2020-03-20T17:08:33.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14503"><a href="#Problem-14503" class="headerlink" title="Problem 14503"></a>Problem 14503</h1><h2 id="로봇-청소기"><a href="#로봇-청소기" class="headerlink" title="로봇 청소기"></a>로봇 청소기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.</p><p>로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.</p><p>로봇 청소기는 다음과 같이 작동한다.</p><ol><li>현재 위치를 청소한다.</li><li>현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.<ol><li>왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.</li><li>왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.</li><li>네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.</li><li>네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.</li></ol></li></ol><p>로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)</p><p>둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.</p><p>셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.</p><p>로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>로봇 청소기가 청소하는 칸의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14503" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14503</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 1 0<br>1 1 1<br>1 0 1<br>1 1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>11 10<br>7 4 0<br>1 1 1 1 1 1 1 1 1 1<br>1 0 0 0 0 0 0 0 0 1<br>1 0 0 0 1 1 1 1 0 1<br>1 0 0 1 1 0 0 0 0 1<br>1 0 1 1 0 0 0 0 0 1<br>1 0 0 0 0 0 0 0 0 1<br>1 0 0 0 0 0 0 1 0 1<br>1 0 0 0 0 0 1 1 0 1<br>1 0 0 0 0 0 1 1 0 1<br>1 0 0 0 0 0 0 0 0 1<br>1 1 1 1 1 1 1 1 1 1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>57</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀 함수를 통해 문제의 조건을 그대로 구현해야 한다.</li><li>청소를 완료한 구역은 2를 저장하여 구분하였고, 0, 1, 2, 3이 북, 서, 남, 동이므로 dx, dy에 순서를 맞춰주었다.</li><li>먼저 청소하지 않은 구역이면 청소를 하고 방의 개수를 카운트한다.</li><li>calc_dir이라는 0, 1, 2, 3 다음 다시 0이 되도록 계산을 해주는 함수를 구현하여<ul><li>왼쪽부터 4방향을 확인하는데, 왼쪽으로 회전하는 것은 현재 방향에서 -1을 해주면 된다.</li><li>바라보는 방향의 방이 청소가 안된 빈칸이라면 재귀를 수행하여 다음 칸으로 이동하고, 이후 나머지 방향은 추가로 검사하지 않는다.</li></ul></li><li>위의 과정이 끝나 네 방향 모두 청소가 되었거나 벽이라면<ul><li>현재 방향에서 -2를 해주어 후진 방향을 설정하고 후진할 방향이 벽이라면 정답을 출력 후 종료,</li><li>벽이 아니라면 후진을 한다. 이 때, 원래의 방향을 유지하며 후진을 수행한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;; <span class="comment">// 0  : 북, 1 : 서, 2 : 남, 3 : 동</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_dir</span><span class="params">(<span class="keyword">int</span> dir, <span class="keyword">int</span> rotation)</span> <span class="comment">// 청소기의 회전</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = dir + rotation;</span><br><span class="line"><span class="keyword">if</span> (res &gt; <span class="number">3</span>) res -= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(res &lt; <span class="number">0</span>) res += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>) <span class="comment">// 청소하지 않았다면</span></span><br><span class="line">&#123;</span><br><span class="line">a[x][y] = <span class="number">2</span>; <span class="comment">// 청소</span></span><br><span class="line">ans++; <span class="comment">// 카운트</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span> (cnt--) <span class="comment">// 4방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line">dir = calc_dir(dir, <span class="number">-1</span>); <span class="comment">// 왼쪽으로 회전</span></span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) <span class="comment">// 빈칸이라면 청소</span></span><br><span class="line">&#123;</span><br><span class="line">go(nx, ny, dir);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 다음 칸으로 넘어간 이후 나머지 방향은 검사 x</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 검사 끝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네 방향 모두 청소가 이미 되어있거나 벽인 경우</span></span><br><span class="line"><span class="keyword">int</span> rear = calc_dir(dir, <span class="number">-2</span>); <span class="comment">// 후진 방향 설정</span></span><br><span class="line"><span class="keyword">int</span> nx = x + dx[rear];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[rear];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span>) <span class="comment">// 후진도 못한다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 출력 후 종료</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 후진한다</span></span><br><span class="line">&#123;</span><br><span class="line">go(nx, ny, dir); <span class="comment">// 방향은 유지</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sx, sy, dir;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; dir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">go(sx, sy, dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14503&quot;&gt;&lt;a href=&quot;#Problem-14503&quot; class=&quot;headerlink&quot; title=&quot;Problem 14503&quot;&gt;&lt;/a&gt;Problem 14503&lt;/h1&gt;&lt;h2 id=&quot;로봇-청소기&quot;&gt;&lt;a href=&quot;#로봇-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2580번 스도쿠</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/19/algorithm2580/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/19/algorithm2580/</id>
    <published>2020-03-19T01:30:12.000Z</published>
    <updated>2020-03-19T01:39:02.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2580"><a href="#Problem-2580" class="headerlink" title="Problem 2580"></a>Problem 2580</h1><h2 id="스도쿠"><a href="#스도쿠" class="headerlink" title="스도쿠"></a>스도쿠</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 몇 몇 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.</p><p>0 3 5 4 6 9 2 7 8<br>7 8 2 1 0 5 6 0 9<br>0 6 0 2 7 8 1 3 5<br>3 2 1 0 4 6 8 9 7<br>8 0 4 9 1 3 5 0 6<br>5 9 6 8 2 0 4 1 3<br>9 1 7 6 5 2 0 8 0<br>6 0 3 7 0 1 9 5 2<br>2 5 8 3 9 4 7 6 0</p><p>나머지 빈 칸을 채우는 방식은 다음과 같다.</p><ol><li>각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li><li>굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li></ol><p>위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.</p><p><strong>1</strong> 3 5 4 6 9 2 7 8</p><p>또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.</p><p>4 6 9<br>1 <strong>3</strong> 5<br>2 7 8</p><p>이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.</p><p>1 3 5 4 6 9 2 7 8<br>7 8 2 1 3 5 6 4 9<br>4 6 9 2 7 8 1 3 5<br>3 2 1 5 4 6 8 9 7<br>8 7 4 9 1 3 5 2 6<br>5 9 6 8 2 7 4 1 3<br>9 1 7 6 5 2 3 8 4<br>6 4 3 7 8 1 9 5 2<br>2 5 8 3 9 4 7 6 1</p><p>게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.</p><p>스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2580" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2580</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>0 3 5 4 6 9 2 7 8<br>7 8 2 1 0 5 6 0 9<br>0 6 0 2 7 8 1 3 5<br>3 2 1 0 4 6 8 9 7<br>8 0 4 9 1 3 5 0 6<br>5 9 6 8 2 0 4 1 3<br>9 1 7 6 5 2 0 8 0<br>6 0 3 7 0 1 9 5 2<br>2 5 8 3 9 4 7 6 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1 3 5 4 6 9 2 7 8<br>7 8 2 1 3 5 6 4 9<br>4 6 9 2 7 8 1 3 5<br>3 2 1 5 4 6 8 9 7<br>8 7 4 9 1 3 5 2 6<br>5 9 6 8 2 7 4 1 3<br>9 1 7 6 5 2 3 8 4<br>6 4 3 7 8 1 9 5 2<br>2 5 8 3 9 4 7 6 1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>각각의 동일한 행, 열, 3 * 3 사각형에 중복되는 수가 들어가지 않도록 하여 백트래킹을 하면 된다.</li><li>입력을 받으며 각 행에 존재하는 수를 check배열에 행과 열을 구분하여 체크한다.<ul><li>이 때, 사각형에 존재하는 수를 체크하는 방법은 3x3 사각형을 순서대로 0 ~ 8번이라고 정의하고</li><li>현재 행, 열에 대해 (행 / 3) * 3 + (열 / 3)을 수행하면 현재 몇 번째 사각형인지 얻을 수 있다.</li></ul></li><li>이제 재귀 함수를 통해 백트래킹을 구현한다.</li><li>9행 9열을 0 ~ 80까지로 표현하여 현재 행은 (행 / 9), 현재 열은 (열 % 9)로 구할 수 있다.</li><li>현재 입력 배열의 수가 0인 경우(빈칸) 같은 행, 열, 사각형에 없는 수만 선택하여 수를 채우고 재귀를 수행한다.</li><li>index가 81이 되었다면 답을 구한 것이므로 출력 후 프로그램을 종료한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> check_row[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check_col[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check_square[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x / <span class="number">3</span>) * <span class="number">3</span> + (y / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">81</span>) <span class="comment">// 답을 구했으면 출력 후 프로그램 종료</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = index / <span class="number">9</span>; <span class="comment">// 0 ~ 80 을 행, 열로 변환</span></span><br><span class="line"><span class="keyword">int</span> y = index % <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check_row[x][i] &amp;&amp; !check_col[i][y] &amp;&amp; !check_square[square(x, y)][i]) <span class="comment">// 같은 행, 열, 사각형에 없는 수만 확인</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[x][i] = check_col[i][y] = check_square[square(x, y)][i] = <span class="literal">true</span>; <span class="comment">// 수를 넣었으므로 체크</span></span><br><span class="line">a[x][y] = i;</span><br><span class="line">go(index + <span class="number">1</span>); <span class="comment">// 수를 넣고 넘어감</span></span><br><span class="line">a[x][y] = <span class="number">0</span>; <span class="comment">// 확인 후 초기화</span></span><br><span class="line">check_row[x][i] = check_col[i][y] = check_square[square(x, y)][i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">go(index + <span class="number">1</span>); <span class="comment">// 0이 아니라면 계속 진행</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">check_row[i][a[i][j]] = <span class="literal">true</span>; <span class="comment">// i번째 행에 존재하는 수 체크</span></span><br><span class="line">check_col[a[i][j]][j] = <span class="literal">true</span>; <span class="comment">// j번째 열에 존재하는 수 체크</span></span><br><span class="line">check_square[square(i, j)][a[i][j]] = <span class="literal">true</span>; <span class="comment">// n번째 사각형에 존재하는 수 체크</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2580&quot;&gt;&lt;a href=&quot;#Problem-2580&quot; class=&quot;headerlink&quot; title=&quot;Problem 2580&quot;&gt;&lt;/a&gt;Problem 2580&lt;/h1&gt;&lt;h2 id=&quot;스도쿠&quot;&gt;&lt;a href=&quot;#스도쿠&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1201번 NMK</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/18/algorithm1201/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/18/algorithm1201/</id>
    <published>2020-03-18T05:01:12.000Z</published>
    <updated>2020-03-18T05:07:08.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1201"><a href="#Problem-1201" class="headerlink" title="Problem 1201"></a>Problem 1201</h1><h2 id="NMK"><a href="#NMK" class="headerlink" title="NMK"></a>NMK</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>1부터 N까지의 수를 한 번씩 이용해서 최대 부분 증가 수열의 길이가 M이고, 최대 부분 감소 수열의 길이가 K인 수열을 출력한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N M K가 주어진다. N은 500보다 작거나 같은 자연수, M과 K는 N보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 정답을 출력한다. 정답이 없다면-1을 출력한다</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1201" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1201</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2 1 4 3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>적어도 m개는 증가수열에 포함되어야 하고 적어도 k개는 감소수열에 포함되어야 한다. 두 수열은 최대 1개의 정수를 공유 가능</p><ul><li>[ex) m = 3, k = 2 -&gt; 1 2 4 3 과 같이 3개가 증가하고 이어서 4를 공유하여 2개가 감소하는 경우 최소 길이]</li><li>따라서 n &gt;= m + k -1 를 만족해야 한다.</li></ul></li><li><p>예를 들어, 1 2 3 4 5 6 7 8 9를 4개씩 묶는다고 생각해보자.</p><ul><li>(1 2 3 4)(5 6 7 8)(9) 와 같이 묶고, 각 구간을 뒤집는다.</li><li>(4 3 2 1)(8 7 6 5)(9) 가 될 것이다. 이 경우, 각 구간 내에서는 증가하는 부분이 없으므로 구간의 개수가 증가하는 최대 부분수열의 개수가 된다. 또한 구간의 최대 길이가 감소한는 부분 수열의 최대 길이가 될 것이다.</li></ul></li><li><p>감소하는 부분 수열의 길이를 k가 되도록 하기 위해 오름차순으로 정렬된 k개의 수에 대해 앞에서부터 한번은 최대 k개가 되도록 묶어 뒤집어 준다.</p></li><li><p>또한 m개의 증가 수열을 만들어 주기 위해 뒤집힌 묶음의 개수가 m개가 되어야 한다.</p></li><li><p>즉, m개의 구간을 묶을 때, 적어도 한 번은 k개가 되도록 수를 묶어 모든 구간을 뒤집어 주면 정답을 구할 수 있다.</p></li><li><p>이때, n이 m * k보다 커지게 된다면, m개의 구간을 k개씩 묶고 나서도 1개 이상의 수가 남기 때문에 이 경우 정답을 구할 수 없다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; m + k - <span class="number">1</span> || n &gt; m * k) <span class="comment">// 불가능한 범위 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">a[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 구간을 나눌 지점을 저장할 벡터</span></span><br><span class="line">s.push_back(<span class="number">0</span>); <span class="comment">// 첫 구간의 시작</span></span><br><span class="line">s.push_back(k); <span class="comment">// 첫 구간의 끝</span></span><br><span class="line">n -= k; <span class="comment">// 남은 수의 개수</span></span><br><span class="line">m--; <span class="comment">// 남은 구간 수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q = m == <span class="number">0</span> ? <span class="number">1</span> : n / m; <span class="comment">// 남은 구간이 없다면 1</span></span><br><span class="line"><span class="keyword">int</span> r = m == <span class="number">0</span> ? <span class="number">0</span> : n % m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 남은 구간 수 만큼</span></span><br><span class="line">&#123; <span class="comment">// r(나머지)가 0이 될때까지 각 구간에 1씩 추가한다.</span></span><br><span class="line">s.push_back(s.back() + q + (r &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));  <span class="comment">// 마지막 원소에 나눌 구간 크기만큼 더하여 추가</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0</span>) r--; <span class="comment">// 나머지 감소</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">reverse(a.<span class="built_in">begin</span>() + s[i], a.<span class="built_in">begin</span>() + s[i + <span class="number">1</span>]); <span class="comment">// s에 저장된 구간으로 나누어 뒤집음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1201&quot;&gt;&lt;a href=&quot;#Problem-1201&quot; class=&quot;headerlink&quot; title=&quot;Problem 1201&quot;&gt;&lt;/a&gt;Problem 1201&lt;/h1&gt;&lt;h2 id=&quot;NMK&quot;&gt;&lt;a href=&quot;#NMK&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14499번 주사위 굴리기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/17/algorithm14499/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/17/algorithm14499/</id>
    <published>2020-03-17T14:40:12.000Z</published>
    <updated>2020-03-17T14:41:23.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14499"><a href="#Problem-14499" class="headerlink" title="Problem 14499"></a>Problem 14499</h1><h2 id="주사위-굴리기"><a href="#주사위-굴리기" class="headerlink" title="주사위 굴리기"></a>주사위 굴리기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line">  <span class="number">6</span></span><br></pre></td></tr></table></figure><p>주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.</p><p>지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.</p><p>주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.</p><p>주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.</p><p>둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10을 넘지 않는 자연수 또는 0이다.</p><p>마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>이동할 때마다 주사위의 윗 면에 쓰여 있는 수를 출력한다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14499" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14499</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2 0 0 8<br>0 2<br>3 4<br>5 6<br>7 8<br>4 4 4 1 3 3 3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0<br>0<br>3<br>0<br>0<br>8<br>6<br>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 3 1 1 9<br>1 2 3<br>4 0 5<br>6 7 8<br>1 3 2 2 4 4 1 1 3</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>0<br>0<br>0<br>3<br>0<br>1<br>0<br>6<br>0</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>2 2 0 0 16<br>0 2<br>3 4<br>4 4 4 4 1 1 1 1 3 3 3 3 2 2 2 2</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>0<br>0<br>0<br>0</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>3 3 0 0 16<br>0 1 2<br>3 4 5<br>6 7 8<br>4 4 1 1 3 3 2 2 4 4 1 1 3 3 2 2</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>0<br>0<br>0<br>6<br>0<br>8<br>0<br>2<br>0<br>8<br>0<br>2<br>0<br>8<br>0<br>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>각 주사위의 면의 변화를 기록하여 좌표의 값에 따른 동작을 잘 구현하면 된다.</li><li>벡터에 명령을 저장했고, 명령에 따른 주사위의 이동을 주사위의 각 면에 해당하는 변수를 만들어 구현하였다.</li><li>예를 들어, 명령 1을 받아 동쪽으로 이동하는 경우를 살펴보자.<ul><li>다음 좌표가 지도의 범위 내에 있는지 확인하여 지도의 범위가 아니라면 해당 명령을 무시하고 다음 명령을 수행한다.</li><li>지도의 범위라면 동쪽으로 이동하므로 바닥면은 동쪽을 보게 되고, 동쪽을 보던 면은 윗면, 윗면은 서쪽 면, 서쪽 면은 바닥면으로 이동하게 된다.</li><li>이 때, 지도의 칸이 0이라면 주사위의 바닥면을 복사하고, 아니라면 지도의 칸을 주사위의 바닥면으로 복사한다.</li><li>이후 x, y를 갱신하여 반복을 이어간다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> dice[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 현재 x,y가 범위에 속하는지 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cmd(k); <span class="comment">// 명령어 저장</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cmd[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주사위의 6면</span></span><br><span class="line"><span class="keyword">int</span> bottom = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> north = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> south = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> east = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> west = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx, ny;</span><br><span class="line"><span class="keyword">switch</span> (cmd[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 동쪽으로 이동하는 경우</span></span><br><span class="line">nx = x; <span class="comment">// 다음 좌표</span></span><br><span class="line">ny = y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123; <span class="comment">// 주사위의 각 면 이동</span></span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = east;</span><br><span class="line">east = top;</span><br><span class="line">top = west;</span><br><span class="line">west = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) <span class="comment">// 지도의 칸이 0인 경우</span></span><br><span class="line">a[nx][ny] = bottom; <span class="comment">// 주사위의 바닥면이 복사</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny]; <span class="comment">// 0이 아니면 주사위의 바닥면으로 복사</span></span><br><span class="line">a[nx][ny] = <span class="number">0</span>; <span class="comment">// 지도의 칸은 0으로 변경</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>; <span class="comment">// 범위를 벗어난 경우 해당 명령 무시</span></span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 서쪽으로 이동하는 경우</span></span><br><span class="line">nx = x;</span><br><span class="line">ny = y - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = west;</span><br><span class="line">west = top;</span><br><span class="line">top = east;</span><br><span class="line">east = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>)</span><br><span class="line">a[nx][ny] = bottom;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny];</span><br><span class="line">a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 북쪽으로 이동하는 경우</span></span><br><span class="line">nx = x - <span class="number">1</span>;</span><br><span class="line">ny = y;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = north;</span><br><span class="line">north = top;</span><br><span class="line">top = south;</span><br><span class="line">south = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>)</span><br><span class="line">a[nx][ny] = bottom;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny];</span><br><span class="line">a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 남쪽으로 이동하는 경우</span></span><br><span class="line">nx = x + <span class="number">1</span>;</span><br><span class="line">ny = y;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = south;</span><br><span class="line">south = top;</span><br><span class="line">top = north;</span><br><span class="line">north = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>)</span><br><span class="line">a[nx][ny] = bottom;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny];</span><br><span class="line">a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; top &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 윗면 출력</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14499&quot;&gt;&lt;a href=&quot;#Problem-14499&quot; class=&quot;headerlink&quot; title=&quot;Problem 14499&quot;&gt;&lt;/a&gt;Problem 14499&lt;/h1&gt;&lt;h2 id=&quot;주사위-굴리기&quot;&gt;&lt;a href=&quot;#주사
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16236번 아기 상어</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/17/algorithm16236/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/17/algorithm16236/</id>
    <published>2020-03-17T04:51:12.000Z</published>
    <updated>2020-03-17T04:59:25.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16236"><a href="#Problem-16236" class="headerlink" title="Problem 16236"></a>Problem 16236</h1><h2 id="아기-상어"><a href="#아기-상어" class="headerlink" title="아기 상어"></a>아기 상어</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.</p><p>아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다.</p><p>아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.</p><p>아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다.</p><ul><li>더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.</li><li>먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.</li><li>먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.<ul><li>거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.</li><li>거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.</li></ul></li></ul><p>아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.</p><p>아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.</p><p>공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.</p><p>둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.</p><ul><li>0: 빈 칸</li><li>1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기</li><li>9: 아기 상어의 위치</li></ul><p>아기 상어는 공간에 한 마리 있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16236" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16236</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>0 0 0<br>0 0 0<br>0 9 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3<br>0 0 1<br>0 0 0<br>0 9 0</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4<br>4 3 2 1<br>0 0 0 0<br>0 0 9 0<br>1 2 3 4</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>12</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6<br>5 4 3 2 3 4<br>4 3 2 3 4 5<br>3 2 9 5 6 6<br>2 1 2 3 4 5<br>3 2 1 6 5 4<br>6 6 6 6 6 6</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>60</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>6<br>6 0 6 0 6 1<br>0 0 0 0 0 2<br>2 3 4 5 6 6<br>0 0 0 0 0 2<br>0 2 0 0 0 0<br>3 9 3 0 0 1</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>48</p><h3 id="예제-입력-6"><a href="#예제-입력-6" class="headerlink" title="예제 입력 6"></a>예제 입력 6</h3><p>6<br>1 1 1 1 1 1<br>2 2 6 2 2 3<br>2 2 5 2 2 3<br>2 2 2 4 6 3<br>0 0 0 0 0 6<br>0 0 0 0 0 9</p><h3 id="예제-출력-6"><a href="#예제-출력-6" class="headerlink" title="예제 출력 6"></a>예제 출력 6</h3><p>39</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>현재 상어의 위치를 기준으로 bfs를 통해 가장 가까운 위치의 먹을 수 있는 물고기를 찾는다.<ul><li>이 때, bfs에서 먹을 수 있는 물고기가 여러마리라면 문제의 조건대로 가장 가깝고, 가장 위, 가장 왼쪽의 물고기가 우선순위가 되도록 하기 위해</li><li>먹을 수 있는 물고기의 위치를 tuple을 사용하여 거리가 같다면 가장 위, 다음 가장 왼쪽 (거리, 행, 열)순서로 오름차순 정렬을 하여 0번째 인덱스의 튜플을 리턴한다.<ul><li>먹을 수 있는 물고기가 없다면 -1을 리턴</li></ul></li></ul></li><li>가장 가까운 물고기의 위치로 상어의 위치를 갱신하고 먹은 자리를 0으로 초기화한다.</li><li>이번 차례의 물고기를 먹기 위해 이동한 거리를 누적하고 물고기의 경험치를 1추가하여 자기의 크기와 같아진다면 크기를 1증가시키고 경험치를 0으로 초기화한다.</li><li>더 이상 먹을 수 있는 물고기가 없어 -1을 리턴받았다면 반복문을 빠져나간다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; bfs(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(x, y));</span><br><span class="line">d[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">tie(x, y) = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; d[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> eat = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span> || a[nx][ny] == <span class="built_in">size</span>) ok = <span class="literal">true</span>; <span class="comment">// 이동 가능 여부</span></span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] != <span class="number">0</span> &amp;&amp; a[nx][ny] &lt; <span class="built_in">size</span>)  <span class="comment">// 먹을 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">ok = <span class="literal">true</span>; <span class="comment">// 이동 가능하고</span></span><br><span class="line">eat = <span class="literal">true</span>; <span class="comment">// 먹을 수 있다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) <span class="comment">// 이동이 가능한 상태라면</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny)); <span class="comment">// 다음 위치</span></span><br><span class="line">d[nx][ny] = d[x][y] + <span class="number">1</span>; <span class="comment">// 거리 1증가</span></span><br><span class="line"><span class="keyword">if</span> (eat) <span class="comment">// 먹을 수 있는 물고기를 만난 경우</span></span><br><span class="line">ans.push_back(make_tuple(d[nx][ny], nx, ny)); <span class="comment">// 먹을 수 있는 물고기가 여러마리라면 위, 왼쪽이 우선</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans.empty()) <span class="comment">// 먹을 수 있는 물고기가 없는 경우</span></span><br><span class="line">ans.push_back(make_tuple(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)); <span class="comment">// -1리턴</span></span><br><span class="line"></span><br><span class="line">sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()); <span class="comment">// 가장 가까운 물고기부터</span></span><br><span class="line"><span class="comment">// 거리가 같다면 가장 위, 다음 가장 왼쪽 (거리, 행, 열)순서로 오름차순 정렬</span></span><br><span class="line"><span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">9</span>) <span class="comment">// 상어의 위치</span></span><br><span class="line">&#123;</span><br><span class="line">x = i;</span><br><span class="line">y = j;</span><br><span class="line">a[i][j] = <span class="number">0</span>; <span class="comment">// 0으로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">2</span>; <span class="comment">// 크기</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>; <span class="comment">// 경험치</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dist;</span><br><span class="line">tie(dist, x, y) = bfs(x, y, <span class="built_in">size</span>); <span class="comment">// 상어의 위치 갱신(가장 가까운 물고기의 위치)</span></span><br><span class="line"><span class="keyword">if</span> (dist == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 더 이상 먹을 수 있는 물고기가 없다면</span></span><br><span class="line">a[x][y] = <span class="number">0</span>; <span class="comment">// 물고기를 먹은 자리는 0으로 초기화</span></span><br><span class="line">ans += dist; <span class="comment">// 이동 거리 추가(초)</span></span><br><span class="line"><span class="built_in">exp</span>++; <span class="comment">// 물고기 경험치</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="built_in">exp</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line"><span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16236&quot;&gt;&lt;a href=&quot;#Problem-16236&quot; class=&quot;headerlink&quot; title=&quot;Problem 16236&quot;&gt;&lt;/a&gt;Problem 16236&lt;/h1&gt;&lt;h2 id=&quot;아기-상어&quot;&gt;&lt;a href=&quot;#아기-상
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 9663번 N-Queen</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/16/algorithm9663/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/16/algorithm9663/</id>
    <published>2020-03-16T05:15:12.000Z</published>
    <updated>2020-03-16T05:16:32.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-9663"><a href="#Problem-9663" class="headerlink" title="Problem 9663"></a>Problem 9663</h1><h2 id="N-Queen"><a href="#N-Queen" class="headerlink" title="N-Queen"></a>N-Queen</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p><p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/9663" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/9663</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>92</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>퀸은 같은 행, 열, 대각선의 모든 칸으로 이동이 가능하므로 동일 행, 열, 대각선에 두 개 이상의 퀸을 놓을 수 없다.</li><li>n * n에 n개를 놓는 경우이므로 한 행에는 한개의 퀸만이 놓일 수 있다.<ul><li>이를 기준으로 재귀를 수행하며 check[row][col]에 퀸을 놓은 위치를 기록한다.</li><li>possible함수로 현재 위치에  퀸을 놓을 수 있는지 판별하여 가능하다면 퀸을 놓고 재귀를 수행한다.<ul><li>possible함수 : 첫 번째 행부터 차례로 퀸을 놓아 내려가고 있으므로 이전 행의 같은 열, 좌측 위 대각선, 우측 위 대각선을 확인하며 퀸이 놓였는지 확인한다.</li></ul></li></ul></li><li>row가 n과 같아졌다면 한 행에 하나의 퀸을 모두 놓은 경우이므로 방법의 수를 1증가시킨다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// (x, y)에 퀸을 놓을 수 있는지 판별하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>, j = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][y]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 같은 열에 놓인 퀸이 있는지 확인</span></span><br><span class="line"><span class="keyword">if</span> (y - j &gt;= <span class="number">0</span> &amp;&amp; check[i][y - j]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 좌측 위 대각선 확인</span></span><br><span class="line"><span class="keyword">if</span> (y + j &lt; n &amp;&amp; check[i][y + j]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 우측 위 대각선 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == n) <span class="comment">// 놓을 수 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (possible(row, col)) <span class="comment">// 현재 (row, col)에 퀸을 놓을 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">check[row][col] = <span class="literal">true</span>; <span class="comment">// 놓은 것을 표시</span></span><br><span class="line">go(row + <span class="number">1</span>);</span><br><span class="line">check[row][col] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">go(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-9663&quot;&gt;&lt;a href=&quot;#Problem-9663&quot; class=&quot;headerlink&quot; title=&quot;Problem 9663&quot;&gt;&lt;/a&gt;Problem 9663&lt;/h1&gt;&lt;h2 id=&quot;N-Queen&quot;&gt;&lt;a href=&quot;#N-Quee
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 13164번 행복 유치원</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/14/algorithm13164/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/14/algorithm13164/</id>
    <published>2020-03-14T11:01:12.000Z</published>
    <updated>2020-03-14T11:02:13.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-13164"><a href="#Problem-13164" class="headerlink" title="Problem 13164"></a>Problem 13164</h1><h2 id="행복-유치원"><a href="#행복-유치원" class="headerlink" title="행복 유치원"></a>행복 유치원</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>행복 유치원 원장인 태양이는 어느 날 N명의 원생들을 키 순서대로 일렬로 줄 세우고, 총 K개의 조로 나누려고 한다. 각 조에는 원생이 적어도 한 명 있어야 하며, 같은 조에 속한 원생들은 서로 인접해 있어야 한다. 조별로 인원수가 같을 필요는 없다.</p><p>이렇게 나뉘어진 조들은 각자 단체 티셔츠를 맞추려고 한다. 조마다 티셔츠를 맞추는 비용은 조에서 가장 키가 큰 원생과 가장 키가 작은 원생의 키 차이만큼 든다. 최대한 비용을 아끼고 싶어 하는 태양이는 K개의 조에 대해 티셔츠 만드는 비용의 합을 최소로 하고 싶어한다. 태양이를 도와 최소의 비용을 구하자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력의 첫 줄에는 유치원에 있는 원생의 수를 나타내는 자연수 N(1 ≤ N ≤ 300,000)과 나누려고 하는 조의 개수를 나타내는 자연수 K(1 ≤ K ≤ N)가 공백으로 구분되어 주어진다. 다음 줄에는 원생들의 키를 나타내는 N개의 자연수가 공백으로 구분되어 줄 서 있는 순서대로 주어진다. 태양이는 원생들을 키 순서대로 줄 세웠으므로, 왼쪽에 있는 원생이 오른쪽에 있는 원생보다 크지 않다. 원생의 키는 109를 넘지 않는 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>티셔츠 만드는 비용이 최소가 되도록 K개의 조로 나누었을 때, 티셔츠 만드는 비용을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/13164" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/13164</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 3<br>1 3 5 6 10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>유치원생의 키를 k개의 구간으로 나누어 각 구간의 (최대 - 최소)의 합이 최소가 되도록 해야 한다.</li><li>그리디 알고리즘으로 해결이 가능한데, 연속된 키의 차이가 가장 큰 k - 1개의 지점을 기준으로 구간을 나누면 된다.<ul><li>연속된 두 키의 차이를 모두 구하여 새로운 벡터에 키의 차와 몇 번째 인덱스의 차이 인지 저장하고</li><li>키 차이를 기준으로 내림차순 정렬을 하여 가장 큰 k - 1개의 지점의 인덱스를 다시 오름차순으로 저장한다.<ul><li>이 때, 마지막 인덱스의 위치도 추가해준다.</li></ul></li><li>저장된 인덱스를 기준으로 각 구간의 (최대 - 최소)를 구해 누적한다.<ul><li>오름차순으로 정렬되어 있으므로 구간의 (마지막 수 - 첫 번째 수)를 구하면 된다.</li></ul></li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">g[i].first = a[i] - a[i - <span class="number">1</span>]; <span class="comment">// 각 수의 차를 저장</span></span><br><span class="line">g[i].second = i; <span class="comment">// 몇 번째 수의 차이인지 같이 저장(i, i - 1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 키 차이를 기준으로 내림차순 정렬</span></span><br><span class="line">sort(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b) &#123; <span class="keyword">return</span> a.first &gt; b.first; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t(k - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)</span><br><span class="line">t[i] = g[i].second; <span class="comment">// 구간을 나눌 지점을 저장</span></span><br><span class="line">sort(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>()); <span class="comment">// 오름차순으로 정렬</span></span><br><span class="line">t.push_back(n); <span class="comment">// 마지막 인덱스 추가</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">ans += (a[t[i] - <span class="number">1</span>] - a[tmp]); <span class="comment">// 각 구간의 차를 누적</span></span><br><span class="line">tmp = t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-13164&quot;&gt;&lt;a href=&quot;#Problem-13164&quot; class=&quot;headerlink&quot; title=&quot;Problem 13164&quot;&gt;&lt;/a&gt;Problem 13164&lt;/h1&gt;&lt;h2 id=&quot;행복-유치원&quot;&gt;&lt;a href=&quot;#행복-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1300번 k번째 수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/13/algorithm1300/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/13/algorithm1300/</id>
    <published>2020-03-13T13:11:12.000Z</published>
    <updated>2020-03-13T13:44:05.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1300"><a href="#Problem-1300" class="headerlink" title="Problem 1300"></a>Problem 1300</h1><h2 id="k번째-수"><a href="#k번째-수" class="headerlink" title="k번째 수"></a>k번째 수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.</p><p>배열 A와 B의 인덱스는 1부터 시작한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 배열의 크기 N이 주어진다. N은 10^5보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(10^9, N2)보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>B[k]를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1300" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1300</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>B의 현재 원소의 인덱스를 구해 k와 비교하며 이분 탐색을 수행한다.</li><li>인덱스를 구하는 방법은 현재 원소보다 작거나 같은 원소의 개수를 구하면 된다.<ul><li>예를 들어, 5 * 5 행렬에서 8보다 작거나 같은 수의 개수를 구한다면</li></ul></li></ul><p><strong>1 2 3 4 5</strong><br><strong>2 4 6 8</strong> 10<br><strong>3 6</strong> 9 12 15<br><strong>4 8</strong> 12 16 20<br><strong>5</strong> 10 15 20 25</p><ul><li>a[i][j] = i * j 이므로 위와 같이 구할 수 있다.<ul><li>즉, 8을 1부터 n까지 각 행으로 나누었을 때의 몫이 그 행에서 8보다 작거나 같은 수의 개수가 된다.</li><li>이 때, 1행과 같이 몫이 8보다 작다면 n이 8보다 작거나 같은 수의 개수가 된다.</li><li>또한 8로 나누어 떨어지는 행에는 8이 존재한다.</li></ul></li><li>따라서 위와 같이 8보다 작거나 같은 수의 개수를 구하면 14가 되고, 이것이 8의 인덱스가 된다.(1부터 시작)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">go</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> mid)</span> <span class="comment">// mid의 인덱스를 구하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123; <span class="comment">// 현재 원소(mid)보다 작거나 같은 수의 개수를 count</span></span><br><span class="line">cnt += <span class="built_in">min</span>(n, mid / i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt; <span class="comment">// mid의 인덱스</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> right = n * n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 현재 원소</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (go(mid) &gt;= k) <span class="comment">// 현재 원소의 인덱스가 더 크다면</span></span><br><span class="line">&#123;</span><br><span class="line">ans = mid;</span><br><span class="line">right = mid - <span class="number">1</span>; <span class="comment">// 현재 원소를 감소시켜 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1300&quot;&gt;&lt;a href=&quot;#Problem-1300&quot; class=&quot;headerlink&quot; title=&quot;Problem 1300&quot;&gt;&lt;/a&gt;Problem 1300&lt;/h1&gt;&lt;h2 id=&quot;k번째-수&quot;&gt;&lt;a href=&quot;#k번째-수&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1981번 배열에서 이동</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/13/algorithm1981/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/13/algorithm1981/</id>
    <published>2020-03-13T07:51:12.000Z</published>
    <updated>2020-03-13T10:57:48.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1981"><a href="#Problem-1981" class="headerlink" title="Problem 1981"></a>Problem 1981</h1><h2 id="배열에서-이동"><a href="#배열에서-이동" class="headerlink" title="배열에서 이동"></a>배열에서 이동</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>n×n짜리의 배열이 하나 있다. 이 배열의 (1, 1)에서 (n, n)까지 이동하려고 한다. 이동할 때는 상, 하, 좌, 우의 네 인접한 칸으로만 이동할 수 있다.</p><p>이와 같이 이동하다 보면, 배열에서 몇 개의 수를 거쳐서 이동하게 된다. 이동하기 위해 거쳐 간 수들 중 최댓값과 최솟값의 차이가 가장 작아지는 경우를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n(2≤n≤100)이 주어진다. 다음 n개의 줄에는 배열이 주어진다. 배열의 각 수는 0보다 크거나 같고, 200보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 (최대 - 최소)가 가장 작아질 때의 그 값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1981" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1981</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>1 1 3 6 8<br>1 2 2 5 5<br>4 4 0 3 3<br>8 0 2 3 4<br>4 3 0 2 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>이분 탐색을 이용하여 최대, 최소의 차이를 확인하며 현재 차이값으로 (0, 0)에서 (n-1, n-1)까지 이동이 가능한지 확인하면 된다.</li><li>이 때, 최대, 최소의 차이만으로는 모든 경우를 확인할 수 없다.<ul><li>따라서 현재 차이값에서 가능한 최대, 최솟값을 모두 확인하여 가능한 경우가 있는지를 판별한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> <span class="built_in">min</span>, <span class="keyword">int</span> <span class="built_in">max</span>)</span> <span class="comment">// 현재 최대, 최솟값으로 (n-1,n-1)까지 이동 가능한지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>][<span class="number">0</span>] &lt; <span class="built_in">min</span> || a[<span class="number">0</span>][<span class="number">0</span>] &gt; <span class="built_in">max</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 범위를 벗어나면 false</span></span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">check[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">q.push(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front().first;</span><br><span class="line"><span class="keyword">int</span> y = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[nx][ny])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] &lt;= <span class="built_in">max</span> &amp;&amp; a[nx][ny] &gt;= <span class="built_in">min</span>) <span class="comment">// 최대 최소의 범위 내에서 이동</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny));</span><br><span class="line">check[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> check[n - <span class="number">1</span>][n - <span class="number">1</span>]; <span class="comment">// (n-1,n-1)까지 이동 가능한지 판별</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + mid &lt;= <span class="number">200</span>; i++) <span class="comment">// 0부터 차이의 합이 200보다 작을 때까지</span></span><br><span class="line">&#123; <span class="comment">// 차이가 mid인 모든 최대, 최소의 경우를 확인</span></span><br><span class="line"><span class="keyword">if</span> (bfs(i, i + mid))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; a[i][j]) <span class="built_in">max</span> = a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> right = <span class="built_in">max</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 이분 탐색</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="keyword">if</span> (go(mid))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; mid)</span><br><span class="line">ans = mid;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1981&quot;&gt;&lt;a href=&quot;#Problem-1981&quot; class=&quot;headerlink&quot; title=&quot;Problem 1981&quot;&gt;&lt;/a&gt;Problem 1981&lt;/h1&gt;&lt;h2 id=&quot;배열에서-이동&quot;&gt;&lt;a href=&quot;#배열에서-이
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 15658번 연산자 끼워넣기 (2)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/12/algorithm15658/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/12/algorithm15658/</id>
    <published>2020-03-12T09:31:12.000Z</published>
    <updated>2020-03-12T09:54:56.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-15658"><a href="#Problem-15658" class="headerlink" title="Problem 15658"></a>Problem 15658</h1><h2 id="연산자-끼워넣기-2"><a href="#연산자-끼워넣기-2" class="headerlink" title="연산자 끼워넣기 (2)"></a>연산자 끼워넣기 (2)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N개의 수로 이루어진 수열 A1, A2, …, AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다. 연산자의 개수는 N-1보다 많을 수도 있다. 모든 수의 사이에는 연산자를 한 개 끼워넣어야 하며, 주어진 연산자를 모두 사용하지 않고 모든 수의 사이에 연산자를 끼워넣을 수도 있다.</p><p>우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.</p><p>예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 3개, 뺄셈(-) 2개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 250가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.</p><ul><li>1+2+3-4×5÷6</li><li>1÷2+3+4-5×6</li><li>1+2÷3×4-5+6</li><li>1÷2×3-4+5+6</li><li>1+2+3+4-5-6</li><li>1+2+3-4-5×6</li></ul><p>식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 음수를 양수로 나눌 때는 C++14의 기준을 따른다. 즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.</p><ul><li>1+2+3-4×5÷6 = 1</li><li>1÷2+3+4-5×6 = 12</li><li>1+2÷3×4-5+6 = 5</li><li>1÷2×3-4+5+6 = 7</li><li>1+2+3+4-5-6 = -1</li><li>1+2+3-4-5×6 = -18</li></ul><p>N개의 수와 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1보다 크거나 같고, 4N보다 작거나 같은 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/15658" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/15658</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2<br>5 6<br>1 1 1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>30<br>-1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3<br>3 4 5<br>2 1 2 1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>60<br>-5</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6<br>1 2 3 4 5 6<br>3 2 1 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>72<br>-48</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>처음엔 순열을 이용하여 모든 연산자의 개수에서 n - 1개를 뽑아 모든 경우를 확인하였더니 시간초과가 난다. 최대 O(44C11 * 11)가 걸리니 당연한 결과였다.</li><li>방법을 바꾸어 4개의 연산자 중 1개를 뽑은 경우이니 최대 O(4^10)으로 해결이 가능하다. 각 연산자의 개수가 0보다 큰 경우 재귀를 수행한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ul><li><p>처음 작성한 코드, 최대 O(44C11 * 11)로 시간 초과.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; oper;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selected;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> max_ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> min_ans = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> <span class="comment">// 현재 연산자 순서로 결과를 구하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (selected[i - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">res += a[i];</span><br><span class="line"><span class="keyword">if</span> (selected[i - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">res -= a[i];</span><br><span class="line"><span class="keyword">if</span> (selected[i - <span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">res * = a[i];</span><br><span class="line"><span class="keyword">if</span> (selected[i - <span class="number">1</span>] == <span class="number">3</span>)</span><br><span class="line">res /= a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == n - <span class="number">1</span>) <span class="comment">// 필요한 연산자의 개수가 구해지면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> res = calc(a);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">if</span> (max_ans &lt; res) max_ans = res; <span class="comment">// 최대</span></span><br><span class="line"><span class="keyword">if</span> (min_ans &gt; res) min_ans = res; <span class="comment">// 최소</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oper.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i]) <span class="keyword">continue</span>; <span class="comment">// 중복 제거</span></span><br><span class="line">check[i] = <span class="literal">true</span>;</span><br><span class="line">selected.push_back(oper[i]); <span class="comment">// 연산자 추가</span></span><br><span class="line">go(a, index + <span class="number">1</span>);</span><br><span class="line">selected.pop_back();</span><br><span class="line">check[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; op[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; op[i]; j++) <span class="comment">// 각 연산자를 개수대로 삽입</span></span><br><span class="line">oper.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">go(a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max_ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min_ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>정답 코드, 최대 O(4^10)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> op[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> max_ans = -INT_MAX + <span class="number">1</span>; <span class="comment">// 최댓값이 음수일수도 있음</span></span><br><span class="line"><span class="keyword">int</span> min_ans = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> index, <span class="keyword">int</span> plus, <span class="keyword">int</span> minus, <span class="keyword">int</span> multi, <span class="keyword">int</span> div, <span class="keyword">int</span> res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == n) <span class="comment">// 필요한 연산자의 개수가 구해지면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max_ans &lt; res) max_ans = res; <span class="comment">// 최대</span></span><br><span class="line"><span class="keyword">if</span> (min_ans &gt; res) min_ans = res; <span class="comment">// 최소</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 각 연산자의 수가 0보다 클 때, 재귀</span></span><br><span class="line"><span class="keyword">if</span> (plus &gt; <span class="number">0</span>) go(a, index + <span class="number">1</span>, plus - <span class="number">1</span>, minus, multi, div, res + a[index]);</span><br><span class="line"><span class="keyword">if</span> (minus &gt; <span class="number">0</span>) go(a, index + <span class="number">1</span>, plus, minus - <span class="number">1</span>, multi, div, res - a[index]);</span><br><span class="line"><span class="keyword">if</span> (multi &gt; <span class="number">0</span>) go(a, index + <span class="number">1</span>, plus, minus, multi - <span class="number">1</span>, div, res * a[index]);</span><br><span class="line"><span class="keyword">if</span> (div &gt; <span class="number">0</span>) go(a, index + <span class="number">1</span>, plus, minus, multi, div - <span class="number">1</span>, res / a[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; op[i];</span><br><span class="line"></span><br><span class="line">go(a, <span class="number">1</span>, op[<span class="number">0</span>], op[<span class="number">1</span>], op[<span class="number">2</span>], op[<span class="number">3</span>], a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max_ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min_ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-15658&quot;&gt;&lt;a href=&quot;#Problem-15658&quot; class=&quot;headerlink&quot; title=&quot;Problem 15658&quot;&gt;&lt;/a&gt;Problem 15658&lt;/h1&gt;&lt;h2 id=&quot;연산자-끼워넣기-2&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1967번 트리의 지름</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/12/algorithm1967/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/12/algorithm1967/</id>
    <published>2020-03-12T01:51:12.000Z</published>
    <updated>2020-03-27T00:43:11.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1967"><a href="#Problem-1967" class="headerlink" title="Problem 1967"></a>Problem 1967</h1><h2 id="트리의-지름"><a href="#트리의-지름" class="headerlink" title="트리의 지름"></a>트리의 지름</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.</p><p>이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.</p><p>입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>파일의 첫 번째 줄은 노드의 개수 n(1 ≤ n ≤ 10,000)이다. 둘째 줄부터 n번째 줄까지 각 간선에 대한 정보가 들어온다. 간선에 대한 정보는 세 개의 정수로 이루어져 있다. 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호를 나타내고, 두 번째 정수는 자식 노드를, 세 번째 정수는 간선의 가중치를 나타낸다. 간선에 대한 정보는 부모 노드의 번호가 작은 것이 먼저 입력되고, 부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. 루트 노드의 번호는 항상 1이라고 가정하며, 간선의 가중치는 100보다 크지 않은 양의 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 트리의 지름을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1967" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1967</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>12<br>1 2 3<br>1 3 2<br>2 4 5<br>3 5 11<br>3 6 9<br>4 7 1<br>4 8 7<br>5 9 15<br>5 10 4<br>6 11 6<br>6 12 10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>45</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>트리의 지름를 구하는 문제이다. 1167번 트리의 지름 문제와 똑같다고 할 수 있다.<ul><li>입력 방식만 바꿔서 풀었다.</li></ul></li><li>트리에 존재하는 모든 경로 중에서 가장 긴 것의 길이를 트리의 지름이라 한다.</li><li>트리의 지름은 탐색 2번으로 구할 수 있다.<ul><li>한 정점 s에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점을 u라고 한다.</li><li>u에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점 v를 구한다.</li><li>이 때, u와 v사이의 거리가 트리의 지름이다.</li></ul></li><li>인접 리스트를 저장할 벡터에 각 노드와 연결된 노드와 그 사이의 거리를 저장한다.</li><li>bfs를 이용하여 임의의 한 정점에서 다른 모든 정점까지의 거리를 구하고 그 최댓값을 가지는 인덱스를 반환한다.</li><li>반환받은 정점에서 다시 bfs를 수행하여 가장 먼 노드까지의 거리를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dist[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 정점의 개수</span></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bfs(<span class="keyword">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(start);</span><br><span class="line">check[start] = <span class="literal">true</span>;</span><br><span class="line">dist[start] = <span class="number">0</span>; <span class="comment">// 시작 노드의 거리는 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i].first;</span><br><span class="line"><span class="keyword">int</span> ndist = a[node][i].second;</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(next);</span><br><span class="line">check[next] = <span class="literal">true</span>;</span><br><span class="line">dist[next] = dist[node] + ndist; <span class="comment">// 시작점과의 거리를 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; dist[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = dist[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123; index, <span class="built_in">max</span> &#125;; <span class="comment">// 가장 먼 거리와 그 인덱스를 리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, d; <span class="comment">// d : 거리</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;</span><br><span class="line">a[u].push_back(make_pair(v, d));</span><br><span class="line">a[v].push_back(make_pair(u, d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp = bfs(<span class="number">1</span>); <span class="comment">// 어느 한 지점부터 가장 먼 노드를 구함</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res = bfs(tmp.first); <span class="comment">// 그 노드부터 다시 가장 먼 노드까지의 거리가 정답</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1967&quot;&gt;&lt;a href=&quot;#Problem-1967&quot; class=&quot;headerlink&quot; title=&quot;Problem 1967&quot;&gt;&lt;/a&gt;Problem 1967&lt;/h1&gt;&lt;h2 id=&quot;트리의-지름&quot;&gt;&lt;a href=&quot;#트리의-지름&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14226번 이모티콘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/11/algorithm14226/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/11/algorithm14226/</id>
    <published>2020-03-11T10:51:12.000Z</published>
    <updated>2020-03-27T00:14:02.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14226"><a href="#Problem-14226" class="headerlink" title="Problem 14226"></a>Problem 14226</h1><h2 id="이모티콘"><a href="#이모티콘" class="headerlink" title="이모티콘"></a>이모티콘</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>영선이는 매우 기쁘기 때문에, 효빈이에게 스마일 이모티콘을 S개 보내려고 한다.</p><p>영선이는 이미 화면에 이모티콘 1개를 입력했다. 이제, 다음과 같은 3가지 연산만 사용해서 이모티콘을 S개 만들어 보려고 한다.</p><p>화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.<br>클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.<br>화면에 있는 이모티콘 중 하나를 삭제한다.<br>모든 연산은 1초가 걸린다. 또, 클립보드에 이모티콘을 복사하면 이전에 클립보드에 있던 내용은 덮어쓰기가 된다. 클립보드가 비어있는 상태에는 붙여넣기를 할 수 없으며, 일부만 클립보드에 복사할 수는 없다. 또한, 클립보드에 있는 이모티콘 중 일부를 삭제할 수 없다. 화면에 이모티콘을 붙여넣기 하면, 클립보드에 있는 이모티콘의 개수가 화면에 추가된다.</p><p>영선이가 S개의 이모티콘을 화면에 만드는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 S (2 ≤ S ≤ 1000) 가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14226" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14226</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>4</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>5</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>18</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>8</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ol><li>화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.</li><li>클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.</li><li>화면에 있는 이모티콘 중 하나를 삭제한다.</li></ol><ul><li>주어진 조건에 따라 bfs를 수행하면 된다.</li><li>처음에는 문제를 잘 이해하지 못했었다. 화면에 있는 모든 이모티콘을 클립보드에 저장하고 붙여넣기를 하는 연산을 2초짜리 하나의 연산으로 생각하고 문제를 풀었다.</li><li>하지만 그게 아니라 새로 이모티콘을 복사하지 않고 이전에 클립보드에 저장해둔 이모티콘을 붙여넣는 경우도 있다는 것을 깨달았다.</li><li>d라는 2중 배열을 사용하여 이모티콘의 수 s와 클립보드에 저장된 이모티콘의 개수 c를 저장하였다.</li><li>초기값을 d[1][0] = 0 으로 설정하고 큐에 pair(1, 0)을 시작 노드로 하여 bfs를 수행한다.</li><li>d는 모두 -1로 초기화를 하였으므로 아직 방문하지 않은 노드에는 -1이 저장되어 있다.</li></ul><ol><li>먼저 복사하는 경우, 클립보드에 s를 복사해야 하므로 d[s][s]가 -1인 경우 수행하며 d[s][s]에 d[s][c] + 1을 넣어 이전 상태에서 1초를 추가하고, (s, s)를 큐에 push한다.</li><li>클립보드에 있는 이모티콘을 붙여넣기 하는 경우, s + c &lt;= n 이고 d[s + c][c]가 -1인 경우 수행하며 d[s + c][c]에 d[s][c] + 1을 넣어 이전 상태에서 1초를 추가하고, (s + c, c)를 큐에 push한다.</li><li>화면에 있는 이모티콘 하나를 삭제하는 경우, s - 1 &gt;= 0 이고 이고 d[s - 1][c]가 -1인 경우 수행하며 d[s - 1][c]에 d[s][c] + 1을 넣어 이전 상태에서 1초를 추가하고, (s - 1, c)를 큐에 push한다.</li></ol><ul><li>이후 d[n][i]의 -1이 아닌 최솟값을 구하면 된다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>]; <span class="comment">// d[s][clipboard]의 상태에 되기 까지 걸리는 시간(초)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n; <span class="comment">// 만들어야 할 이모티콘 수</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d)); <span class="comment">// -1로 초기화 : -1은 방문하기 전</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q; <span class="comment">// s, clipboard</span></span><br><span class="line">q.push(make_pair(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 초기값, 이모티콘 수는 1, 클립보드에는 0개, 걸리는 시간 0초</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s = q.front().first;</span><br><span class="line"><span class="keyword">int</span> c = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d[s][s] == <span class="number">-1</span>) <span class="comment">// 복사하는 경우, 클립보드에 s를 복사한다.</span></span><br><span class="line">&#123; <span class="comment">// 이모티콘 수가 s개이고 클립보드에 s개가 있는경우를 탐색하지 않았다면</span></span><br><span class="line">q.push(make_pair(s, s));</span><br><span class="line">d[s][s] = d[s][c] + <span class="number">1</span>; <span class="comment">// 이전 상태에서 1초를 추가</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s + c &lt;= n &amp;&amp; d[s + c][c] == <span class="number">-1</span>) <span class="comment">// 붙여넣기를 하는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(s + c, c)); <span class="comment">// 화면에 c개의 이모티콘이 추가됨</span></span><br><span class="line">d[s + c][c] = d[s][c] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; d[s - <span class="number">1</span>][c] == <span class="number">-1</span>) <span class="comment">// 이모티콘 하나를 삭제하는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(s - <span class="number">1</span>, c));</span><br><span class="line">d[s - <span class="number">1</span>][c] = d[s][c] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[n][i] != <span class="number">-1</span>) <span class="comment">// -1이 아닌 최솟값을 구한다.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans == <span class="number">-1</span> || ans &gt; d[n][i])</span><br><span class="line">ans = d[n][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14226&quot;&gt;&lt;a href=&quot;#Problem-14226&quot; class=&quot;headerlink&quot; title=&quot;Problem 14226&quot;&gt;&lt;/a&gt;Problem 14226&lt;/h1&gt;&lt;h2 id=&quot;이모티콘&quot;&gt;&lt;a href=&quot;#이모티콘&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16964번 DFS 스페셜 저지</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/11/algorithm16964/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/11/algorithm16964/</id>
    <published>2020-03-11T06:51:12.000Z</published>
    <updated>2020-03-26T23:59:16.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16964"><a href="#Problem-16964" class="headerlink" title="Problem 16964"></a>Problem 16964</h1><h2 id="DFS-스페셜-저지"><a href="#DFS-스페셜-저지" class="headerlink" title="DFS 스페셜 저지"></a>DFS 스페셜 저지</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>BOJ에서 정답이 여러가지인 경우에는 스페셜 저지를 사용한다. 스페셜 저지는 유저가 출력한 답을 검증하는 코드를 통해서 정답 유무를 결정하는 방식이다. 오늘은 스페셜 저지 코드를 하나 만들어보려고 한다.</p><p>정점의 개수가 N이고, 정점에 1부터 N까지 번호가 매겨져있는 양방향 그래프가 있을 때, DFS 알고리즘은 다음과 같은 형태로 이루어져 있다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (check[x] == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    check[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// x를 방문</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y : x와 인접한 정점) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check[y] == <span class="literal">false</span>) &#123;</span><br><span class="line">            dfs(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 문제에서 시작 정점은 1이기 때문에 가장 처음에 호출하는 함수는 dfs(1)이다. DFS 방문 순서는 dfs함수에서 // x를 방문 이라고 적힌 곳에 도착한 정점 번호를 순서대로 나열한 것이다.</p><p>트리가 주어졌을 때, 올바른 DFS 방문 순서인지 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정점의 수 N(2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에는 트리의 간선 정보가 주어진다. 마지막 줄에는 DFS 방문 순서가 주어진다. DFS 방문 순서는 항상 N개의 정수로 이루어져 있으며, 1부터 N까지 자연수가 한 번씩 등장한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>입력으로 주어진 DFS 방문 순서가 올바른 순서면 1, 아니면 0을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16964" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16964</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>1 2<br>1 3<br>2 4<br>1 2 3 4</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4<br>1 2<br>1 3<br>2 4<br>1 2 4 3</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4<br>1 2<br>1 3<br>2 4<br>1 3 2 4</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>입력된 방문 순서가 올바른 dfs의 순서인지 판별하는 문제이다.</li><li>입력된 방문 순서에 따라 각 노드의 인접 리스트를 정렬한 후 dfs를 수행하였을때<ul><li>입력된 방문 순서와 같은 순서가 나온다면 올바른 순서이고 아니라면 잘못된 순서이다.</li></ul></li><li>입력된 방문 순서를 저장할 벡터 d와 입력받은 방문 순서대로 인덱스를 저장할 벡터 order을 만든다.<ul><li>order[d[i]] = i 와 같이 입력된 노드 순서대로 인덱스를 저장한다.</li><li>각 노드의 인접 리스트가 저장된 벡터 a를 모두 order에 저장된 순서로 정렬한다.</li></ul></li><li>이후 그 순서로 bfs를 수행한 결과를 dfs_order라는 벡터에 담고 b와 비교하여 같으면 1, 다르면 0을 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">100001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs_order;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = <span class="literal">true</span>;</span><br><span class="line">dfs_order.push_back(node); <span class="comment">// 확인할 벡터의 순서에 따라 정렬된 인접 리스트로 dfs를 수행한 결과를 담는다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="literal">false</span>)</span><br><span class="line">dfs(next, d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 정점의 개수</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">u--; v--; <span class="comment">// 정점을 0부터 시작하도록 지정(인덱스가 0부터 시작하므로)</span></span><br><span class="line">a[u].push_back(v);</span><br><span class="line">a[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d(n);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">d[i]--; <span class="comment">// 정점을 0부터 시작</span></span><br><span class="line">order[d[i]] = i; <span class="comment">// 확인할 벡터의 순서를 저장할 벡터</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">sort(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> order[a] &lt; order[b]; <span class="comment">// 인접 리스트를 확인할 벡터의 순서에 따라 정렬</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>, d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d == dfs_order)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16964&quot;&gt;&lt;a href=&quot;#Problem-16964&quot; class=&quot;headerlink&quot; title=&quot;Problem 16964&quot;&gt;&lt;/a&gt;Problem 16964&lt;/h1&gt;&lt;h2 id=&quot;DFS-스페셜-저지&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1167번 트리의 지름</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/11/algorithm1167/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/11/algorithm1167/</id>
    <published>2020-03-11T01:51:12.000Z</published>
    <updated>2020-03-27T00:13:18.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1167"><a href="#Problem-1167" class="headerlink" title="Problem 1167"></a>Problem 1167</h1><h2 id="트리의-지름"><a href="#트리의-지름" class="headerlink" title="트리의 지름"></a>트리의 지름</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2≤V≤100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. (정점 번호는 1부터 V까지 매겨져 있다고 생각한다)</p><p>먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 트리의 지름을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1167" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1167</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>1 3 2 -1<br>2 4 4 -1<br>3 1 2 4 3 -1<br>4 2 4 3 3 5 6 -1<br>5 4 6 -1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>트리의 지름를 구하는 문제이다.</li><li>트리에 존재하는 모든 경로 중에서 가장 긴 것의 길이를 트리의 지름이라 한다.</li><li>트리의 지름은 탐색 2번으로 구할 수 있다.<ul><li>한 정점 s에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점을 u라고 한다.</li><li>u에서 모든 정점까지의 거리를 구한다. 이 때, 가장 먼 거리인 정점 v를 구한다.</li><li>이 때, u와 v사이의 거리가 트리의 지름이다.</li></ul></li><li>인접 리스트를 저장할 벡터에 각 노드와 연결된 노드와 그 사이의 거리를 저장한다.</li><li>bfs를 이용하여 임의의 한 정점에서 다른 모든 정점까지의 거리를 구하고 그 최댓값을 가지는 인덱스를 반환한다.</li><li>반환받은 정점에서 다시 bfs를 수행하여 가장 먼 노드까지의 거리를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dist[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 정점의 개수</span></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; bfs(<span class="keyword">int</span> start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(start);</span><br><span class="line">check[start] = <span class="literal">true</span>;</span><br><span class="line">dist[start] = <span class="number">0</span>; <span class="comment">// 시작 노드의 거리는 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i].first;</span><br><span class="line"><span class="keyword">int</span> ndist = a[node][i].second;</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(next);</span><br><span class="line">check[next] = <span class="literal">true</span>;</span><br><span class="line">dist[next] = dist[node] + ndist; <span class="comment">// 시작점과의 거리를 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; dist[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = dist[i];</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123; index, <span class="built_in">max</span> &#125;; <span class="comment">// 가장 먼 거리와 그 인덱스를 리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// 현재 정점</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// -1이면 다음 노드로</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">a[k].push_back(make_pair(l, m)); <span class="comment">// k와 연결된 노드와 거리 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp = bfs(<span class="number">1</span>); <span class="comment">// 어느 한 지점부터 가장 먼 노드를 구함</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res = bfs(tmp.first); <span class="comment">// 그 노드부터 다시 가장 먼 노드까지의 거리가 정답</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1167&quot;&gt;&lt;a href=&quot;#Problem-1167&quot; class=&quot;headerlink&quot; title=&quot;Problem 1167&quot;&gt;&lt;/a&gt;Problem 1167&lt;/h1&gt;&lt;h2 id=&quot;트리의-지름&quot;&gt;&lt;a href=&quot;#트리의-지름&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16940번 BFS 스페셜 저지</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/11/algorithm16940/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/11/algorithm16940/</id>
    <published>2020-03-11T00:51:12.000Z</published>
    <updated>2020-03-26T23:58:05.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16940"><a href="#Problem-16940" class="headerlink" title="Problem 16940"></a>Problem 16940</h1><h2 id="BFS-스페셜-저지"><a href="#BFS-스페셜-저지" class="headerlink" title="BFS 스페셜 저지"></a>BFS 스페셜 저지</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>BOJ에서 정답이 여러가지인 경우에는 스페셜 저지를 사용한다. 스페셜 저지는 유저가 출력한 답을 검증하는 코드를 통해서 정답 유무를 결정하는 방식이다. 오늘은 스페셜 저지 코드를 하나 만들어보려고 한다.</p><p>정점의 개수가 N이고, 정점에 1부터 N까지 번호가 매겨져있는 양방향 그래프가 있을 때, BFS 알고리즘은 다음과 같은 형태로 이루어져 있다.</p><p>큐에 시작 정점을 넣는다. 이 문제에서 시작 정점은 1이다. 1을 방문했다고 처리한다.<br>큐가 비어 있지 않은 동안 다음을 반복한다.<br>큐에 들어있는 첫 정점을 큐에서 꺼낸다. 이 정점을 x라고 하자.<br>x와 연결되어 있으면, 아직 방문하지 않은 정점 y를 모두 큐에 넣는다. 모든 y를 방문했다고 처리한다.<br>2-2 단계에서 방문하지 않은 정점을 방문하는 순서는 중요하지 않다. 따라서, BFS의 결과는 여러가지가 나올 수 있다.</p><p>트리가 주어졌을 때, 올바른 BFS 방문 순서인지 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정점의 수 N(2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에는 트리의 간선 정보가 주어진다. 마지막 줄에는 BFS 방문 순서가 주어진다. BFS 방문 순서의 항상 N개의 정수로 이루어져 있으며, 1부터 N까지 자연수가 한 번씩 등장한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>입력으로 주어진 BFS 방문 순서가 올바른 순서면 1, 아니면 0을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16940" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16940</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>1 2<br>1 3<br>2 4<br>1 2 3 4</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4<br>1 2<br>1 3<br>2 4<br>1 2 4 3</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>0</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>입력된 방문 순서가 올바른 bfs의 순서인지 판별하는 문제이다.</li><li>입력된 방문 순서에 따라 각 노드의 인접 리스트를 정렬한 후 bfs를 수행하였을때<ul><li>입력된 방문 순서와 같은 순서가 나온다면 올바른 순서이고 아니라면 잘못된 순서이다.</li></ul></li><li>입력된 방문 순서를 저장할 벡터 b와 입력받은 방문 순서대로 인덱스를 저장할 벡터 order을 만든다.<ul><li>order[b[i]] = i 와 같이 입력된 노드 순서대로 인덱스를 저장한다.</li><li>각 노드의 인접 리스트가 저장된 벡터 a를 모두 order에 저장된 순서로 정렬한다.</li></ul></li><li>이후 그 순서로 bfs를 수행한 결과를 bfs_order라는 벡터에 담고 b와 비교하여 같으면 1, 다르면 0을 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 정점의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">a[u].push_back(v);</span><br><span class="line">a[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(n + <span class="number">1</span>); <span class="comment">// 이 벡터에 입력된 순서가 맞는지 확인해야함</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(n + <span class="number">1</span>); <span class="comment">// 인접리스트를 정렬하기 위한 기준 벡터(확인할 벡터의 순서)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">order[b[i]] = i; <span class="comment">// 입력을 받은 순서대로 인덱스를 저장할 벡터</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sort(a[i].<span class="built_in">begin</span>(), a[i].<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">int</span>&amp; u, <span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> order[u] &lt; order[v];</span><br><span class="line">&#125;); <span class="comment">// 인접 리스트를 확인할 벡터의 순서로 정렬한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bfs_order; <span class="comment">// bfs가 맞는지 검사할 배열의 순서로 정렬된 a로 실제 bfs를 수행한 순서를 저장할 벡터</span></span><br><span class="line">bfs_order.push_back(<span class="number">0</span>); <span class="comment">// b와 비교하기 위해(b는 1부터 시작되므로)</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line">check[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">bfs_order.push_back(node); <span class="comment">// pop할때 출력</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(next);</span><br><span class="line">check[next] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bfs_order == b) <span class="comment">// 확인할 벡터와 그 순서로 정렬된 인접리스트로 bfs를 수행한 벡터를 비교</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16940&quot;&gt;&lt;a href=&quot;#Problem-16940&quot; class=&quot;headerlink&quot; title=&quot;Problem 16940&quot;&gt;&lt;/a&gt;Problem 16940&lt;/h1&gt;&lt;h2 id=&quot;BFS-스페셜-저지&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

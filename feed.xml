<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-02-17T03:25:57.877Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 16929번 Two Dots</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/</id>
    <published>2020-02-17T03:24:28.000Z</published>
    <updated>2020-02-17T03:25:57.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16929"><a href="#Problem-16929" class="headerlink" title="Problem 16929"></a>Problem 16929</h1><h2 id="Two-Dots"><a href="#Two-Dots" class="headerlink" title="Two Dots"></a>Two Dots</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>Two Dots는 Playdots, Inc.에서 만든 게임이다. 게임의 기초 단계는 크기가 N×M인 게임판 위에서 진행된다.</p><p>각각의 칸은 색이 칠해진 공이 하나씩 있다. 이 게임의 핵심은 같은 색으로 이루어진 사이클을 찾는 것이다.</p><p>다음은 위의 게임판에서 만들 수 있는 사이클의 예시이다.</p><p>점 k개 d1, d2, …, dk로 이루어진 사이클의 정의는 아래와 같다.</p><ul><li>모든 k개의 점은 서로 다르다.</li><li>k는 4보다 크거나 같다.</li><li>모든 점의 색은 같다.</li><li>모든 1 ≤ i ≤ k-1에 대해서, di와 di+1은 인접하다. 또, dk와 d1도 인접해야 한다. 두 점이 인접하다는 것은 각각의 점이 들어있-는 칸이 변을 공유한다는 의미이다.</li></ul><p>게임판의 상태가 주어졌을 때, 사이클이 존재하는지 아닌지 구해보자.</p><p>2 ≤ N, M ≤ 50</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판의 크기 N, M이 주어진다. 둘째 줄부터 N개의 줄에 게임판의 상태가 주어진다. 게임판은 모두 점으로 가득차 있고, 게임판의 상태는 점의 색을 의미한다. 점의 색은 알파벳 대문자 한 글자이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>사이클이 존재하는 경우에는 “Yes”, 없는 경우에는 “No”를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 4<br>AAAA<br>ABCA<br>AAAA</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>Yes</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 4<br>AAAA<br>ABCA<br>AADA</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>No</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>Yes</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>Yes</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>No</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>문제에서 주어진 조건에 맞는 사이클이 형성되는지 찾는 문제이다. dfs를 통해 해결할 수 있다.</p></li><li><p>방문 여부를 체크할 배열과 탐색을 시작한 점부터 이동한 거리를 나타낼 배열을 선언한다.</p></li><li><p>인접한 같은 색깔의 점인 경우 dfs를 수행한다.</p><ul><li>이때, 사이클을 이루는지 여부를 확인하는 방법은 다음과 같다.<ul><li>cnt변수를 탐색을 진행할 때마다 1씩 증가시킨다.</li><li>처음 방문하게 되는 점의 dist배열에 현재 cnt를 저장한다.</li><li>재귀를 수행할 때 이미 방문했던 노드이며, cnt - dist[x][y] &gt;= 4 인 경우 사이클이 형성된다.</li></ul></li></ul></li><li><p>사이클이 형성되지 않는 경우</p></li></ul><p><img src="https://kyu9341.github.io/img/cycle2.png" alt="cycle"></p><ul><li>사이클이 형성되는 경우</li></ul><p><img src="https://kyu9341.github.io/img/cycle1.png" alt="cycle"></p><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> color[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">// 시작점부터 이동한 거리</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 게임판의 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check[x][y]) <span class="comment">// 이미 방문했던 노드인데</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt - dist[x][y] &gt;= <span class="number">4</span>) <span class="comment">// 이동 횟수에서 현재 위치에 저장된 시작점과의 거리 차가 4 이상 = 싸이클</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line">dist[x][y] = cnt; <span class="comment">// 현재 x,y가 시작점에서 몇번 이동했는지 저장, 시작점은 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (color[nx][ny] == color[x][y]) <span class="comment">// 같은 색깔의 점인 경우(방문여부는 관계x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(nx, ny, cnt + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">color[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"No"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>))</span><br><span class="line">ans = <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16929&quot;&gt;&lt;a href=&quot;#Problem-16929&quot; class=&quot;headerlink&quot; title=&quot;Problem 16929&quot;&gt;&lt;/a&gt;Problem 16929&lt;/h1&gt;&lt;h2 id=&quot;Two-Dots&quot;&gt;&lt;a href=&quot;#T
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1707번 이분 그래프</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/</id>
    <published>2020-02-15T11:05:15.000Z</published>
    <updated>2020-02-16T04:44:13.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1707"><a href="#Problem-1707" class="headerlink" title="Problem 1707"></a>Problem 1707</h1><h2 id="이분-그래프"><a href="#이분-그래프" class="headerlink" title="이분 그래프"></a>이분 그래프</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.</p><p>그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V(1≤V≤20,000)와 간선의 개수 E(1≤E≤200,000)가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호가 빈 칸을 사이에 두고 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1707" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1707</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2<br>3 2<br>1 3<br>2 3<br>4 4<br>1 2<br>2 3<br>3 4<br>4 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>YES<br>NO</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그래프를 다음과 같이 A와 B로 나눌 수 있으면 <strong>이분 그래프</strong> 라고 한다.</li></ul><p><img src="https://kyu9341.github.io/img/bipartite_graph.png" alt="bipartite_graph"></p><ul><li>A에 포함된 정점끼리 연결된 간선이 없음</li><li>B에 포함된 정점끼리 연결된 간선이 없음</li><li>모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에</li></ul><hr><ul><li><p>check배열을 bool타입 대신 int형으로 선언하여 방문하지 않은 노드는 0, 방문한 노드인데 1번 그룹이라면 1, 2번 그룹이라면 2로 저장한다.</p><ul><li>(dfs or bfs)를 통해 탐색을 수행하며 다음 노드로 넘어가면 그룹을 바꿔서 지정해준다. 이때 다음에 방문한 노드가 같은 그룹에 속한 노드라면 이분 그래프가 아니다.</li></ul></li><li><p>(dfs or bfs)에서 다음 노드가 방문하지 않은 노드라면 다음 노드로 재귀 호출하며 현재 1번 그룹이라면 다음은 2번을 넘겨주고 현재 2번이라면 1번을 넘겨준다.</p></li><li><p>다음 노드가 방문을 했던 노드인데 현재 노드와 같은 그룹이라면 이분 그래프가 아니다.</p></li><li><p>각 테스트케이스를 시작할 때마다 인접 노드와 방문 내역을 초기화 해야한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">20001</span>];</span><br><span class="line"><span class="keyword">int</span> check[<span class="number">20001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 0 : 방문 x, 1 : 1번 그룹에 포함, 2 : 2번 그룹에 포함</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c)</span> <span class="comment">// c : 다음 방문할 노드의 그룹 ( 1 or 2 ) , 이분그래프이면 true, 아니면 false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = c; <span class="comment">// c 그룹 방문 처리</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i]; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (!check[next]) <span class="comment">// 다음 정점을 방문 안했으면 동작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dfs(next, <span class="number">3</span> - c)) <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// false를 리턴받았으면 false리턴</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[next] == check[node]) <span class="comment">// 다음 정점이 이미 방문했던 정점인데 현재 정점과 같은 그룹이면 이분그래프가 아님</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">check[start] = c; <span class="comment">// 그룹 지정</span></span><br><span class="line">q.push(start); <span class="comment">// 첫 노드 push</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">3</span> - check[node];</span><br><span class="line">check[next] = c; <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1로 방문 처리</span></span><br><span class="line">q.push(next); <span class="comment">// 방문처리하며 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[node] == check[next])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].<span class="built_in">clear</span>(); <span class="comment">// 인접 노드 초기화</span></span><br><span class="line">check[i] = <span class="number">0</span>; <span class="comment">// 방문 내역 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">a[n].push_back(m);</span><br><span class="line">a[m].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) <span class="comment">// 모든 정점을 확인하여 이분 그래프가 아닌 경우가 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="number">0</span>) <span class="comment">// 아직 방문 안한 노드에 대해서 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bfs(i, <span class="number">1</span>) == <span class="literal">false</span>) <span class="comment">// dfs(i, 1) 도 가능</span></span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1707&quot;&gt;&lt;a href=&quot;#Problem-1707&quot; class=&quot;headerlink&quot; title=&quot;Problem 1707&quot;&gt;&lt;/a&gt;Problem 1707&lt;/h1&gt;&lt;h2 id=&quot;이분-그래프&quot;&gt;&lt;a href=&quot;#이분-그래프&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14002번 가장 긴 증가하는 부분 수열 4 (LIS)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/</id>
    <published>2020-02-14T01:32:18.000Z</published>
    <updated>2020-02-24T13:13:11.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14002"><a href="#Problem-14002" class="headerlink" title="Problem 14002"></a>Problem 14002</h1><h2 id="가장-긴-증가하는-부분-수열-4-LIS"><a href="#가장-긴-증가하는-부분-수열-4-LIS" class="headerlink" title="가장 긴 증가하는 부분 수열 4 (LIS)"></a>가장 긴 증가하는 부분 수열 4 (LIS)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p><p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p><p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p><p>둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14002" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14002</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6<br>10 20 10 30 20 50</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = a[1], … a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</li><li>i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i] = d[j] + 1</li></ul><table><thead><tr><th align="center"><strong>i</strong></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th></tr></thead><tbody><tr><td align="center"><strong>a[i]</strong></td><td align="center">10</td><td align="center">20</td><td align="center">10</td><td align="center">30</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center"><strong>d[i]</strong></td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">2</td><td align="center">4</td></tr><tr><td align="center"><strong>v[i]</strong></td><td align="center">-1</td><td align="center">1</td><td align="center">-1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table><ul><li>모든 d[i] 중 최댓값을 구한다.</li><li>이 문제에서는 LIS의 길이 뿐 아니라 LIS의 원소까지 출력을 해야한다.</li><li>이전 LIS문제와 같은 방식으로 푸는데, 역추적을 위한 배열을 만들어 LIS에 연결되는 인덱스를 저장한다.<ul><li>즉, d의 값이 어느 인덱스에 의해 변하는지를 저장한 후 역추적을 통해 출력하는 방식이다.</li><li>또한 p라는 변수에 LIS의 마지막 인덱스를 넣는다. 즉, 최댓값을 가지는 인덱스에서 역추적을 시작한다.</li><li>역추적을 재귀함수를 통해 구현하였지만 스택을 사용하거나 그냥 v에 저장된 인덱스로 a[v[i]]와 같은 배열을 만들어 오름차순 정렬하여 출력해도 무방하다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// LIS 문제</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1001</span>]; <span class="comment">// 역추적을 위한 배열</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>]; <span class="comment">// d[i] = a[1], ... a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 수열의 크기</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 수열 입력</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>; <span class="comment">// 역추적을 시작할 인덱스</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = <span class="number">1</span>; <span class="comment">// 모든 d[i]의 초기값은 1</span></span><br><span class="line">v[i] = <span class="number">-1</span>; <span class="comment">// 초기값은 -1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;<span class="comment">// 수열의 마지막 항이 더 크면서</span></span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; d[j] + <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) <span class="comment">// i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i]</span></span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">v[i] = j; <span class="comment">// 연결되는 인덱스를 저장 / 즉, d의 값이 어느 인덱스에 의해 변하는지 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; d[i]) <span class="comment">// 모든 d[i] 중 최댓값이 정답</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">p = i; <span class="comment">// 최댓값을 가지는 인덱스에서 역추적 시작</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">go(p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// 역추적 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">go(v[p]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[p] &lt;&lt; <span class="string">' '</span>; <span class="comment">// 역순으로 a값 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14002&quot;&gt;&lt;a href=&quot;#Problem-14002&quot; class=&quot;headerlink&quot; title=&quot;Problem 14002&quot;&gt;&lt;/a&gt;Problem 14002&lt;/h1&gt;&lt;h2 id=&quot;가장-긴-증가하는-부분-수열-4-LIS
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11053번 가장 긴 증가하는 부분 수열(LIS)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/13/algorithm11053/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/13/algorithm11053/</id>
    <published>2020-02-13T01:32:18.000Z</published>
    <updated>2020-02-24T13:13:30.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11053"><a href="#Problem-11053" class="headerlink" title="Problem 11053"></a>Problem 11053</h1><h2 id="가장-긴-증가하는-부분-수열-LIS"><a href="#가장-긴-증가하는-부분-수열-LIS" class="headerlink" title="가장 긴 증가하는 부분 수열(LIS)"></a>가장 긴 증가하는 부분 수열(LIS)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p><p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p><p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11053" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11053</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6<br>10 20 10 30 20 50</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = a[1], … a[i] 까지 있을 때, a[i]를 가장 마지막 수로 하는 LIS의 길이</li><li>i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i] = d[j] + 1</li></ul><table><thead><tr><th align="center"><strong>i</strong></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th></tr></thead><tbody><tr><td align="center"><strong>a[i]</strong></td><td align="center">10</td><td align="center">20</td><td align="center">10</td><td align="center">30</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center"><strong>d[i]</strong></td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">2</td><td align="center">4</td></tr></tbody></table><ul><li>모든 d[i] 중 최댓값을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// LIS 문제</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>]; <span class="comment">// d[i] = a[1], ... a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 수열의 크기</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 수열 입력</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 초기값 지정 수열의 크기가 1이면 LIS는 1</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = <span class="number">1</span>; <span class="comment">// 모든 d[i]의 초기값은 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;<span class="comment">// 수열의 마지막 항이 더 크면서</span></span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; d[j] + <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) <span class="comment">// i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i]</span></span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; d[i]) <span class="comment">// 모든 d[i] 중 최댓값이 정답</span></span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11053&quot;&gt;&lt;a href=&quot;#Problem-11053&quot; class=&quot;headerlink&quot; title=&quot;Problem 11053&quot;&gt;&lt;/a&gt;Problem 11053&lt;/h1&gt;&lt;h2 id=&quot;가장-긴-증가하는-부분-수열-LIS&quot;&gt;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2193번 이친수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/11/algorithm2193/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/11/algorithm2193/</id>
    <published>2020-02-11T11:32:18.000Z</published>
    <updated>2020-02-24T12:58:03.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2193"><a href="#Problem-2193" class="headerlink" title="Problem 2193"></a>Problem 2193</h1><h2 id="이친수"><a href="#이친수" class="headerlink" title="이친수"></a>이친수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.</p><ol><li>이친수는 0으로 시작하지 않는다.</li><li>이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.</li></ol><p>예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.</p><p>N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 N자리 이친수의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2193" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2193</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[i][j] = 이전 수가 j인 i자리 이친수의 개수</li><li>d[i-1][0]의 뒤에 올 수 있는 수는 0, 1 /  d[i-1][1]뒤에 올 수 있는 수는 0뿐<ul><li>d[i][0] = d[i - 1][0] + d[i - 1][1]</li><li>d[i][1] = d[i - 1][0]</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">91</span>][<span class="number">2</span>]; <span class="comment">// d[i][j] = 이전 수가 j인 i자리 이친수의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 0으로 시작하는 수는 이친수가 아님</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">0</span>] = d[i - <span class="number">1</span>][<span class="number">0</span>] + d[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">d[i][<span class="number">1</span>] = d[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n][<span class="number">0</span>] + d[n][<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2193&quot;&gt;&lt;a href=&quot;#Problem-2193&quot; class=&quot;headerlink&quot; title=&quot;Problem 2193&quot;&gt;&lt;/a&gt;Problem 2193&lt;/h1&gt;&lt;h2 id=&quot;이친수&quot;&gt;&lt;a href=&quot;#이친수&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 10844번 1, 2, 3 쉬운 계단 수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/11/algorithm10844/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/11/algorithm10844/</id>
    <published>2020-02-11T01:32:18.000Z</published>
    <updated>2020-02-24T12:57:19.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-10844"><a href="#Problem-10844" class="headerlink" title="Problem 10844"></a>Problem 10844</h1><h2 id="쉬운-계단-수"><a href="#쉬운-계단-수" class="headerlink" title="쉬운 계단 수"></a>쉬운 계단 수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>45656이란 수를 보자.</p><p>이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.</p><p>세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.</p><p>N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/10844" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/10844</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>9</p><h3 id="solve-first"><a href="#solve-first" class="headerlink" title="solve first"></a>solve first</h3><ul><li><p>점화식 d[i][j] = 길이가 i인 계단 수의 총 개수, 이전 수의 맨 마지막 수 = j</p></li><li><p>(i != 1) =&gt; (0 &lt;= j &lt;= 9)  -&gt; i = 1일때 예외처리</p></li><li><p>j = 0 or j = 9 이면 다음에 올 수 있는 수는 1, 8 뿐</p></li><li><p>1 ~ 8은 j + 1, j - 1이 올 수 있음</p><ul><li>ex) d[2][1] = sum(d[2 - 1][j])</li><li>ex) d[2][2] = sum(d[2 - 1][j]) * 2</li></ul></li><li><p>첫 번째 코드</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000000</span>;</span><br><span class="line"><span class="comment">// 점화식 d[i][j] = 길이가 i인 계단 수의 총 개수, 이전 수의 맨 마지막 수 = j</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">101</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">d[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || j == <span class="number">9</span>) <span class="comment">// 0 또는 9인 경우에는 다음에 올 수 있는 수는 1, 8뿐이므로 한번만 더해줌</span></span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 1 ~ 8의 수 다음에는 j - 1, j + 1이 올 수 있으므로 두 배로 더해줌</span></span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> d[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">result += d[n][j];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solve-second"><a href="#solve-second" class="headerlink" title="solve second"></a>solve second</h3></li><li><p>위와 같이 하니 예제 입출력의 테스트케이스는 맞지만 틀렸다고 나옴.</p></li><li><p>생각해보니 단순히 j가 0이나 9일 때에 한 번만 더하고 두 번만 더하는 것이 잘못되었음</p><ul><li>정확히 0일때는 이전 수가 1인 경우 즉, d[i-1][j+1]인 경우를 더해줘야 하고</li><li>9일때는 이전 수가 8 인 경우 즉, d[i-1][j-1]인 경우를 더해주어야 한다.</li><li>또한 j가 1 ~ 8 인 경우에는 d[i-1][j-1]과 d[i-1][j+1] 모두를 더해주어야 한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000000</span>;</span><br><span class="line"><span class="comment">// 점화식 d[i][j] = 길이가 i인 계단 수의 총 개수, 이전 수의 맨 마지막 수 = j</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">101</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">d[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// d[i][j] = 0;</span></span><br><span class="line"><span class="keyword">if</span> (j &lt;= <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> d[i][j] %= mod; <span class="comment">// 미리 나머지로 바꿔주어야 정수 범위내에서 연산 가능</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) <span class="comment">// n의 모든 경우를 누적</span></span><br><span class="line">result += d[n][j];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-10844&quot;&gt;&lt;a href=&quot;#Problem-10844&quot; class=&quot;headerlink&quot; title=&quot;Problem 10844&quot;&gt;&lt;/a&gt;Problem 10844&lt;/h1&gt;&lt;h2 id=&quot;쉬운-계단-수&quot;&gt;&lt;a href=&quot;#쉬운
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 15990번 1, 2, 3 더하기 5</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/10/algorithm15990/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/10/algorithm15990/</id>
    <published>2020-02-10T01:32:18.000Z</published>
    <updated>2020-02-24T12:56:42.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-15990"><a href="#Problem-15990" class="headerlink" title="Problem 15990"></a>Problem 15990</h1><h2 id="1-2-3-더하기-5"><a href="#1-2-3-더하기-5" class="headerlink" title="1, 2, 3 더하기 5"></a>1, 2, 3 더하기 5</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.</p><ul><li>1+2+1</li><li>1+3</li><li>3+1<br>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/15990" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/15990</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>4<br>7<br>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>9<br>27</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>같은 수를 두 번 이상 연속해서 사용하면 안된다.<ul><li>(연속, 증가, 감소) 등의 조건이 나오면 두 개씩 나누어 풀이한다.</li></ul></li><li>d[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j<ul><li>d[i][1] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 1<ul><li>바로 전에 사용할 수 있는 수는 2, 3 =&gt; d[i - 1][2] + d[i - 1][3]</li></ul></li><li>d[i][2] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 2<ul><li>바로 전에 사용할 수 있는 수는 2, 3 =&gt; d[i - 2][1] + d[i - 2][3]</li></ul></li><li>d[i][3] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 3<ul><li>바로 전에 사용할 수 있는 수는 2, 3 =&gt; d[i - 3][1] + d[i - 3][2]</li></ul></li></ul></li><li>d[0] = 1 처럼 d[0][1], d[0][2], d[0][3]을 1로 초기화하면 중복이 발생<ul><li>d[1][1] = d[0][2] + d[0][3] = 2 (1로 끝나는데 1을 만드는 경우는 1뿐)</li><li>예외 처리를 해주어야 함.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">100001</span>][<span class="number">4</span>]; <span class="comment">// d[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000009</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum123_bottom_up(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">1</span>] = d[i - <span class="number">1</span>][<span class="number">2</span>] + d[i - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">d[i][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 1로 끝나는데 1을 만드는 경우는 1뿐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">2</span>] = d[i - <span class="number">2</span>][<span class="number">1</span>] + d[i - <span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">d[i][<span class="number">2</span>] = <span class="number">1</span>;  <span class="comment">// 2로 끝나는데 2을 만드는 경우는 2뿐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">3</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">3</span>] = d[i - <span class="number">3</span>][<span class="number">1</span>] + d[i - <span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">d[i][<span class="number">3</span>] = <span class="number">1</span>; <span class="comment">// 3으로 끝나는데 3을 만드는 경우는 3뿐</span></span><br><span class="line">&#125;</span><br><span class="line">d[i][<span class="number">1</span>] %= mod; <span class="comment">// 정수 범위를 초과하기</span></span><br><span class="line">d[i][<span class="number">2</span>] %= mod;</span><br><span class="line">d[i][<span class="number">3</span>] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (d[n][<span class="number">1</span>] + d[n][<span class="number">2</span>] + d[n][<span class="number">3</span>]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-15990&quot;&gt;&lt;a href=&quot;#Problem-15990&quot; class=&quot;headerlink&quot; title=&quot;Problem 15990&quot;&gt;&lt;/a&gt;Problem 15990&lt;/h1&gt;&lt;h2 id=&quot;1-2-3-더하기-5&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11052번 카드 구매하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/09/algorithm11052/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/09/algorithm11052/</id>
    <published>2020-02-09T10:32:18.000Z</published>
    <updated>2020-02-24T12:49:15.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11052"><a href="#Problem-11052" class="headerlink" title="Problem 11052"></a>Problem 11052</h1><h2 id="카드-구매하기"><a href="#카드-구매하기" class="headerlink" title="카드 구매하기"></a>카드 구매하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.</p><p>PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 아이디와 얼굴이 적혀있는 카드이다. 각각의 카드에는 등급을 나타내는 색이 칠해져 있고, 다음과 같이 8가지가 있다.</p><ul><li>전설카드</li><li>레드카드</li><li>오렌지카드</li><li>퍼플카드</li><li>블루카드</li><li>청록카드</li><li>그린카드</li><li>그레이카드</li></ul><p>카드는 카드팩의 형태로만 구매할 수 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, … 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재한다.</p><p>민규는 카드의 개수가 적은 팩이더라도 가격이 비싸면 높은 등급의 카드가 많이 들어있을 것이라는 미신을 믿고 있다. 따라서, 민규는 돈을 최대한 많이 지불해서 카드 N개 구매하려고 한다. 카드가 i개 포함된 카드팩의 가격은 Pi원이다.</p><p>예를 들어, 카드팩이 총 4가지 종류가 있고, P1 = 1, P2 = 5, P3 = 6, P4 = 7인 경우에 민규가 카드 4개를 갖기 위해 지불해야 하는 금액의 최댓값은 10원이다. 2개 들어있는 카드팩을 2번 사면 된다.</p><p>P1 = 5, P2 = 2, P3 = 8, P4 = 10인 경우에는 카드가 1개 들어있는 카드팩을 4번 사면 20원이고, 이 경우가 민규가 지불해야 하는 금액의 최댓값이다.</p><p>마지막으로, P1 = 3, P2 = 5, P3 = 15, P4 = 16인 경우에는 3개 들어있는 카드팩과 1개 들어있는 카드팩을 구매해 18원을 지불하는 것이 최댓값이다.</p><p>카드 팩의 가격이 주어졌을 때, N개의 카드를 구매하기 위해 민규가 지불해야 하는 금액의 최댓값을 구하는 프로그램을 작성하시오. N개보다 많은 개수의 카드를 산 다음, 나머지 카드를 버려서 N개를 만드는 것은 불가능하다. 즉, 구매한 카드팩에 포함되어 있는 카드 개수의 합은 N과 같아야 한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)</p><p>둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11052" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11052</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>1 5 6 7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>10</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>5<br>10 9 8 7 6</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>50</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>10<br>1 1 2 3 5 8 13 21 34 55</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>55</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>10<br>5 10 11 12 13 30 35 40 45 47</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>50</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[n] = 카드 n개를 갖기 위해 지불하는 금액의 최댓값</li><li>카드팩 + 카드팩 + 카드팩 + … + <strong>카드팩</strong> = n  –&gt; <strong>카드팩</strong> 은 카드가 몇개? 알수없음 (i개)<ul><li>카드팩 + 카드팩 + 카드팩 + … + -&gt; n - i 개</li><li>d[n - i] + p[i]</li></ul></li><li>즉, d[n] = max(d[n - i] + p[i]) (1 &lt;= i &lt;= n)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i]; <span class="comment">// Pi 입력</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// d[n] = max(d[n - i] + p[i]) (1 &lt;= i &lt;= n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = d[i - j] + p[j];</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; temp)</span><br><span class="line">d[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11052&quot;&gt;&lt;a href=&quot;#Problem-11052&quot; class=&quot;headerlink&quot; title=&quot;Problem 11052&quot;&gt;&lt;/a&gt;Problem 11052&lt;/h1&gt;&lt;h2 id=&quot;카드-구매하기&quot;&gt;&lt;a href=&quot;#카드
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 9095번 1, 2, 3 더하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/09/algorithm9095/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/09/algorithm9095/</id>
    <published>2020-02-09T06:32:18.000Z</published>
    <updated>2020-02-24T12:53:44.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-9095"><a href="#Problem-9095" class="headerlink" title="Problem 9095"></a>Problem 9095</h1><h2 id="1-2-3-더하기"><a href="#1-2-3-더하기" class="headerlink" title="1, 2, 3 더하기"></a>1, 2, 3 더하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.</p><ul><li>1+1+1+1</li><li>1+1+2</li><li>1+2+1</li><li>2+1+1</li><li>2+2</li><li>1+3</li><li>3+1</li></ul><p>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/9095" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/9095</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>4<br>7<br>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>7<br>44<br>274</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[n] = n을 1, 2, 3의 합으로 나타내는 방법의 수</li><li>o + o + o + … + <strong>o</strong> = n  –&gt; <strong>o</strong> 의 자리에 올 수 있는 수 : 1, 2, 3<ul><li>[  합 : n - 1    ] + 1 = n;</li><li>[  합 : n - 2    ] + 2 = n;</li><li>[  합 : n - 3    ] + 3 = n;</li></ul></li><li>d[n] = d[n - 1] + d[n - 2] + d[n - 3]<ul><li>d[0] = 1 // 공집합, 모든 숫자를 0개씩 사용하는 경우 1</li><li>d[1] = 1 // 1</li><li>d[2] = 2 // 1+1, 2</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ul><li><p>동적 계획법</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">11</span>]; <span class="comment">// n &lt; 11, d[n] = n을 1, 2, 3의 합으로 나타내는 방법의 수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t; <span class="comment">// testcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum123_top_down(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="comment">// d[0] = 1(공집합, 모든 숫자를 0개씩 사용), d[1] = 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="comment">// 1 + 1, 2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 메모되어있으면 리턴</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// d[n] = d[n - 1] + d[n - 2] + d[n - 3]</span></span><br><span class="line">d[n] = sum123_top_down(n - <span class="number">1</span>) + sum123_top_down(n - <span class="number">2</span>) + sum123_top_down(n - <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] + d[i - <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>부르트 포스(재귀)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; goal) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 1, 2, 3으로 원하는 수를 만들 수 없는 경우</span></span><br><span class="line"><span class="keyword">if</span> (sum == goal) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 만든 경우</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">count += go(sum + i, goal);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(<span class="number">0</span>, n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-9095&quot;&gt;&lt;a href=&quot;#Problem-9095&quot; class=&quot;headerlink&quot; title=&quot;Problem 9095&quot;&gt;&lt;/a&gt;Problem 9095&lt;/h1&gt;&lt;h2 id=&quot;1-2-3-더하기&quot;&gt;&lt;a href=&quot;#1-2-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11727번 2xn 타일링 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11727/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11727/</id>
    <published>2020-02-08T11:32:18.000Z</published>
    <updated>2020-02-24T12:49:29.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11727"><a href="#Problem-11727" class="headerlink" title="Problem 11727"></a>Problem 11727</h1><h2 id="2xn타일링2"><a href="#2xn타일링2" class="headerlink" title="2xn타일링2"></a>2xn타일링2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 직사각형을 1x2와 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11727" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11727</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>8</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>171</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>12</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>2731</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>2xn타일링 문제와 동일하게 진행되지만 2x2타일이 따로 존재한다는 점에서 다음과 같이 진행한다.</li><li>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수<ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li><li><ol start="3"><li>2x2 타일을 하나 붙인다.</li></ol></li></ul></li><li>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수 * 2</li><li>d[n] = d[n - 1] + d[n - 2] * 2</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 2×n 직사각형을 1x2와 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling_top_down(n) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2xn 타일링 문제에서 d[n - 2]인 경우가 두배가 된 것.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] * <span class="number">2</span>; <span class="comment">// d[n] = d[n - 1] + d[n - 2]\*2</span></span><br><span class="line">d[i] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling_top_down(n - <span class="number">1</span>) + tiling_top_down(n - <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">d[n] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11727&quot;&gt;&lt;a href=&quot;#Problem-11727&quot; class=&quot;headerlink&quot; title=&quot;Problem 11727&quot;&gt;&lt;/a&gt;Problem 11727&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링2&quot;&gt;&lt;a href=&quot;#2x
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11726번 2xn타일링</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/</id>
    <published>2020-02-08T06:45:13.000Z</published>
    <updated>2020-02-17T15:35:03.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11726"><a href="#Problem-11726" class="headerlink" title="Problem 11726"></a>Problem 11726</h1><h2 id="2xn타일링"><a href="#2xn타일링" class="headerlink" title="2xn타일링"></a>2xn타일링</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><p>아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11726" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11726</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>9</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>55</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>먼저 메모이제이션 할 배열 d[]를 선언한다.</p></li><li><p>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</p><ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li></ul></li><li><p>즉, 2xn 크기의 직사각형을 채우는 방법의 수는</p></li><li><p>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수</p></li><li><p>d[n] = d[n - 1] + d[n - 2]</p></li><li><p>피보나치 수열과 같은 형태로 점화식이 만들어진다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="comment">// n이 d[1] = 1, d[2] = 2이므로</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 구한 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling(n - <span class="number">1</span>) + tiling(n - <span class="number">2</span>); <span class="comment">// d[n] = d[n - 1] + d[n - 2]</span></span><br><span class="line">d[n] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>];</span><br><span class="line">d[i] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11726&quot;&gt;&lt;a href=&quot;#Problem-11726&quot; class=&quot;headerlink&quot; title=&quot;Problem 11726&quot;&gt;&lt;/a&gt;Problem 11726&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링&quot;&gt;&lt;a href=&quot;#2xn
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1676번 팩토리얼 0의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1676/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1676/</id>
    <published>2020-02-08T06:32:18.000Z</published>
    <updated>2020-02-24T12:38:32.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1676"><a href="#Problem-1676" class="headerlink" title="Problem 1676"></a>Problem 1676</h1><h2 id="팩토리얼-0의-개수"><a href="#팩토리얼-0의-개수" class="headerlink" title="팩토리얼 0의 개수"></a>팩토리얼 0의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 구한 0의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1676" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1676</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.<ul><li>(뒤에서부터 연속으로 등장하는 0의 개수이므로)</li></ul></li><li>n!에서는 2의 개수가 항상 5의 개수보다 많으므로 5의 개수만 세어준다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.</span></span><br><span class="line"><span class="comment">// n!에서는 2의 개수가 항상 5의 개수보다 많으므로 5의 개수만 세어준다.</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = i;</span><br><span class="line"><span class="keyword">while</span> (tmp % <span class="number">5</span> == <span class="number">0</span>) <span class="comment">// 5의 개수 count</span></span><br><span class="line">&#123;</span><br><span class="line">tmp /= <span class="number">5</span>; <span class="comment">// 5를 하나 이상 인자로 가지는 수 처리</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1676&quot;&gt;&lt;a href=&quot;#Problem-1676&quot; class=&quot;headerlink&quot; title=&quot;Problem 1676&quot;&gt;&lt;/a&gt;Problem 1676&lt;/h1&gt;&lt;h2 id=&quot;팩토리얼-0의-개수&quot;&gt;&lt;a href=&quot;#팩토리
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1463번 1로 만들기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/</id>
    <published>2020-02-08T05:30:51.000Z</published>
    <updated>2020-02-17T15:24:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1463"><a href="#Problem-1463" class="headerlink" title="Problem 1463"></a>Problem 1463</h1><h2 id="1로-만들기"><a href="#1로-만들기" class="headerlink" title="1로 만들기"></a>1로 만들기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p><ol><li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li><li>X가 2로 나누어 떨어지면, 2로 나눈다.</li><li>1을 뺀다.</li></ol><p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1463" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1463</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>10</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>먼저 메모이제이션 할 배열 d[]를 선언한다.</li><li>점화식 d[n] = n을 1로 만드는 최소 연산 횟수 를 정의한다.<ul><li>[n을 n / 3으로 만드는 연산 횟수 : 1번], [n/3을 1로 만드는 연산 횟수 : d[n / 3]번]  //  1번 + d[n / 3]번</li><li>n -&gt; [n / 2] -&gt; 1  //  1번 + d[n / 2]번</li><li>n -&gt; [n - 1] -&gt; 1  //  1번 + d[n - 1]번</li><li>=&gt; d[n] = min(d[n / 3], d[n / 2], d[n - 1]) + 1</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000001</span>]; <span class="comment">// d[n] : n을 1로 만드는 최소 연산 횟수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식 구현</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 1을 만든 경우 d[1] = 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 수행했던 연산인 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n]; <span class="comment">// 메모이제이션</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = go(n - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 최솟값을 더 편하게 구하기 위해 먼저 처리</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 2로 나누어 떨어지는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp; <span class="comment">// 새로운 방식이 더 적은 연산을 필요로 하면 바꿔줌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 초기값 지정</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">3</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1463&quot;&gt;&lt;a href=&quot;#Problem-1463&quot; class=&quot;headerlink&quot; title=&quot;Problem 1463&quot;&gt;&lt;/a&gt;Problem 1463&lt;/h1&gt;&lt;h2 id=&quot;1로-만들기&quot;&gt;&lt;a href=&quot;#1로-만들기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2004번 조합 0의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm2004/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm2004/</id>
    <published>2020-02-08T01:32:18.000Z</published>
    <updated>2020-02-24T12:39:35.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2004"><a href="#Problem-2004" class="headerlink" title="Problem 2004"></a>Problem 2004</h1><h2 id="조합-0의-개수"><a href="#조합-0의-개수" class="headerlink" title="조합 0의 개수"></a>조합 0의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>nCm의 끝자리 0의 개수를 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정수 n, m(0≤m≤n≤2,000,000,000, n!=0)이 들어온다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 0의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2004" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2004</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>25 12</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.<ul><li>(뒤에서부터 연속으로 등장하는 0의 개수이므로)</li></ul></li><li>nCm = n! / (n-m)!*m!</li><li>조합의 0의 개수는 n!의 0의 개수에서 (n-m)!의 0의 개수와 m!의 0의 개수를 빼주면 된다.</li><li>조합의 0의 개수는 항상 5의 개수가 더 많지 않을 수 있으므로 2와 5의 개수 중 더 작은 값을 구하면 된다.</li><li>범위가 매우 크기 때문에 int형이 아닌 long long 형을 사용한다. (int형 사용시 런타임에러)</li><li>이때 2와 5의 개수를 구하는 방법은 팩토리얼의 0의 개수를 구할 때와는 다르게 구한다.<ul><li>최대 2,000,000,000의 수가 들어오기 때문에 시간 초과가 발생할 수 있음</li><li>n!의 i의 개수를 구한다고 한다면</li><li>먼저 count에 n / i를 더한다.</li><li>n을 i로 나누어도 i^2의 배수들은 i가 남아있기 때문에 count에 n / i^2 을 더한다.</li><li>i^3의 배수같은 경우는 i^2으로 나누어도 i가 남아있기 때문에 count에 n / i^3을 더한다.</li><li>위의 과정을 반복한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; zeros(<span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> five = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">5</span>; i &lt;= n; i *= <span class="number">5</span>) <span class="comment">// 5의 개수 카운트</span></span><br><span class="line">five += n / i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; i *= <span class="number">2</span>) <span class="comment">// 2의 개수 카운트</span></span><br><span class="line">two += n / i;</span><br><span class="line"><span class="keyword">return</span> &#123;two, five&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; resM, resN, resNM;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>, five = <span class="number">0</span>;</span><br><span class="line">resM = zeros(m);</span><br><span class="line">resN = zeros(n);</span><br><span class="line">resNM = zeros(n - m);</span><br><span class="line"></span><br><span class="line">two = resN.first - resM.first - resNM.first; <span class="comment">// n의 2의 개수에서 m과 (n-m)의 2의 개수를 빼줌</span></span><br><span class="line">five = resN.second - resM.second - resNM.second;  <span class="comment">// n의 5의 개수에서 m과 (n-m)의 5의 개수를 빼줌</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(two, five) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2004&quot;&gt;&lt;a href=&quot;#Problem-2004&quot; class=&quot;headerlink&quot; title=&quot;Problem 2004&quot;&gt;&lt;/a&gt;Problem 2004&lt;/h1&gt;&lt;h2 id=&quot;조합-0의-개수&quot;&gt;&lt;a href=&quot;#조합-0의
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17087번 숨박꼭질 6</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm17087/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm17087/</id>
    <published>2020-02-07T11:32:18.000Z</published>
    <updated>2020-02-24T12:41:17.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17087"><a href="#Problem-17087" class="headerlink" title="Problem 17087"></a>Problem 17087</h1><h2 id="숨박꼭질-6"><a href="#숨박꼭질-6" class="headerlink" title="숨박꼭질 6"></a>숨박꼭질 6</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, …, AN에 있다.</p><p>수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.</p><p>모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>가능한 D값의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17087" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17087</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 7 11</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 81<br>33 105 57</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>24</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>1 1<br>1000000000</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>999999999</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>수빈이의 위치와 동생의 위치를 모두 하나의 벡터에 오름차순으로 담는다.</li><li>이후 벡터의 인덱스를 i라고 하면 모든 v[i+1] - v[i] 의 최대공약수를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> <span class="comment">// 유클리드 호제법 (최대공약수)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, s; <span class="comment">// n : 동생 수, s : 수빈이의 위치</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v(n); <span class="comment">// 수빈이의 위치와 동생의 위치를 담을 벡터</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">v.push_back(s); <span class="comment">// 수빈이의 위치 추가</span></span><br><span class="line"></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 오름차순 정렬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = v[<span class="number">1</span>] - v[<span class="number">0</span>]; <span class="comment">// 초기값 설정</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, j = i + <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); i++, j++)</span><br><span class="line">&#123;</span><br><span class="line">res = gcd(res, v[j] - v[i]); <span class="comment">// 다음 원소와의 차이의 최대공약수(모든 차이 값의 최대공약수)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17087&quot;&gt;&lt;a href=&quot;#Problem-17087&quot; class=&quot;headerlink&quot; title=&quot;Problem 17087&quot;&gt;&lt;/a&gt;Problem 17087&lt;/h1&gt;&lt;h2 id=&quot;숨박꼭질-6&quot;&gt;&lt;a href=&quot;#숨박꼭
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1929번 소수 구하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm1929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm1929/</id>
    <published>2020-02-07T10:32:18.000Z</published>
    <updated>2020-02-24T12:35:40.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1929"><a href="#Problem-1929" class="headerlink" title="Problem 1929"></a>Problem 1929</h1><h2 id="소수-구하기"><a href="#소수-구하기" class="headerlink" title="소수 구하기"></a>소수 구하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>계산 결과를 소숫점 둘째 자리까지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 16</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>5<br>7<br>11<br>13</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>에라토스테네스의 체<ul><li>2부터 n까지의 모든 수를 써놓는다.</li><li>아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.</li><li>그 수는 소수이다.</li><li>이제 그 수의 배수를 모두 지운다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">1000001</span>] = &#123; <span class="literal">false</span> &#125;; <span class="comment">// 각 숫자의 소수 여부를 체크할 bool배열</span></span><br><span class="line"><span class="keyword">int</span> m, n; <span class="comment">// 소수 범위 (1 ≤ M ≤ N ≤ 1,000,000)</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">check[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 1은 소수가 아님</span></span><br><span class="line"><span class="comment">//  에라토스테네스의 체</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++) <span class="comment">// i^2이 n을 넘어가면 i의 배수는 이미 모두 지워짐</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!check[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j*i &lt;= n; j++) <span class="comment">// i*i이상의 i의 배수를 모두 지워줌</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i * j &gt; <span class="number">1000000</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">check[i * j] = <span class="literal">true</span>; <span class="comment">// 소수가 아니면 true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[i])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1929&quot;&gt;&lt;a href=&quot;#Problem-1929&quot; class=&quot;headerlink&quot; title=&quot;Problem 1929&quot;&gt;&lt;/a&gt;Problem 1929&lt;/h1&gt;&lt;h2 id=&quot;소수-구하기&quot;&gt;&lt;a href=&quot;#소수-구하기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17103번 골드바흐 파티션</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm17103/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm17103/</id>
    <published>2020-02-07T06:32:18.000Z</published>
    <updated>2020-02-24T12:44:30.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17103"><a href="#Problem-17103" class="headerlink" title="Problem 17103"></a>Problem 17103</h1><h2 id="골드바흐-파티션"><a href="#골드바흐-파티션" class="headerlink" title="골드바흐 파티션"></a>골드바흐 파티션</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><ul><li>골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.</li></ul><p>짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 &lt; N ≤ 1,000,000을 만족한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17103" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17103</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>6<br>8<br>10<br>12<br>100</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1<br>1<br>2<br>1<br>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>전체 범위의 소수들을 모두 구한다.(에라토스테네스의 체 이용)</li><li>이후 n - b = a 가 소수인 경우. 즉, 골드바흐의 추측을 만족하는 경우에 n = a + b 를 출력</li></ul><hr><ul><li>위와 같이 골드바흐의 추측 문제와 같은 방식으로 접근하여 파티션의 개수만 출력한다.<ul><li>이때 중복을 제거해야 하므로 count를 2로 나눈 몫을 출력하는데,</li><li>6 = 3 + 3, 10 = 5 + 5 와 같은 경우 중복이 발생하지 않는 한 쌍이 존재하므로</li><li>현재 입력받은 수 num을 기준으로 num / 2가 소수라면 count를 2로 나눈 몫에 1을 더하여 중복이 발생하지 않는 경우를 더해주어 출력하고</li><li>아니라면 count를 2로 나누어 중복을 제거 후 출력한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> prime[MAX]; <span class="comment">// 소수를 담을 배열</span></span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// 인덱스가 소수이면 false인 배열</span></span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>; <span class="comment">// 소수의 개수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">check[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 1은 소수가 아님</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX; i++) <span class="comment">// 에라토스테네스의 체</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="literal">false</span>) <span class="comment">// 아직 (소수가 아니라고)판별되지 않았다면</span></span><br><span class="line">&#123;</span><br><span class="line">prime[pn++] = i; <span class="comment">// 소수이면 prime에 저장</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; MAX; j += i) <span class="comment">// i*i로 하면 정수 범위를 벗어날 수 있음</span></span><br><span class="line">&#123;</span><br><span class="line">check[j] = <span class="literal">true</span>; <span class="comment">// 소수의 배수는 모두 제거</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 파티션 수</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; prime[i] &lt; num; i++) <span class="comment">// 소수가 현재 입력 수 보다 작은동안</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[num - prime[i]]) <span class="comment">// n - b = a(소수)라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; num &lt;&lt; " = " &lt;&lt; num - prime[i] &lt;&lt; " + " &lt;&lt; prime[i] &lt;&lt; '\n';</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!check[num / <span class="number">2</span>]) <span class="comment">// num / 2 가 소수라면 - 즉, 6 = 3 + 3 과 같이 중복이 발생하지 않는 파티션이 존재하는 경우</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count / <span class="number">2</span> + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 중복을 제거하고 1을 더함</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count / <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 중복 제거</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17103&quot;&gt;&lt;a href=&quot;#Problem-17103&quot; class=&quot;headerlink&quot; title=&quot;Problem 17103&quot;&gt;&lt;/a&gt;Problem 17103&lt;/h1&gt;&lt;h2 id=&quot;골드바흐-파티션&quot;&gt;&lt;a href=&quot;#골
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17298번 오큰수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm17298/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm17298/</id>
    <published>2020-02-07T02:23:42.000Z</published>
    <updated>2020-02-24T12:33:10.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17298"><a href="#Problem-17298" class="headerlink" title="Problem 17298"></a>Problem 17298</h1><h2 id="오큰수"><a href="#오큰수" class="headerlink" title="오큰수"></a>오큰수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.</p><p>예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, …, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>총 N개의 수 NGE(1), NGE(2), …, NGE(N)을 공백으로 구분해 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17298" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17298</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>3 5 2 7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>5 7 7 -1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4<br>9 5 4 8</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1 8 8 -1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>vector a에 입력받은 수열을 넣고 vector res에는 a의 각 값에 대한 오큰수를 넣는다.</li><li>stack s에는 vector a에서 다음 원소와 비교하여 아직 오큰수를 찾지 못한 수의 인덱스가 쌓인다.</li><li>스택이 비어있다면 현재 인덱스를 먼저 push한다</li><li>이후 비어있지 않고 현재 a의 원소a[i]가 스택의 가장 위에 있는 인덱스를 가지는 원소(a[s.top()])와 비교하여 더 크다면 a[i] 는 a[s.top()]의 오큰수이므로 res[s.top()]에 저장한다. 이후 pop을 수행한다.(반복문 내에서 조건하에 계속 반복)</li><li>오큰수를 아직 확인하지 못한 수(=현재 수열의 원소 because 다음번에 확인 가능하므로)의 인덱스를 push</li><li>위의 과정의 반복이 끝나고 스택에 남아있는 수들은 오큰수를 구하지 못한 수 이므로 -1로 처리</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">현재 수 보다 큰 수면서 오른쪽으로 가장 가까운 수 = 오큰수</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 다음 수가 오큰수가 아닌 수의 인덱스를 담을 스택</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">s.push(<span class="number">0</span>); <span class="comment">// 첫번째 원소 0으로 초기화</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s.empty())</span><br><span class="line">&#123;</span><br><span class="line">s.push(i); <span class="comment">// 스택이 비어있다면 현재 인덱스를 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; a[i] &gt; a[s.top()]) <span class="comment">// 스택이 비어있지 않고 현재 수열의 원소가 아직 오큰수를 구하지 못한 수보다 크면</span></span><br><span class="line">&#123;</span><br><span class="line">res[s.top()] = a[i]; <span class="comment">// a[s.top()]의 오큰수는 a[i]</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">s.push(i); <span class="comment">// 오큰수를 아직 확인하지 못한 수(=현재 수열의 원소 because 다음번에 확인 가능하므로)의 인덱스를 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.empty()) <span class="comment">// 위의 과정이 끝나고 오큰수를 구하지 못한 수들은 -1</span></span><br><span class="line">&#123;</span><br><span class="line">res[s.top()] = <span class="number">-1</span>;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17298&quot;&gt;&lt;a href=&quot;#Problem-17298&quot; class=&quot;headerlink&quot; title=&quot;Problem 17298&quot;&gt;&lt;/a&gt;Problem 17298&lt;/h1&gt;&lt;h2 id=&quot;오큰수&quot;&gt;&lt;a href=&quot;#오큰수&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1935번 후위 표기식 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/06/algorithm1935/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/06/algorithm1935/</id>
    <published>2020-02-06T10:32:18.000Z</published>
    <updated>2020-02-24T12:32:17.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1935"><a href="#Problem-1935" class="headerlink" title="Problem 1935"></a>Problem 1935</h1><h2 id="후위-표기식-2"><a href="#후위-표기식-2" class="headerlink" title="후위 표기식 2"></a>후위 표기식 2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>후위 표기식과 각 피연산자에 대응하는 값들이 주어져 있을 때, 그 식을 계산하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 피연산자의 개수(1 ≤ N ≤ 26) 가 주어진다. 그리고 둘째 줄에는 후위 표기식이 주어진다. (여기서 피연산자는 A~Z의 영대문자이며, A부터 순서대로 N개의 영대문자만이 사용되며, 길이는 100을 넘지 않는다) 그리고 셋째 줄부터 N+2번째 줄까지는 각 피연산자에 대응하는 값이 주어진다. (3번째 줄에는 A에 해당하는 값, 4번째 줄에는 B에 해당하는값 , 5번째 줄에는 C …이 주어진다, 그리고 피연산자에 대응 하는 값은 정수이다)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>계산 결과를 소숫점 둘째 자리까지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1935" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1935</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>ABC*+DE/-<br>1<br>2<br>3<br>4<br>5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6.20</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>1<br>AA+A+<br>1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3.00</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>문자열의 현재 인덱스가 피연산자(영어 대문자)라면 해당 숫자로 변환하여 스택에 push한다.</li><li>연산자인 경우 스택의 가장 위의 두 수를 뽑아 순서를 뒤집어(아래의 숫자가 더 먼저 들어간 수 이므로) 연산 후 다시 push 한다.</li><li>위 과정을 반복 후 스택의 top원소를 소수점 둘째 자리까지만 표기하여 출력</li></ul><h3 id="C-소수점-조정"><a href="#C-소수점-조정" class="headerlink" title="C++ 소수점 조정"></a>C++ 소수점 조정</h3><ul><li>“cout &lt;&lt; fixed”라는 표현은 소숫점 아래 값을 고정하는 표현이다.</li><li>즉, cout &lt;&lt; fixed 이후에 precision(6)을 입력하면 소숫점 아래를 6으로 고정한다.</li><li>precision() -&gt; 자릿수를 조정하는 함수이다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str; <span class="comment">// 입력 문자열</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 피연산자 수</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s; <span class="comment">// 피연산자를 담을 스택</span></span><br><span class="line"><span class="keyword">double</span> alphabet[<span class="number">26</span>]; <span class="comment">// 피연산자에 해당하는 숫자를 저장할 배열</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; alphabet[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">'A'</span> &amp;&amp; str[i] &lt;= <span class="string">'Z'</span>) <span class="comment">// 피연산자일 경우 숫자로 변환하여 스택에 push</span></span><br><span class="line">&#123;</span><br><span class="line">s.push(alphabet[str[i] - <span class="string">'A'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 연산자인 경우 스택의 위의 두 수를 뽑아 순서를 뒤집어 연산 후 다시 push</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> a = s.top();</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">double</span> b = s.top();</span><br><span class="line">s.pop();</span><br><span class="line">s.push(cal(a, b, str[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0.</span>;</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">res = b + a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">res = b - a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'\*'</span>:</span><br><span class="line">res = b * a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">res = b / a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1935&quot;&gt;&lt;a href=&quot;#Problem-1935&quot; class=&quot;headerlink&quot; title=&quot;Problem 1935&quot;&gt;&lt;/a&gt;Problem 1935&lt;/h1&gt;&lt;h2 id=&quot;후위-표기식-2&quot;&gt;&lt;a href=&quot;#후위-표기
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 6588번 골드바흐의 추측</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/06/algorithm6588/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/06/algorithm6588/</id>
    <published>2020-02-06T10:32:18.000Z</published>
    <updated>2020-02-24T12:50:06.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-6588"><a href="#Problem-6588" class="headerlink" title="Problem 6588"></a>Problem 6588</h1><h2 id="골드바흐의-추측"><a href="#골드바흐의-추측" class="headerlink" title="골드바흐의 추측"></a>골드바흐의 추측</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다.</p><blockquote><p>4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.</p></blockquote><p>예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다. 또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.</p><p>이 추측은 아직도 해결되지 않은 문제이다.</p><p>백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.</p><p>각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)</p><p>입력의 마지막 줄에는 0이 하나 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스에 대해서, n = a + b 형태로 출력한다. 이때, a와 b는 홀수 소수이다. 숫자와 연산자는 공백 하나로 구분되어져 있다. 만약, n을 만들 수 있는 방법이 여러 가지라면, b-a가 가장 큰 것을 출력한다. 또, 두 홀수 소수의 합으로 n을 나타낼 수 없는 경우에는 “Goldbach’s conjecture is wrong.”을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/6588" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/6588</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8<br>20<br>42<br>0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>8 = 3 + 5<br>20 = 3 + 17<br>42 = 5 + 37</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>전체 범위의 소수들을 모두 구한다.(에라토스테네스의 체 이용)</li><li>이후 n - b = a 가 소수인 경우. 즉, 골드바흐의 추측을 만족하는 경우에 n = a + b 를 출력</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAX]; <span class="comment">// 소수들을 담을 배열</span></span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// check의 인덱스가 소수면 참</span></span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>; <span class="comment">// 소수의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) <span class="comment">// 에라토스테네스의 체</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="literal">false</span>)  <span class="comment">// 지워지지 않았다면(소수라면)</span></span><br><span class="line">&#123;</span><br><span class="line">prime[pn++] = i; <span class="comment">// 소수 배열에 추가</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= MAX; j += i) <span class="comment">//  i*i 부터 시작을 하면 정수의 범위를 넘어 런타임 에러가 남</span></span><br><span class="line">&#123;</span><br><span class="line">check[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pn ; i++) <span class="comment">// 3부터 시작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[n - prime[i]]) <span class="comment">// n - prime[i] 가 소수면 성립</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; prime[i] &lt;&lt; <span class="string">" + "</span> &lt;&lt; n - prime[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-6588&quot;&gt;&lt;a href=&quot;#Problem-6588&quot; class=&quot;headerlink&quot; title=&quot;Problem 6588&quot;&gt;&lt;/a&gt;Problem 6588&lt;/h1&gt;&lt;h2 id=&quot;골드바흐의-추측&quot;&gt;&lt;a href=&quot;#골드바흐의
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-04-05T16:12:55.242Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 16975번 수열과 쿼리 21</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/06/algorithm16975/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/06/algorithm16975/</id>
    <published>2020-04-05T16:11:12.000Z</published>
    <updated>2020-04-05T16:12:55.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16975"><a href="#Problem-16975" class="headerlink" title="Problem 16975"></a>Problem 16975</h1><h2 id="수열과-쿼리-21"><a href="#수열과-쿼리-21" class="headerlink" title="수열과 쿼리 21"></a>수열과 쿼리 21</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>1 i j k: Ai, Ai+1, …, Aj에 k를 더한다.</li><li>2 x: Ax 를 출력한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 1,000,000)</p><p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p><p>넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 1번 쿼리의 경우 1 ≤ i ≤ j ≤ N, -1,000,000 ≤ k ≤ 1,000,000 이고, 2번 쿼리의 경우 1 ≤ x ≤ N이다. 2번 쿼리는 하나 이상 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>2번 쿼리가 주어질 때마다 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16975" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16975</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>1 2 3 4 5<br>4<br>1 3 4 6<br>2 3<br>1 1 3 -2<br>2 3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>9<br>7</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 해결하였다.</li><li>리프 노드를 제외한 나머지 노드를 0으로 초기화한다.</li><li>1번 쿼리인 경우 update함수에서<ul><li>범위를 벗어난다면 현재 노드를 리턴하고</li><li>완전히 범위 내에 들어온 경우 각 노드에 더해질 k값들을 모두 누적하여 쿼리 수행 시 거쳐가는 모든 노드의 값을 더할 수 있도록 구성한다.</li></ul></li><li>2번 쿼리를 수행하는 경우<ul><li>리프 노드까지 이동하며 지금까지 각 노드에 누적된 값을 모두 더하여 리턴한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="comment">// 값이 누적되면 정수 범위를 벗어나므로 long long형으로 선언</span></span><br><span class="line">ll a[MAX + <span class="number">1</span>];</span><br><span class="line">ll tree[MAX * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 세그먼트 트리 생성 리프 노드를 제외한 나머지 노드는 0으로 초기화</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">tree[node] = a[start];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree[node] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">init(start, mid, node * <span class="number">2</span>);</span><br><span class="line">init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right, ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 각 노드에 더해질 k값들을 모두 누적하여 쿼리 수행 시 거쳐가는 모든 노드의 값을 더할 수 있도록 구성.</span></span><br><span class="line"><span class="comment">// 범위를 벗어난 경우 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 완전히 범위 내에 들어온 경우 현재 노드에 k를 누적</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line">tree[node] += k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">update(start, mid, node * <span class="number">2</span>, left, right, k);</span><br><span class="line">update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getX</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index, ll ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// index에 맞는 리프 노드까지 이동하며 거치는 노드의 값을 모두 누적한다.</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; start || index &gt; <span class="built_in">end</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ans += tree[node];</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> ans; <span class="comment">// 리프 노드에 도달하면 누적된 값 리턴</span></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> getX(start, mid, node * <span class="number">2</span>, index, ans) + getX(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">init(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q, left, right, index;</span><br><span class="line">ll k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right &gt;&gt; k;</span><br><span class="line">update(<span class="number">1</span>, n, <span class="number">1</span>, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; getX(<span class="number">1</span>, n, <span class="number">1</span>, index, <span class="number">0</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16975&quot;&gt;&lt;a href=&quot;#Problem-16975&quot; class=&quot;headerlink&quot; title=&quot;Problem 16975&quot;&gt;&lt;/a&gt;Problem 16975&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-21&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 13544번 수열과 쿼리 3</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/05/algorithm13544/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/05/algorithm13544/</id>
    <published>2020-04-05T05:01:12.000Z</published>
    <updated>2020-04-05T05:04:38.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-13544"><a href="#Problem-13544" class="headerlink" title="Problem 13544"></a>Problem 13544</h1><h2 id="수열과-쿼리-3"><a href="#수열과-쿼리-3" class="headerlink" title="수열과 쿼리 3"></a>수열과 쿼리 3</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>i j k: Ai, Ai+1, …, Aj로 이루어진 부분 수열 중에서 k보다 큰 원소의 개수를 출력한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p><p>넷째 줄부터 M개의 줄에는 a, b, c가 주어진다. a, b, c를 이용해 쿼리를 만들어야 한다.</p><ul><li>i = a xor last_ans</li><li>j = b xor last_ans</li><li>k = c xor last_ans<br>last_ans는 이전 쿼리의 정답이며, 가장 처음에는 0이다. xor한 결과는 1 ≤ i ≤ j ≤ n, 1 ≤ k ≤ 109 을 만족한다.</li></ul><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/13544" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/13544</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 1 2 3 4<br>3<br>2 4 1<br>6 6 6<br>1 5 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2<br>0<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>수열과 쿼리 1 문제와 똑같지만 xor연산만 추가된 문제이다.</li><li>세그먼트 트리를 이용하여 리프 노드가 아닌 각 노드에 자식 노드들을 원소로 가지는 벡터를 저장한다.<ul><li>원소를 하나씩 입력받을 때마다 트리에 추가하며 알맞은 index를 찾아가며 지나는 노드에 현재 원소를 추가한다.</li><li>머지 소트의 모습과 유사하게 트리가 구성된다.</li></ul></li><li>트리가 완성되면 각 트리의 노드를 정렬한다.</li><li>쿼리가 입력되면 query함수에서 k보다 큰 값의 개수를 리턴해준다.<ul><li>쿼리 수행 전 이전 연산의 답을 저장하여 xor연산 후 쿼리를 수행한다.</li><li>범위를 완전히 벗어난 경우 0을 리턴하고</li><li>현재 노드에서 범위 안에 완벽하게 들어온 경우에 현재 노드의 벡터의 end()에서 upper_bound를 사용하여 k보다 큰 첫 번째 인덱스를 빼주어 k보다 큰 값의 개수를 구해 리턴한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 머지 소트 트리 구성 ( 각 노드에 하위 노드에 포함되는 값을 모두 벡터 형태로 저장 )</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; index || index &gt; <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">tree[node].push_back(x);</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">init(start, mid, node * <span class="number">2</span>, index, x);</span><br><span class="line">init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index, x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 범위를 벗어난 경우 0을 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 범위 내에 완전히 들어온 경우 k보다 큰 수의 개수를 리턴</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="comment">// 벡터의 end()인덱스에서 k보다 큰 가장 가까운 수의 인덱스를 빼서 리턴</span></span><br><span class="line"><span class="keyword">return</span> tree[node].<span class="built_in">end</span>() - upper_bound(tree[node].<span class="built_in">begin</span>(), tree[node].<span class="built_in">end</span>(), k);</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(start, mid, node * <span class="number">2</span>, left, right, k) + query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">init(<span class="number">1</span>, n, <span class="number">1</span>, i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 머지 소트 트리의 각 노드를 정렬</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX * <span class="number">4</span>; i++)</span><br><span class="line">sort(tree[i].<span class="built_in">begin</span>(), tree[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last_ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> left, right, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right &gt;&gt; k;</span><br><span class="line"><span class="comment">// 각각 이전 답에 xor연산을 수행</span></span><br><span class="line">left ^= last_ans;</span><br><span class="line">right ^= last_ans;</span><br><span class="line">k ^= last_ans;</span><br><span class="line"><span class="comment">// 쿼리 수행 후 현재 정답을 기록</span></span><br><span class="line">last_ans = query(<span class="number">1</span>, n, <span class="number">1</span>, left, right, k);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; last_ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-13544&quot;&gt;&lt;a href=&quot;#Problem-13544&quot; class=&quot;headerlink&quot; title=&quot;Problem 13544&quot;&gt;&lt;/a&gt;Problem 13544&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-3&quot;&gt;&lt;a href=&quot;#수
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2357번 최솟값과 최댓값</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/05/algorithm2357/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/05/algorithm2357/</id>
    <published>2020-04-05T01:11:12.000Z</published>
    <updated>2020-04-08T11:41:37.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2357"><a href="#Problem-2357" class="headerlink" title="Problem 2357"></a>Problem 2357</h1><h2 id="최솟값과-최댓값"><a href="#최솟값과-최댓값" class="headerlink" title="최솟값과 최댓값"></a>최솟값과 최댓값</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수, 또는 제일 큰 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.</p><p>여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최소, 최댓값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 최솟값, 최댓값 순서로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2357" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2357</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10 4<br>75<br>30<br>100<br>38<br>50<br>51<br>52<br>20<br>81<br>5<br>1 10<br>3 5<br>6 9<br>8 10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>5 100<br>38 100<br>20 81<br>5 81</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 각 노드에 더 자식 노드 중 더 작은 값과 큰 값을 pair형태로 저장한다.</li><li>쿼리가 들어오면 query함수로 이동하여<ul><li>범위를 벗어난 경우 선택되지 않도록 INT_MAX, 0 리턴</li><li>범위 내에 완전히 들어온 경우 현재 노드 리턴</li><li>좌, 우측 노드로 이동하며 최대, 최솟값을 구해 pair형으로 리턴한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tree[MAX * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; init(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span><br><span class="line">&#123; <span class="comment">// 각 노드에 자식 노드의 최댓값, 최솟값을 가지는 세그먼트 트리 구성</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>)</span><br><span class="line">&#123; <span class="comment">// 리프 노드 도착 시 최대, 최솟값 저장</span></span><br><span class="line">tree[node].first = a[start];</span><br><span class="line">tree[node].second = a[start];</span><br><span class="line"><span class="keyword">return</span> tree[node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 좌측 노드로 이동</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; left = init(start, mid, node * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 우측 노드로 이동</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; right = init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">tree[node].first = <span class="built_in">min</span>(left.first, right.first);</span><br><span class="line">tree[node].second = <span class="built_in">max</span>(left.second, right.second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tree[node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; query(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어난 경우 선택되지 않도록 INT_MAX, 0 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> &#123; INT_MAX, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 범위 내에 완전히 들어온 경우 현재 노드 리턴</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 좌, 우측 노드로 이동하며 최대, 최솟값을 구함.</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; l = query(start, mid, node * <span class="number">2</span>, left, right);</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; r = query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right);</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">res.first = <span class="built_in">min</span>(l.first, r.first);</span><br><span class="line">res.second = <span class="built_in">max</span>(l.second, r.second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">init(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> left, right;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp = query(<span class="number">1</span>, n, <span class="number">1</span>, left, right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp.first &lt;&lt; <span class="string">' '</span> &lt;&lt; tmp.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2357&quot;&gt;&lt;a href=&quot;#Problem-2357&quot; class=&quot;headerlink&quot; title=&quot;Problem 2357&quot;&gt;&lt;/a&gt;Problem 2357&lt;/h1&gt;&lt;h2 id=&quot;최솟값과-최댓값&quot;&gt;&lt;a href=&quot;#최솟값과-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14438번 수열과 쿼리 17</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/05/algorithm14438/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/05/algorithm14438/</id>
    <published>2020-04-04T17:00:12.000Z</published>
    <updated>2020-04-04T17:07:36.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14438"><a href="#Problem-14438" class="headerlink" title="Problem 14438"></a>Problem 14438</h1><h2 id="수열과-쿼리-17"><a href="#수열과-쿼리-17" class="headerlink" title="수열과 쿼리 17"></a>수열과 쿼리 17</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>1 i v : Ai를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 109)</li><li>2 i j : Ai, Ai+1, …, Aj에서 크기가 가장 작은 값을 출력한다. (1 ≤ i ≤ j ≤ N)<br>수열의 인덱스는 1부터 시작한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p><p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14438" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14438</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 4 3 2 1<br>6<br>2 1 3<br>2 1 4<br>1 5 3<br>2 3 5<br>1 4 3<br>2 3 5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>2<br>2<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>수열과 쿼리 15, 16 문제와 아주 유사하다. 2번 쿼리 수행 시 최솟값을 가지는 인덱스가 아닌 그냥 최솟값을 출력하면 된다. 더 쉬운 문제이다.</li><li>세그먼트 트리를 이용하여 각 노드에 더 자식 노드 중 더 작은 값을 저장한다.</li><li>2번 쿼리를 수행하는 경우<ul><li>query함수에서 지정해준 범위를 벗어나면 INT_MAX 리턴하고,(이 값이 리턴되지 않도록)<ul><li>완전히 현재 구간이 지정해준 범위 내에 들어온다면 현재 노드의 값(최솟값)을 리턴한다.</li></ul></li></ul></li><li>1번 쿼리의 경우 update함수에서 수정된 노드와 이어지는 노드들을 모두 수정하여 최솟값 세그먼트 트리를 유지한다.<ul><li>범위를 벗어난다면 현재 노드를 리턴</li><li>리프 노드에서 수정할 인덱스를 찾았다면 현재 노드의 값을 수정 후 리턴</li><li>왼쪽, 오른쪽 자식 노드로 나누어 재귀를 수행하며 더 작은 값을 가지는 인덱스를 현재 노드에 저장(수정)</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tree[MAX * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 자식 노드 중 더 작은 값을 현재 노드로 하는 세그먼트 트리 생성</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = a[start];</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tree[node] = <span class="built_in">min</span>(init(start, mid, node * <span class="number">2</span>), init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어나면 현재 노드 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; index || <span class="built_in">end</span> &lt; index) <span class="keyword">return</span> tree[node];</span><br><span class="line"><span class="comment">// 리프 노드에 도달하면 값 수정 후 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = a[index];</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 수정된 값으로 최솟값 트리 재구성</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = <span class="built_in">min</span>(update(start, mid, node * <span class="number">2</span>, index), update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어난 경우 이 값이 리턴되지 않도록 가장 큰 정수값 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> INT_MAX;</span><br><span class="line"><span class="comment">// 완전히 범위에 들어온 경우 현재 노드(최솟값) 리턴</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="keyword">return</span> tree[node];</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(query(start, mid, node * <span class="number">2</span>, left, right), query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">init(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q, index, v, left, right;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; index &gt;&gt; v;</span><br><span class="line">a[index] = v;</span><br><span class="line">update(<span class="number">1</span>, n, <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, n, <span class="number">1</span>, left, right) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14438&quot;&gt;&lt;a href=&quot;#Problem-14438&quot; class=&quot;headerlink&quot; title=&quot;Problem 14438&quot;&gt;&lt;/a&gt;Problem 14438&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-17&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14428번 수열과 쿼리 16</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/05/algorithm14428/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/05/algorithm14428/</id>
    <published>2020-04-04T16:31:12.000Z</published>
    <updated>2020-04-04T16:36:17.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14428"><a href="#Problem-14428" class="headerlink" title="Problem 14428"></a>Problem 14428</h1><h2 id="수열과-쿼리-16"><a href="#수열과-쿼리-16" class="headerlink" title="수열과 쿼리 16"></a>수열과 쿼리 16</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>1 i v : Ai를 v로 바꾼다.</li><li>2 i j : Ai, Ai+1, …, Aj에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다.<br>수열의 인덱스는 1부터 시작한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p><p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14428" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14428</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 4 3 2 1<br>6<br>2 1 3<br>2 1 4<br>1 5 3<br>2 3 5<br>1 4 3<br>2 3 5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>4<br>4<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>수열과 쿼리 15문제와 아주 유사하다. 2번 쿼리 시 범위가 주어지는 것이 다르다.</li><li>세그먼트 트리를 이용하여 각 노드에 더 자식 노드 중 더 작은 값의 인덱스를 저장한다.<ul><li>minIndex라는 함수를 생성하여 두 인덱스를 받아 더 작은 값을 가지는 인덱스를 리턴한다.</li><li>이 때, 두 값이 같은 경우 더 작은 인덱스를 리턴한다.</li></ul></li><li>2번 쿼리를 수행하는 경우 query함수에서 지정해준 범위를 벗어나면 -1을 리턴하고, 완전히 현재 구간이 지정해준 범위 내에 들어온다면 현재 노드의 값(하위 노드 중 최솟값을 가지는 인덱스)을 리턴한다.</li><li>1번 쿼리의 경우 update함수에서 minIndex함수를 사용해서 수정된 노드와 이어지는 노드들을 모두 수정한다.<ul><li>범위를 벗어나거나 리프 노드에서 수정할 인덱스를 찾았다면 현재 노드의 값(a의 인덱스)를 리턴</li><li>왼쪽, 오른쪽 자식 노드로 나누어 재귀를 수행하며 더 작은 값을 가지는 인덱스를 현재 노드에 저장(수정)</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIndex</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 더 작은 값의 인덱스를 반환하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 유효하지 않은 경우</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">// 같은 경우 더 작은 인덱스 리턴</span></span><br><span class="line"><span class="keyword">if</span> (a[x] == a[y]) <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a[x] &lt;= a[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = start;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(init(start, mid, node * <span class="number">2</span>), init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// index를 찾았거나 범위를 벗어난 경우 현재 노드 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; index || <span class="built_in">end</span> &lt; index) <span class="keyword">return</span> tree[node];</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값을 가지는 인덱스로 update</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(update(start, mid, node * <span class="number">2</span>, index), update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 구간을 벗어나는 경우</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 완전히 구간 안에 들어온 경우</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값을 가지는 인덱스 리턴</span></span><br><span class="line"><span class="keyword">return</span> minIndex(query(start, mid, node * <span class="number">2</span>, left, right), query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">init(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q, index, v, left, right;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; index &gt;&gt; v;</span><br><span class="line">a[index] = v;</span><br><span class="line">update(<span class="number">1</span>, n, <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, n, <span class="number">1</span>, left, right) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14428&quot;&gt;&lt;a href=&quot;#Problem-14428&quot; class=&quot;headerlink&quot; title=&quot;Problem 14428&quot;&gt;&lt;/a&gt;Problem 14428&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-16&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 13537번 수열과 쿼리 1</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/04/algorithm13537/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/04/algorithm13537/</id>
    <published>2020-04-04T04:11:12.000Z</published>
    <updated>2020-04-04T04:17:59.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-13537"><a href="#Problem-13537" class="headerlink" title="Problem 13537"></a>Problem 13537</h1><h2 id="수열과-쿼리-1"><a href="#수열과-쿼리-1" class="headerlink" title="수열과 쿼리 1"></a>수열과 쿼리 1</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>i j k: Ai, Ai+1, …, Aj로 이루어진 부분 수열 중에서 k보다 큰 원소의 개수를 출력한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p><p>넷째 줄부터 M개의 줄에는 쿼리 i, j, k가 한 줄에 하나씩 주어진다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ 109)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/13537" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/13537</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 1 2 3 4<br>3<br>2 4 1<br>4 4 4<br>1 5 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2<br>0<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 리프 노드가 아닌 각 노드에 자식 노드들을 원소로 가지는 벡터를 저장한다.<ul><li>원소를 하나씩 입력받을 때마다 트리에 추가하며 알맞은 index를 찾아가며 지나는 노드에 현재 원소를 추가한다.</li><li>머지 소트의 모습과 유사하게 트리가 구성된다.</li></ul></li><li>트리가 완성되면 각 트리의 노드를 정렬한다.</li><li>쿼리가 입력되면 query함수에서 k보다 큰 값의 개수를 리턴해준다.<ul><li>범위를 완전히 벗어난 경우 0을 리턴하고</li><li>현재 노드에서 범위 안에 완벽하게 들어온 경우에 현재 노드의 벡터의 end()에서 upper_bound를 사용하여 k보다 큰 첫 번째 인덱스를 빼주어 k보다 큰 값의 개수를 구해 리턴한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 원소를 하나씩 추가하며 세그먼트 트리 구성</span></span><br><span class="line"><span class="comment">// 리프 노드가 아닌 각 노드에 자식 노드들을 원소로 가지는 벡터를 저장</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; index || <span class="built_in">end</span> &lt; index) <span class="keyword">return</span>;</span><br><span class="line">tree[node].push_back(x);</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">update(start, mid, node * <span class="number">2</span>, index, x);</span><br><span class="line">update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 범위 안에 들어온 경우 더 큰 값들의 개수를 리턴</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="keyword">return</span> tree[node].<span class="built_in">end</span>() - upper_bound(tree[node].<span class="built_in">begin</span>(), tree[node].<span class="built_in">end</span>(), k);</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 큰 값들의 개수를 더해 리턴</span></span><br><span class="line"><span class="keyword">return</span> query(start, mid, node * <span class="number">2</span>, left, right, k) + query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">update(<span class="number">1</span>, n, <span class="number">1</span>, i, a[i]); <span class="comment">// 트리 구성</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX * <span class="number">4</span>; i++) <span class="comment">// 모든 노드 정렬</span></span><br><span class="line">sort(tree[i].<span class="built_in">begin</span>(), tree[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> left, right, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, n, <span class="number">1</span>, left, right, k) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-13537&quot;&gt;&lt;a href=&quot;#Problem-13537&quot; class=&quot;headerlink&quot; title=&quot;Problem 13537&quot;&gt;&lt;/a&gt;Problem 13537&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-1&quot;&gt;&lt;a href=&quot;#수
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14427번 수열과 쿼리 15</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/04/algorithm14427/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/04/algorithm14427/</id>
    <published>2020-04-03T16:51:12.000Z</published>
    <updated>2020-04-03T16:56:32.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14427"><a href="#Problem-14427" class="headerlink" title="Problem 14427"></a>Problem 14427</h1><h2 id="수열과-쿼리-15"><a href="#수열과-쿼리-15" class="headerlink" title="수열과 쿼리 15"></a>수열과 쿼리 15</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>1 i v : Ai를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 109)</li><li>2 : 수열에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다.<br>수열의 인덱스는 1부터 시작한다.<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</li></ul><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p><p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14427" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14427</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 4 3 2 1<br>5<br>2<br>1 5 3<br>2<br>1 4 3<br>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>5<br>4<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 각 노드에 더 자식 노드 중 더 작은 값의 인덱스를 저장한다.<ul><li>minIndex라는 함수를 생성하여 두 인덱스를 받아 더 작은 값을 가지는 인덱스를 리턴한다.</li><li>이 때, 두 값이 같은 경우 더 작은 인덱스를 리턴한다.</li></ul></li><li>2번 쿼리를 수행하는 경우 세그먼트 트리의 1번 노드에 최솟값의 인덱스가 저장되어 있으므로 tree[1] + 1을 출력한다.(인덱스는 0부터 저장했음)</li><li>1번 쿼리의 경우 update함수에서 minIndex함수를 사용해서 수정된 노드와 이어지는 노드들을 모두 수정한다.<ul><li>범위를 벗어나거나 리프 노드에서 수정할 인덱스를 찾았다면 현재 노드의 값(a의 인덱스)를 리턴</li><li>왼쪽, 오른쪽 자식 노드로 나누어 재귀를 수행하며 더 작은 값을 가지는 인덱스를 현재 노드에 저장(수정)</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIndex</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 두 인덱스를 받아 더 작은 값을 가지는 인덱스를 리턴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] == a[y]) <span class="keyword">return</span> x &lt; y ? x : y; <span class="comment">// 같은 경우 더 작은 인덱스를 리턴</span></span><br><span class="line"><span class="keyword">return</span> a[x] &lt; a[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 자식 노드 중 작은 값의 인덱스를 부모 노드에 저장하는 세그먼트 트리</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = start;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값의 인덱스를 각 노드에 저장</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(init(start, mid, node * <span class="number">2</span>), init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 범위를 벗어나거나 수정할 인덱스를 찾았다면 현재 노드 리턴</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; start || index &gt; <span class="built_in">end</span> || start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값을 가지는 인덱스를 현재 노드에 저장</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(update(start, mid, node * <span class="number">2</span>, index), update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">init(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 세그먼트 트리 생성</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q, index, value;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 수정하는 경우</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; index &gt;&gt; value;</span><br><span class="line">index--;</span><br><span class="line">a[index] = value;</span><br><span class="line">update(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">2</span>)</span><br><span class="line">&#123; <span class="comment">// 트리의 1번 노드가 최소값의 인덱스</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tree[<span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14427&quot;&gt;&lt;a href=&quot;#Problem-14427&quot; class=&quot;headerlink&quot; title=&quot;Problem 14427&quot;&gt;&lt;/a&gt;Problem 14427&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-15&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2042번 구간 합 구하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/03/algorithm2042/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/03/algorithm2042/</id>
    <published>2020-04-03T04:51:12.000Z</published>
    <updated>2020-04-03T16:56:47.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2042"><a href="#Problem-2042" class="headerlink" title="Problem 2042"></a>Problem 2042</h1><h2 id="구간-합-구하기"><a href="#구간-합-구하기" class="headerlink" title="구간 합 구하기"></a>구간 합 구하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b번째 수를 c로 바꾸고 a가 2인 경우에는 b번째 수부터 c번째 수까지의 합을 구하여 출력하면 된다.</p><p>입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -2^63보다 크거나 같고, 2^63-1보다 작거나 같은 정수이다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2042" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2042</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 2 2<br>1<br>2<br>3<br>4<br>5<br>1 3 6<br>2 2 5<br>1 5 2<br>2 3 5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>17<br>12</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 구간 합을 구하는 문제이다.</li><li>트리의 각 노드에 모든 하위 노드의 합을 저장하여 구간합을 구한다.</li><li>자세한 설명은 주석에 있다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;a, <span class="built_in">vector</span>&lt;ll&gt; &amp;tree, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 세그먼트 트리 생성</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = a[start]; <span class="comment">// 리프 노드에 도달한 경우</span></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 재귀적으로 두 부분을 나누어 그 합을 자기 자신으로 한다.</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = init(a, tree, start, mid, node * <span class="number">2</span>) + init(a, tree, mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left ~ right 까지의 구간합을 구함, start, end : 시작, 끝 인덱스</span></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;&amp; tree, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어난 경우</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; <span class="built_in">end</span> || right &lt; start) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 범위 내에 포함된 경우 현재 트리의 값 리턴(구간합)</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; right &gt;= <span class="built_in">end</span>) <span class="keyword">return</span> tree[node];</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> sum(tree, start, mid, node * <span class="number">2</span>, left, right) + sum(tree, mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index : 수정할 노드의 인덱스, dif : 노드의 차이값</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;&amp; tree, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index, ll dif)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어난 경우</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; start || index &gt; <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">tree[node] += dif; <span class="comment">// 수정할 노드가 포함된 노드들의 값을 수정</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span>; <span class="comment">// 수정할 노드를 찾은 경우</span></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">update(tree, start, mid, node * <span class="number">2</span>, index, dif);</span><br><span class="line">update(tree, mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index, dif);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a(n);</span><br><span class="line"><span class="keyword">int</span> h = (<span class="keyword">int</span>)<span class="built_in">ceil</span>(log2(n)); <span class="comment">// 트리의 높이</span></span><br><span class="line"><span class="keyword">int</span> tree_size = (<span class="number">1</span> &lt;&lt; (h + <span class="number">1</span>)); <span class="comment">// 세그먼트 트리의 크기</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; tree(tree_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">init(a, tree, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 세그먼트 트리 생성</span></span><br><span class="line">k += m; <span class="comment">// m + k번 반복</span></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t1, t2, t3;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;</span><br><span class="line"><span class="keyword">if</span> (t1 == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t2--; <span class="comment">// 인덱스로 맞춤</span></span><br><span class="line">ll dif = (ll)(t3 - a[t2]); <span class="comment">// 차이값 저장</span></span><br><span class="line">a[t2] = t3; <span class="comment">// a[t2] 값 변경</span></span><br><span class="line">update(tree, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, t2, dif);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t1 == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(tree, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, t2 - <span class="number">1</span>, t3 - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2042&quot;&gt;&lt;a href=&quot;#Problem-2042&quot; class=&quot;headerlink&quot; title=&quot;Problem 2042&quot;&gt;&lt;/a&gt;Problem 2042&lt;/h1&gt;&lt;h2 id=&quot;구간-합-구하기&quot;&gt;&lt;a href=&quot;#구간-합-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 12970번 AB</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/03/algorithm12970/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/03/algorithm12970/</id>
    <published>2020-04-02T18:11:12.000Z</published>
    <updated>2020-04-02T18:15:51.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-12970"><a href="#Problem-12970" class="headerlink" title="Problem 12970"></a>Problem 12970</h1><h2 id="AB"><a href="#AB" class="headerlink" title="AB"></a>AB</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 N과 K가 주어졌을 때, 다음 두 조건을 만족하는 문자열 S를 찾는 프로그램을 작성하시오.</p><ul><li>문자열 S의 길이는 N이고, ‘A’, ‘B’로 이루어져 있다.</li><li>문자열 S에는 0 ≤ i &lt; j &lt; N 이면서 s[i] == ‘A’ &amp;&amp; s[j] == ‘B’를 만족하는 (i, j) 쌍이 K개가 있다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (2 ≤ N ≤ 50, 0 ≤ K ≤ N(N-1)/2)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 조건을 만족하는 문자열 S를 출력한다. 가능한 S가 여러 가지라면, 아무거나 출력한다. 만약, 그러한 S가 존재하지 않는 경우에는 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/12970" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/12970</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>ABB</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>2 0</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>BA</p><h3 id="예제-입력-2-1"><a href="#예제-입력-2-1" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>5 8</p><h3 id="예제-출력-2-1"><a href="#예제-출력-2-1" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>10 12</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>BAABBABAAB</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>A와 B의 개수를 각각 a, b라고 했을때, 만족하는 쌍의 개수는 0 ~ a * b개가 된다.</li><li>여기서 주어진 k개 만큼 쌍을 가지도록 문자열을 만들기 위해서는 먼저 주어진 문자열의 크기만큼 모두 B로 채우고,</li><li>k가 a * b보다 작거나 같을 때까지 a, b를 조정한다.</li><li>작거나 같아진다면 앞에서부터 a - 1개까지 A로 채운다.<ul><li>예를 들어, 입력이 7 11 이라면 a = 3, b = 4 일때 만족하므로</li><li>AABBBBB와 같은 상태로 문자열을 만든다.</li><li>여기서 맨 마지막 문자를 A로 바꾼다면 AABBBBA가 될 것이다.</li><li>이 상태에서 쌍의 개수는 (a - 1) * b개가 되고 이 값을 k에서 빼면 남은 필요한 쌍의 개수가 된다.<ul><li>(이 값을 r이라고 한다.)</li></ul></li><li>AABBBBA에서 마지막 A를 한 칸씩 왼쪽으로 이동시킬 때마다 필요한 쌍의 개수가 1씩 증가한다.</li><li>즉, 마지막 A를 왼쪽으로 r만큼 이동시키면 k개의 쌍을 구할 수 있다.</li></ul></li><li>위와 같이 그리디 방식으로 문제를 해결하였다.</li></ul><hr><ul><li>조건을 만족하는 문자열이 있으려면 최대 (n/2 * (n - n/2)) 보다 작아야 한다.<ul><li>가장 많은 쌍을 가지는 경우가 A와 B가 절반 씩 있는 경우이다.</li></ul></li><li>먼저 주어진 문자열의 크기만큼 모두 B로 채운다.</li><li>k가 0인 경우 예외처리를 해준다. (그냥 맨 마지막 문자를 A로 바꿔서 처리했다.)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countAB</span><span class="params">(<span class="built_in">string</span> ab)</span> <span class="comment">// 디버깅용 AB개수 체크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ab.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ab[i] == <span class="string">'A'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; ab.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ab[j] == <span class="string">'B'</span>)</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; m * (n - m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ab = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// B로 모두 채운다.</span></span><br><span class="line">ab += <span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) <span class="comment">// 0일 때 예외 처리</span></span><br><span class="line">&#123;</span><br><span class="line">ab[n - <span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ab &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = n; <span class="comment">// A, B의 개수 초기화</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a * b &gt;= k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a - <span class="number">1</span>; i++) <span class="comment">// 앞에서부터 A의 개수 - 1 개를 A로 채운다.</span></span><br><span class="line">ab[i] = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = (a - <span class="number">1</span>) * b; <span class="comment">// A의 개수 - 1 * B의 개수를 저장 (마지막에 들어갈 A를 제외한 개수)</span></span><br><span class="line"><span class="keyword">int</span> r = k - c; <span class="comment">// 마지막 A를 이용하여 채워야할 쌍의 개수</span></span><br><span class="line">ab[(n - <span class="number">1</span>) - r] = <span class="string">'A'</span>; <span class="comment">// 마지막 인덱스에서 r개 앞에 A를 넣는다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b--; <span class="comment">// A, B의 개수 조정</span></span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ab &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-12970&quot;&gt;&lt;a href=&quot;#Problem-12970&quot; class=&quot;headerlink&quot; title=&quot;Problem 12970&quot;&gt;&lt;/a&gt;Problem 12970&lt;/h1&gt;&lt;h2 id=&quot;AB&quot;&gt;&lt;a href=&quot;#AB&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14267번 내리 갈굼</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/31/algorithm14267/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/31/algorithm14267/</id>
    <published>2020-03-30T16:41:12.000Z</published>
    <updated>2020-03-30T16:46:34.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14267"><a href="#Problem-14267" class="headerlink" title="Problem 14267"></a>Problem 14267</h1><h2 id="내리-갈굼"><a href="#내리-갈굼" class="headerlink" title="내리 갈굼"></a>내리 갈굼</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>영선회사에는 치명적인 악습이 있는데, 바로 상사가 직속 부하를 갈구면 그 부하가 부하의 직속 부하를 연쇄적으로 갈구는 내리 갈굼이 있다. 즉, 상사가 한 직속 부하를 갈구면 그 부하의 모든 부하들이 갈굼을 당한다.</p><p>갈굼에 대해 정도에 대한 수치가 주어지는데, 이 수치 또한 부하들에게 똑같이 갈궈진다.</p><p>직속 상사와 직속 부하관계에 대해 주어지고, 갈굼에 대한 정보가 주어질 때, 각자 얼마의 갈굼을 당했는지 출력하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 회사의 직원 수 n명, 최초의 갈굼 횟수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)</p><p>둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.</p><p>다음 m줄에는 직속 상사로부터 갈굼을 당한 직원 번호 i,갈굼의 수치 w가 주어진다.(2 ≤ i ≤ n, 1 ≤ w ≤ 1,000) 사장은 상사가 없으므로 갈굼을 당하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>1번부터 n번의 직원까지 갈굼을 당한 정도를 출력하시오.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14267" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14267</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 3<br>-1 1 2 3 4<br>2 2<br>3 4<br>5 6</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0 2 6 6 12</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>dfs로 갈굼 정도를 누적하여 부하에게 물려주면 된다.</li><li>n제한이 10만이기 때문에 갈굼의 정도를 모두 저장 후 한번만 순회하면서 모두 물려주도록 한다.</li><li>같은 부하에게 여러번 갈구는 경우를 생각하지 않아서 계속 틀렸던 거였다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cost[MAX + <span class="number">1</span>]; <span class="comment">// 갈굼 횟수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[now].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = v[now][i];</span><br><span class="line">cost[next] += cost[now]; <span class="comment">// 갈굼 수치 누적</span></span><br><span class="line">go(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// -1은 건너뜀</span></span><br><span class="line">v[k].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">cost[u] += v;<span class="comment">// 갈굼 정도 저장</span></span><br><span class="line">&#125;</span><br><span class="line">go(<span class="number">1</span>); <span class="comment">// 1번부터 dfs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cost[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14267&quot;&gt;&lt;a href=&quot;#Problem-14267&quot; class=&quot;headerlink&quot; title=&quot;Problem 14267&quot;&gt;&lt;/a&gt;Problem 14267&lt;/h1&gt;&lt;h2 id=&quot;내리-갈굼&quot;&gt;&lt;a href=&quot;#내리-갈
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC 마리아 DB 연동 - 이클립스</title>
    <link href="https://kyu9341.github.io/java/2020/03/30/java_jdbc/"/>
    <id>https://kyu9341.github.io/java/2020/03/30/java_jdbc/</id>
    <published>2020-03-30T06:12:28.000Z</published>
    <updated>2020-03-30T11:32:38.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC-마리아-DB-연동-with-이클립스"><a href="#JDBC-마리아-DB-연동-with-이클립스" class="headerlink" title="JDBC 마리아 DB 연동 with 이클립스"></a>JDBC 마리아 DB 연동 with 이클립스</h2><h3 id="MariaDB-JDBC-드라이버-설치"><a href="#MariaDB-JDBC-드라이버-설치" class="headerlink" title="MariaDB JDBC 드라이버 설치"></a>MariaDB JDBC 드라이버 설치</h3><p>JDBC를 사용하여 데이터베이스와 연결하기 위해서는 각 DBMS에 맞는 JDBC드라이버가 필요하다.</p><p>먼저 마리아 db가 설치를 한 뒤 다음 사이트로 이동한다.</p><p><a href="https://downloads.mariadb.org/connector-java/" target="_blank" rel="external nofollow noopener noreferrer">https://downloads.mariadb.org/connector-java/</a></p><p>이동하여 아래의 다운로드 버튼을 선택한다.</p><div style="width: 700px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc0.png" style="width: 700px    ; height: 400px;"></div><p>(MariaDB Connector/J .jar files) 을 선택한다.</p><div style="width: 600px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc01.png" style="width: 600px    ; height: 400px;"></div><p>그럼 다음 화면으로 넘어가는데, 아래 화면에 표시된 jar파일을 선택하여 다운로드 받는다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc02.png" style="width: 400px    ; height: 400px;"></div><h3 id="이클립스-연동"><a href="#이클립스-연동" class="headerlink" title="이클립스 연동"></a>이클립스 연동</h3><p>이제 이클립스로 넘어가서 연동시킬 프로젝트에서 우클릭을 하여 Build Path를 선택하고 <strong>Configure Build Path</strong> 를 선택한다.</p><div style="width: 600px; height: 610px;">    <img src="https://kyu9341.github.io/img/jdbc1.png" style="width: 600px    ; height: 600px;"></div><p>다음과 같은 창이 뜨면 아래 표시된 대로 Java Build Path =&gt; Libraries =&gt; Add External JARs… 을 선택한다.</p><div style="width: 700px; height: 510px;">    <img src="https://kyu9341.github.io/img/jdbc2.png" style="width: 700px    ; height: 500px;"></div><p>위에서 다운받았던 폴더로 이동하여 다운로드된 jar파일을 선택한다.</p><div style="width: 700px; height: 80px;">    <img src="https://kyu9341.github.io/img/jdbc3.png" style="width: 700px    ; height: 50px;"></div><p>아래와 같이 선택이 되었다면 Apply버튼을 눌러 적용을 하고 닫아준다.</p><div style="width: 700px; height: 500px;">    <img src="https://kyu9341.github.io/img/jdbc4.png" style="width: 700px    ; height: 500px;"></div><p>그럼 Referenced Libraries아래에 jar파일이 추가된 것을 확인할 수 있다.<br>아래와 같이 선택이 되었다면 Apply버튼을 눌러 적용을 하고 닫아준다.</p><div style="width: 250px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc5.png" style="width: 250px    ; height: 400px;"></div><h3 id="MariaDB-연동-예제-코드"><a href="#MariaDB-연동-예제-코드" class="headerlink" title="MariaDB 연동 예제 코드"></a>MariaDB 연동 예제 코드</h3><ul><li>간단하게 데이터베이스와 연동하여 원하는 컬럼의 값을 가져오는 예제이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread.State;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">String url = <span class="string">"jdbc:mariadb://127.0.0.1:3307/dbName"</span>;</span><br><span class="line">String sql = <span class="string">"SELECT * FROM tableName"</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 클래스를 객체화, 드라이버를 로드</span></span><br><span class="line">Class.forName(<span class="string">"org.mariadb.jdbc.Driver"</span>);</span><br><span class="line">                <span class="comment">// 실행 도구 생성</span></span><br><span class="line">Connection con = DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"asas1207"</span>);</span><br><span class="line">                <span class="comment">// 연결 객체를 얻음</span></span><br><span class="line">Statement st = con.createStatement();</span><br><span class="line">                <span class="comment">// 쿼리를 실행하여 결과 집합을 얻어온다.</span></span><br><span class="line">ResultSet rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rs.next()) &#123; <span class="comment">// 다음 값을 가져옴 Bof ~ Eof</span></span><br><span class="line">String ex1 = rs.getString(<span class="string">"columnName"</span>);</span><br><span class="line">System.out.println(ex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDBC-마리아-DB-연동-with-이클립스&quot;&gt;&lt;a href=&quot;#JDBC-마리아-DB-연동-with-이클립스&quot; class=&quot;headerlink&quot; title=&quot;JDBC 마리아 DB 연동 with 이클립스&quot;&gt;&lt;/a&gt;JDBC 마리아 DB 연동
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 13548번 시험 감독</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/27/algorithm13458/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/27/algorithm13458/</id>
    <published>2020-03-27T07:01:01.000Z</published>
    <updated>2020-03-27T07:01:56.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-13548"><a href="#Problem-13548" class="headerlink" title="Problem 13548"></a>Problem 13548</h1><h2 id="시험-감독"><a href="#시험-감독" class="headerlink" title="시험 감독"></a>시험 감독</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다.</p><p>감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다.</p><p>각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다.</p><p>각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 시험장의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다.</p><p>둘째 줄에는 각 시험장에 있는 응시자의 수 Ai (1 ≤ Ai ≤ 1,000,000)가 주어진다.</p><p>셋째 줄에는 B와 C가 주어진다. (1 ≤ B, C ≤ 1,000,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 시험장마다 응시생을 모두 감독하기 위해 필요한 감독관의 최소 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/13548" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/13548</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>1<br>1<br>1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3<br>3 4 5<br>2 2</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>7</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>5<br>1000000 1000000 1000000 1000000 1000000<br>5 7</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>714290</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>5<br>10 9 10 9 10<br>7 20</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>10</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>총 감독관은 최소 1명씩 필요하므로 ans를 n으로 초기화한다.</li><li>각 시험장의 인원 수에서 총 감독관이 감시가능한 인원을 빼고, 나머지 인원을 부 감독관이 감시가능한 인원으로 나눈다.<ul><li>이 때, 나눈 몫이 필요한 부 감독관의 인원 수인데, 나머지가 0이면 나눈 몫을 넣고 0이 아니면 1명이 더 필요하므로 1을 더하여 누적한다.</li><li>또한 총 감독관만으로 모든 인원을 감시할 수 있는 경우에는 위 연산을 수행하지 않고 넘어간다.</li></ul></li><li>주의할 점은 100만 * 100만이 최대이므로 long long형으로 구해야 한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, b, c; <span class="comment">// 100만 * 100만이 최대이므로 long long</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = n; <span class="comment">// 총 감독관은 무조건 1명씩</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] -= b;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 총 감독관 1명으로 모두 감시 가능한 경우</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s = a[i] / c;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r = a[i] % c;</span><br><span class="line"></span><br><span class="line">ans += r == <span class="number">0</span> ? s : s + <span class="number">1</span>; <span class="comment">// 나머지가 0이 아니면 1명 추가</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-13548&quot;&gt;&lt;a href=&quot;#Problem-13548&quot; class=&quot;headerlink&quot; title=&quot;Problem 13548&quot;&gt;&lt;/a&gt;Problem 13548&lt;/h1&gt;&lt;h2 id=&quot;시험-감독&quot;&gt;&lt;a href=&quot;#시험-감
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 18808번 스티커 붙이기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/27/algorithm18808/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/27/algorithm18808/</id>
    <published>2020-03-26T16:10:12.000Z</published>
    <updated>2020-03-26T16:15:08.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-18808"><a href="#Problem-18808" class="headerlink" title="Problem 18808"></a>Problem 18808</h1><h2 id="스티커-붙이기"><a href="#스티커-붙이기" class="headerlink" title="스티커 붙이기"></a>스티커 붙이기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>R혜윤이는 최근에 다양한 대회를 참여하면서 노트북에 붙일 수 있는 스티커들을 많이 받았다. 스티커는 아래와 같이 사각 모눈종이 위에 인쇄되어 있으며, 스티커의 각 칸은 상하좌우로 모두 연결되어 있다. 또한 모눈종이의 크기는 스티커의 크기에 꼭 맞아서, 상하좌우에 스티커가 포함되지 않는 불필요한 행이나 열이 존재하지 않는다.</p><p>아래는 올바른 모눈종이의 예시이다. 주황색 칸은 스티커가 붙은 칸을, 하얀색 칸은 스티커가 붙지 않은 칸을 나타낸다.</p><p>반면 아래는 올바르지 않은 모눈종이의 예시이다. 첫 번째는 윗쪽에 불필요한 행이 있고, 두 번째는 왼쪽에 불필요한 열이 있다. 그리고 세 번째는 스티커의 각 칸이 상하좌우로 모두 연결되어 있지 않다.</p><p>혜윤이는 자신의 노트북에 이 스티커들을 붙이기로 했다. 혜윤이의 노트북은 마침 직사각형 모양이고, 스티커가 인쇄된 모눈종이와 같은 간격으로 격자가 그려져 있다. 혜윤이는 스티커들을 먼저 받았던 것부터 차례대로 격자에 맞춰서 붙이려고 한다.</p><p>혜윤이가 스티커를 붙이는 방법은 다음과 같다.</p><ol><li>스티커를 회전시키지 않고 모눈종이에서 떼어낸다.</li><li>다른 스티커와 겹치거나 노트북을 벗어나지 않으면서 스티커를 붙일 수 있는 위치를 찾는다. 혜윤이는 노트북의 위쪽부터 스티커를 채워 나가려고 해서, 스티커를 붙일 수 있는 위치가 여러 곳 있다면 가장 위쪽의 위치를 선택한다. 가장 위쪽에 해당하는 위치도 여러 곳이 있다면 그중에서 가장 왼쪽의 위치를 선택한다.</li><li>선택한 위치에 스티커를 붙인다. 만약 스티커를 붙일 수 있는 위치가 전혀 없어서 스티커를 붙이지 못했다면, 스티커를 시계 방향으로 90도 회전한 뒤 2번 과정을 반복한다.</li><li>위의 과정을 네 번 반복해서 스티커를 0도, 90도, 180도, 270도 회전시켜 봤음에도 스티커를 붙이지 못했다면 해당 스티커를 붙이지 않고 버린다.</li></ol><p>아래의 예시를 통해 스티커를 붙이는 과정을 이해해보자. 노트북은 세로 5칸, 가로 4칸 크기이고, 혜윤이가 가지고 있는 스티커들은 아래와 같다. 왼쪽에서 오른쪽 순으로 스티커를 붙일 것이다.</p><p>첫 번째 스티커는 회전 없이 온전히 붙일 수 있는 공간이 아래와 같이 6곳이 있다.</p><p>이 중에서 가장 위쪽의 위치, 가능한 가장 위쪽의 위치가 여러 개이면 그 중에서 가장 왼쪽의 위치는 첫 번째이다. 스티커를 붙인 후 노트북의 모양은 아래와 같다.</p><p>두 번째 스티커는 회전 없이 온전히 붙일 수 있는 공간이 없다. 그러나 시계 방향으로 90도 회전한 후에는 붙일 수 있는 공간이 1개 생긴다. 해당 공간에 스티커를 붙인 후 노트북의 모양은 아래와 같다.</p><p>세 번째 스티커는 스티커를 시계방향으로 0, 90, 180, 270도 회전시킨 모양에 대해 전부 확인을 해도 스티커를 붙일 수 있는 공간이 없다. 그러므로 해당 스티커를 붙이지 않고 버린다.</p><p>네 번째 스티커는 스티커를 시계방향으로 0, 90, 180도 회전 시킨 모양에 대해 온전히 붙일 수 있는 공간이 없다. 그러나 시계 방향으로 270도 회전한 후에는 공간이 1개 생긴다. 스티커를 붙인 후 노트북의 모양은 아래와 같다. 최종적으로 노트북의 18칸이 스티커로 채워졌다.</p><p>혜윤이는 스티커를 다 붙인 후의 노트북의 모습이 궁금해졌다. 노트북의 크기와 스티커들이 주어졌을 때 스티커들을 차례대로 붙이고 난 후 노트북에서 몇 개의 칸이 채워졌는지 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 노트북의 세로와 가로 길이를 나타내는 N(1 ≤ N ≤ 40)과 M(1 ≤ M ≤ 40), 그리고 스티커의 개수 K(1 ≤ K ≤ 100)이 한 칸의 빈칸을 사이에 두고 주어진다.</p><p>그 다음 줄부터는 K개의 스티커들에 대한 정보가 주어진다. 각 스티커는 아래와 같은 형식으로 주어진다.</p><p>먼저 i번째 스티커가 인쇄된 모눈종이의 행의 개수와 열의 개수를 나타내는 Ri(1 ≤ Ri ≤ 10)와 Ci(1 ≤ Ci ≤ 10)가 한 칸의 빈칸을 사이에 두고 주어진다.</p><p>다음 Ri개의 줄에는 각 줄마다 모눈종이의 각 행을 나타내는 Ci개의 정수가 한 개의 빈칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0, 1이다. 0은 스티커가 붙지 않은 칸을, 1은 스티커가 붙은 칸을 의미한다.</p><p>문제에서 설명한 것과 같이 스티커는 모두 올바른 모눈종이에 인쇄되어 있다. 구체적으로 스티커의 각 칸은 상하좌우로 모두 연결되어 있고, 모눈종이의 크기는 스티커의 크기에 꼭 맞아서 상하좌우에 스티커에 전혀 포함되지 않는 불필요한 행이나 열이 존재하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 주어진 스티커들을 차례대로 붙였을 때 노트북에서 스티커가 붙은 칸의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/18808" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/18808</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ol><li>스티커를 회전시키지 않고 모눈종이에서 떼어낸다.</li><li>다른 스티커와 겹치거나 노트북을 벗어나지 않으면서 스티커를 붙일 수 있는 위치를 찾는다. 혜윤이는 노트북의 위쪽부터 스티커를 채워 나가려고 해서, 스티커를 붙일 수 있는 위치가 여러 곳 있다면 가장 위쪽의 위치를 선택한다. 가장 위쪽에 해당하는 위치도 여러 곳이 있다면 그중에서 가장 왼쪽의 위치를 선택한다.</li><li>선택한 위치에 스티커를 붙인다. 만약 스티커를 붙일 수 있는 위치가 전혀 없어서 스티커를 붙이지 못했다면, 스티커를 시계 방향으로 90도 회전한 뒤 2번 과정을 반복한다.</li><li>위의 과정을 네 번 반복해서 스티커를 0도, 90도, 180도, 270도 회전시켜 봤음에도 스티커를 붙이지 못했다면 해당 스티커를 붙이지 않고 버린다.</li></ol><hr><ul><li><p>위의 1~4번 과정을 그대로 구현하면 된다.</p></li><li><p>먼저, 스티커를 노트북에 붙이는 함수(attach)와 스티커를 90도 회전시키는 함수(rotate)를 만들었다.</p><ul><li>attach함수는 현재 위치부터 스티커의 범위까지 a[x][y]가 0(스티커가 없는 경우)인 경우에만 스티커를 붙였다.</li><li>rotate함수는 임시 배열에 현재 스티커 배열을 복사하고 스티커 배열을 0으로 초기화 한다.</li><li>90도를 회전하는 것이므로 행과 열이 뒤바뀌게 된다. 회전하기 전 행, 열의 크기를 row-1, col-1이라 한다면<ul><li>(0, 0) -&gt; (0, row - 1)로, (0, 1) -&gt; (1, row - 1), (0, 2) -&gt; (2, row - 1) …</li><li>(1, 0) -&gt; (0, row - 1 -1), (2, 0) -&gt; (0, row - 1 - 2) …</li></ul></li><li>와 같이 이동한다. 즉, 열은 숫자 그대로 행으로 이동하고, 행은 row - 1부터 줄어들며 열로 이동한다.</li></ul></li><li><p>재귀함수를 이용하여 현재 스티커의 모양으로 왼쪽 위부터 스티커를 노트북에 붙일 수 있는지 확인한다.</p><ul><li>노트북의 범위를 돌며 현재 위치부터 스티커의 범위를 확인하여 스티커가 붙은 곳에 스티커를 붙이는 경우 불가능하다고 판별하도록 하였다.</li><li>불가능한 경우 break로 빠져나왔고, 현재 위치부터 스티커의 범위 모두 가능한 경우라면 attach함수로 현재 위치에 스티커를 붙이고 true 를 리턴했다.</li></ul></li><li><p>현재 모양으로 붙일 수 없는 경우 rotate함수로 90도 회전시킨 후, row와 col을 뒤집어 재귀를 수행한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> sticker[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> <span class="comment">// 스티커를 노트북에 붙이는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &lt; i + row; x++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = j; y &lt; j + col; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x][y] == <span class="number">0</span>)</span><br><span class="line">a[x][y] = sticker[x - i][y - j]; <span class="comment">// 노트북의 현재 위치에 붙임</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> <span class="comment">// 90도 회전시키는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">tmp[i][j] = sticker[i][j]; <span class="comment">// 임시 배열에 복사</span></span><br><span class="line"><span class="built_in">memset</span>(sticker, <span class="number">0</span>, <span class="keyword">sizeof</span>(sticker)); <span class="comment">// 스티커 초기화</span></span><br><span class="line"><span class="comment">// 행과 열을 뒤집는다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)</span><br><span class="line">&#123;</span><br><span class="line">sticker[i][j] = tmp[row - <span class="number">1</span> - j][i]; <span class="comment">// 90도 회전</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">attempt</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 모든 방향 확인 후 붙일 수 없다면 false리턴</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> possible = <span class="literal">false</span>; <span class="comment">// 붙일 수 있는지 확인</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= row &amp;&amp; m &gt;= col) <span class="comment">// 노트북 범위에 맞을때만 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">possible = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i + row &lt;= n &amp;&amp; j + col &lt;= m) <span class="comment">// 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; row; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; col; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sticker[x][y] == <span class="number">1</span> &amp;&amp; a[i + x][j + y] == <span class="number">1</span>) <span class="comment">// 스티커가 붙은 곳에 스티커를 붙이는 경우 불가능</span></span><br><span class="line">&#123; <span class="comment">// 붙일 수 없는 경우</span></span><br><span class="line">possible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!possible) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> possible = <span class="literal">false</span>; <span class="comment">// 범위를 벗어나면 불가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (possible) <span class="comment">// 붙일 수 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">attach</span>(i, j, row, col); <span class="comment">// 노트북에 붙이고 true리턴</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!possible) <span class="comment">// 현재 모양으로 붙일 수 없는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">rotate(row, col); <span class="comment">// 90도 회전</span></span><br><span class="line"><span class="keyword">if</span> (attempt(col, row, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 회전하면 row, col이 바뀌므로 바꿔서 재귀</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sticker[i][j];</span><br><span class="line"></span><br><span class="line">attempt(row, col, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">1</span>) ans++; <span class="comment">// 스티커 붙은 칸 카운트</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-18808&quot;&gt;&lt;a href=&quot;#Problem-18808&quot; class=&quot;headerlink&quot; title=&quot;Problem 18808&quot;&gt;&lt;/a&gt;Problem 18808&lt;/h1&gt;&lt;h2 id=&quot;스티커-붙이기&quot;&gt;&lt;a href=&quot;#스티
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14890번 경사로</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/26/algorithm14890/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/26/algorithm14890/</id>
    <published>2020-03-25T17:40:01.000Z</published>
    <updated>2020-03-25T17:42:02.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14890"><a href="#Problem-14890" class="headerlink" title="Problem 14890"></a>Problem 14890</h1><h2 id="경사로"><a href="#경사로" class="headerlink" title="경사로"></a>경사로</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.</p><p>오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.</p><p>다음과 같은 N=6인 경우 지도를 살펴보자.</p><p>이때, 길은 총 2N개가 있으며, 아래와 같다.</p><p>길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.</p><p>경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.<br>낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.<br>경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.<br>아래와 같은 경우에는 경사로를 놓을 수 없다.</p><p>경사로를 놓은 곳에 또 경사로를 놓는 경우<br>낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우<br>낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우<br>경사로를 놓다가 범위를 벗어나는 경우<br>L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.</p><p>경사로를 놓을 수 없는 경우는 아래와 같다.</p><p>위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.</p><p>가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.</p><p>지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14890" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14890</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6 2<br>3 3 3 3 3 3<br>2 3 3 3 3 3<br>2 2 2 3 2 3<br>1 1 1 2 2 2<br>1 1 1 3 3 1<br>1 1 2 3 3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 2<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>7</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 3<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>3</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6 1<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>check_row, check_col 배열에 행, 열 별로 지나갈 수 있는 길인지 여부를 저장한다.<ul><li>초기값을 true로 지정하여 불가능한 경우가 나오면 false로 변경하고 다음 길을 확인하는 방식으로 구현하였다.</li></ul></li><li>높이의 차가 2 이상인 경우는 불가능한 경우이므로 제외시킨다.</li><li>다음 좌표와의 높이 차를 구해 같은 높이인 경우, 높이가 낮아지는 경우, 높아지는 경우를 각각 처리했다.</li><li>cnt에 같은 높이로 이어지는 블록의 수를 기록하여 경사로의 길이와 비교 후 경사로를 놓을 수 있는지 판별하였다.<ul><li>이 때, 내려가는 경사로인 경우에는 높이가 낮아진 이후 같은 높이의 블록 수를 계산해야 하므로 check_d라는 변수에 내려가는 경사로를 거친 상태라면 true로 두어 판별하였다.</li></ul></li><li>경사로의 길이가 1로 입력된 경우 예외가 많아서 처리하기 힘들었다.</li><li>1인 경우의 예외는 코드에 주석으로 설명을 해두었다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> check_row[MAX];</span><br><span class="line"><span class="keyword">bool</span> check_col[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 평지의 수</span></span><br><span class="line">check_row[i] = <span class="literal">true</span>; <span class="comment">// 초기값 true (지나갈 수 있는 상태)</span></span><br><span class="line"><span class="keyword">bool</span> check_d = <span class="literal">false</span>; <span class="comment">// 내려가는 경사로를 거친 상태라면 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[i][j + <span class="number">1</span>] - a[i][j];</span><br><span class="line"><span class="keyword">if</span> (gap &gt; <span class="number">1</span> || gap &lt; <span class="number">-1</span>) <span class="comment">// 높이차가 2 이상이면 불가능한 경우</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gap == <span class="number">0</span>) <span class="comment">// 같은 높이인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++; <span class="comment">// 같은 높이의 개수</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt;= l) <span class="comment">// 내려가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line">&#123;  <span class="comment">// 경사로의 길이가 1인 경우는 예외</span></span><br><span class="line">check_d = <span class="literal">false</span>; <span class="comment">// 평지로 인식</span></span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">1</span>) <span class="comment">// 높이가 높아진 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 경사로가 내려가다가 바로 올라가는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt == <span class="number">1</span>)</span><br><span class="line">&#123;  <span class="comment">// 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능</span></span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">// l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt; <span class="number">1</span>) check_d = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; l) <span class="comment">// 올라가는 경사로를 놓을 수 없는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">1</span>; <span class="comment">// 높이가 바뀌었으므로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">-1</span>) <span class="comment">// 높이가 낮아졌다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 연속으로 내려가는 경사로를 두 번 놓을 수 없음</span></span><br><span class="line">&#123; <span class="comment">// 1은 예외</span></span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">check_d = <span class="literal">true</span>; <span class="comment">// 다음 높이에서 경사로의 길이를 체크</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; j == n - <span class="number">2</span> &amp;&amp; check_d) check_row[i] = <span class="literal">false</span>; <span class="comment">// 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 평지의 수</span></span><br><span class="line">check_col[j] = <span class="literal">true</span>; <span class="comment">// 초기값 true (지나갈 수 있는 상태)</span></span><br><span class="line"><span class="keyword">bool</span> check_d = <span class="literal">false</span>; <span class="comment">// 내려가는 경사로를 거친 상태라면 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[i + <span class="number">1</span>][j] - a[i][j];</span><br><span class="line"><span class="keyword">if</span> (gap &gt; <span class="number">1</span> || gap &lt; <span class="number">-1</span>) <span class="comment">// 높이차가 2 이상이면 불가능한 경우</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gap == <span class="number">0</span>) <span class="comment">// 같은 높이인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++; <span class="comment">// 같은 높이의 개수</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt;= l)  <span class="comment">// 내려가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line">&#123; <span class="comment">// 경사로의 길이가 1인 경우는 예외</span></span><br><span class="line">check_d = <span class="literal">false</span>; <span class="comment">// 다시 평지로 인식</span></span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">1</span>) <span class="comment">// 높이가 높아진 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d)  <span class="comment">// 경사로가 내려가다가 바로 올라가는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능</span></span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">//l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt; <span class="number">1</span>) check_d = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; l) <span class="comment">// 올라가는 경사로를 놓을 수 없는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">1</span>; <span class="comment">// 높이가 바뀌었으므로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">-1</span>) <span class="comment">// 높이가 낮아졌다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 연속으로 내려가는 경사로를 두 번 놓을 수 없음</span></span><br><span class="line">&#123; <span class="comment">// 1은 예외</span></span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">check_d = <span class="literal">true</span>; <span class="comment">// 다음 높이에서 경사로의 길이를 체크</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; i == n - <span class="number">2</span> &amp;&amp; check_d) check_col[j] = <span class="literal">false</span>; <span class="comment">// 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 각 행, 열 별로 지나갈 수 있는 길의 수 체크</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check_row[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "row : " &lt;&lt; i &lt;&lt; '\n'; // 디버깅용</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check_col[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "col : " &lt;&lt; i &lt;&lt; '\n'; // 디버깅용</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14890&quot;&gt;&lt;a href=&quot;#Problem-14890&quot; class=&quot;headerlink&quot; title=&quot;Problem 14890&quot;&gt;&lt;/a&gt;Problem 14890&lt;/h1&gt;&lt;h2 id=&quot;경사로&quot;&gt;&lt;a href=&quot;#경사로&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 15683번 감시</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/25/algorithm15683/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/25/algorithm15683/</id>
    <published>2020-03-24T17:10:12.000Z</published>
    <updated>2020-03-24T17:18:00.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-15683"><a href="#Problem-15683" class="headerlink" title="Problem 15683"></a>Problem 15683</h1><h2 id="감시"><a href="#감시" class="headerlink" title="감시"></a>감시</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.</p><p>1번    2번    3번    4번    5번<br>1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.</p><p>CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.</p><p>CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 ‘#’로 나타내면 아래와 같다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> # <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"># # <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>→    ←    ↑    ↓<br>CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 벽을 감시할 수 없다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 # # # #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="comment"># # 2 #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># # # # # 5</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 # # # #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment"># #</span></span><br><span class="line"><span class="comment"># # # # # 5</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> # # <span class="number">2</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"># # # # # <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> # #</span><br><span class="line"># # # # # <span class="number">5</span></span><br></pre></td></tr></table></figure><p>왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔    왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕    왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔    왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕<br>CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">6</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 2 # 3</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="comment"># 0 #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.</p><p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)</p><p>둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.</p><p>CCTV의 최대 개수는 8개를 넘지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 사각 지대의 최소 크기를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/15683" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/15683</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 6<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 1 0 6 0<br>0 0 0 0 0 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>20</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 6<br>0 0 0 0 0 0<br>0 2 0 0 0 0<br>0 0 0 0 6 0<br>0 6 0 0 2 0<br>0 0 0 0 0 0<br>0 0 0 0 0 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>15</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 6<br>1 0 0 0 0 0<br>0 1 0 0 0 0<br>0 0 1 0 0 0<br>0 0 0 1 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>6</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6 6<br>1 0 0 0 0 0<br>0 1 0 0 0 0<br>0 0 1 5 0 0<br>0 0 5 1 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>2</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>1 7<br>0 1 2 3 4 5 6</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>0</p><h3 id="예제-입력-6"><a href="#예제-입력-6" class="headerlink" title="예제 입력 6"></a>예제 입력 6</h3><p>3 7<br>4 0 0 0 0 0 0<br>0 0 0 2 0 0 0<br>0 0 0 0 0 0 4</p><h3 id="예제-출력-6"><a href="#예제-출력-6" class="headerlink" title="예제 출력 6"></a>예제 출력 6</h3><p>0</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>부르트 포스 문제로 모든 경우를 다 확인해 최솟값을 구하면 된다.</li><li>나는 see라는 함수를 만들어서 현재 좌표에서 현재 방향으로 감시가능한 구역 체크하도록 했다.<ul><li>인자로 좌표, 방향, flag, num 을 받는다.</li><li>flag는 1인 경우 감시 구역을 체크하고 아니라면 체크된 감시 구역을 해제한다.</li><li>여기서 감시구역을 num으로 체크하는데, num은 7부터 감시카메라의 개수만큼 증가한다.</li><li>이렇게 num을 준 이유는 1~6번은 사용중이고, 다른 감시카메라와의 중복 감시구역을 파악하기 위해서다.</li><li>flag가 1이 아니라면, 현재 방향의 num으로 체크된 구역만 0으로 바꾸어 체크를 해제한다.</li></ul></li><li>이후 재귀함수로 입력받은 감시카메라의 개수만큼, 각 감시카메라의 종류가 볼 수 있는 방향을 모두 체크한다.</li><li>모든 감시카메라 확인 후 0인 구역의 개수가 사각지대의 개수이다. 이것의 최솟값을 구한다.</li></ul><hr><ul><li>3번 감시카메라를 착각해서 감시 방향을 3번만 확인하면 된다고 생각하여 이것을 찾아내는데 시간을 많이 썻다.</li><li>3번 감시카메라도 네 방향을 모두 보아야 한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dir, <span class="keyword">int</span> flag, <span class="keyword">int</span> num)</span> <span class="comment">// 현재 좌표에서 현재 방향으로 감시가능한 구역 체크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="comment">// 감시 구역 체크</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">max</span>(n, m); i++) <span class="comment">// 현재 방향으로 벽이 아닌 모든 구역 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir] * i;</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir] * i;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) a[nx][ny] = num; <span class="comment">// 0인 경우 인자로 받은 num으로 넣어서 구분</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 감시 구역 해제</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">max</span>(n, m); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir] * i;</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir] * i;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(a[nx][ny] == num) a[nx][ny] = <span class="number">0</span>; <span class="comment">// num 체크 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// 확인용 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">size</span>) <span class="comment">// 모든 감시카메라 확인 후</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">0</span>)</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; ans) ans = cnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = v[index].first.first;</span><br><span class="line"><span class="keyword">int</span> y = v[index].first.second;</span><br><span class="line"><span class="keyword">int</span> type = v[index].second;</span><br><span class="line"><span class="keyword">int</span> num = index + <span class="number">7</span>; <span class="comment">// 1~6은 사용중</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) <span class="comment">// 1번 경우 네 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 감시구역 체크</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num); <span class="comment">// 체크 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">// 2번 경우 양 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 현재 방향 체크</span></span><br><span class="line">see(x, y, k + <span class="number">2</span>, <span class="number">1</span>, num); <span class="comment">// 한칸 건너 뛰고 반대방향 체크</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">see(x, y, k + <span class="number">2</span>, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) <span class="comment">// 3번 경우 직각 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 현재 방향 체크</span></span><br><span class="line">see(x, y, k + <span class="number">1</span> &gt; <span class="number">3</span> ? <span class="number">0</span> : k + <span class="number">1</span>, <span class="number">1</span>, num); <span class="comment">// 현재 방향과 직각을 이루는 방향 확인</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">see(x, y, k + <span class="number">1</span> &gt; <span class="number">3</span> ? <span class="number">0</span> : k + <span class="number">1</span>, <span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) <span class="comment">// 4번 경우 세 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l == k) <span class="keyword">continue</span>; <span class="comment">// 현재 방향 빼고 나머지 세 방향 확인</span></span><br><span class="line">see(x, y, l, <span class="number">1</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l == k) <span class="keyword">continue</span>;</span><br><span class="line">see(x, y, l, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">5</span>) <span class="comment">// 5번 경우 전 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num);</span><br><span class="line"></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] &gt;= <span class="number">1</span> &amp;&amp; a[i][j] &lt;= <span class="number">5</span>)</span><br><span class="line">&#123; <span class="comment">// 감시카메라의 위치 , 종류 저장</span></span><br><span class="line">v.push_back(make_pair(make_pair(i, j), a[i][j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-15683&quot;&gt;&lt;a href=&quot;#Problem-15683&quot; class=&quot;headerlink&quot; title=&quot;Problem 15683&quot;&gt;&lt;/a&gt;Problem 15683&lt;/h1&gt;&lt;h2 id=&quot;감시&quot;&gt;&lt;a href=&quot;#감시&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14500번 테트로미노</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/24/algorithm14500/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/24/algorithm14500/</id>
    <published>2020-03-23T15:12:12.000Z</published>
    <updated>2020-03-25T05:34:58.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14500"><a href="#Problem-14500" class="headerlink" title="Problem 14500"></a>Problem 14500</h1><h2 id="테트로미노"><a href="#테트로미노" class="headerlink" title="테트로미노"></a>테트로미노</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.</p><p>정사각형은 서로 겹치면 안 된다.<br>도형은 모두 연결되어 있어야 한다.<br>정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.<br>정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.</p><p>아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.</p><p>테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.</p><p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)</p><p>둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14500" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14500</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 5<br>1 2 3 4 5<br>5 4 3 2 1<br>2 3 4 5 6<br>6 5 4 3 2<br>1 2 1 2 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>19</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4 5<br>1 2 3 4 5<br>1 2 3 4 5<br>1 2 3 4 5<br>1 2 3 4 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>20</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 10<br>1 2 1 2 1 2 1 2 1 2<br>2 1 2 1 2 1 2 1 2 1<br>1 2 1 2 1 2 1 2 1 2<br>2 1 2 1 2 1 2 1 2 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>7</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>5가지의 경우 중 ㅜ 모양을 제외한 4가지 경우는 한 점에서 시작하여 3개의 칸을 연속해서 방문하는 형태이므로 dfs를 통해 구할 수 있다.<ul><li>dfs를 사용하여 네 칸을 연속해서 방문하는 경우 네 칸의 최댓값을 구한다.</li></ul></li><li>나머지 ㅜ 모양은 3개의 칸을 연속해서 방문하지 않으므로 경우 dfs로는 구할 수 없다.<ul><li>따라서 반복문에 직접 구현하였다.</li><li>ㅗ, ㅜ 모양인 경우 j + 2 &lt; m 일 때를 기준으로 처리하였고,</li><li>ㅓ, ㅏ 모양인 경우 i + 2 &lt; n 일 때를 기준으로 처리하였다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> <span class="comment">// 한 점에서 시작하여 3개의 칸을 연속해서 확인하는 경우 모두 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; ans) ans = sum; <span class="comment">// 네 칸의 합의 최댓값</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, sum + a[x][y], index + <span class="number">1</span>);</span><br><span class="line">check[nx][ny] = <span class="literal">false</span>; <span class="comment">// 방문 처리 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">check[x][y] = <span class="literal">false</span>; <span class="comment">// 시작점 방문 처리 해제</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// dfs로 구할 수 없는 한 가지 경우 처리</span></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">2</span> &lt; m) <span class="comment">//  ㅗ, ㅜ 모양 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = a[i][j] + a[i][j + <span class="number">1</span>] + a[i][j + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">2</span> &lt; n) <span class="comment">// ㅓ, ㅏ 모양 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = a[i][j] + a[i + <span class="number">1</span>][j] + a[i + <span class="number">2</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14500&quot;&gt;&lt;a href=&quot;#Problem-14500&quot; class=&quot;headerlink&quot; title=&quot;Problem 14500&quot;&gt;&lt;/a&gt;Problem 14500&lt;/h1&gt;&lt;h2 id=&quot;테트로미노&quot;&gt;&lt;a href=&quot;#테트로미
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16234번 인구 이동</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/23/algorithm16234/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/23/algorithm16234/</id>
    <published>2020-03-22T17:31:12.000Z</published>
    <updated>2020-03-22T17:38:39.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16234"><a href="#Problem-16234" class="headerlink" title="Problem 16234"></a>Problem 16234</h1><h2 id="인구-이동"><a href="#인구-이동" class="headerlink" title="인구 이동"></a>인구 이동</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.</p><p>오늘부터 인구 이동이 시작되는 날이다.</p><p>인구 이동은 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.</p><ul><li>국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루동안 연다.</li><li>위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.</li><li>국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.</li><li>연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.</li><li>연합을 해체하고, 모든 국경선을 닫는다.<br>각 나라의 인구수가 주어졌을 때, 인구 이동이 몇 번 발생하는지 구하는 프로그램을 작성하시오.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)</p><p>둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)</p><p>인구 이동이 발생하는 횟수가 2,000번 보다 작거나 같은 입력만 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>인구 이동이 몇 번 발생하는지 첫째 줄에 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16234" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16234</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2 20 50<br>50 30<br>20 40</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>2 40 50<br>50 30<br>20 40</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>0</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>2 20 50<br>50 30<br>30 40</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>1</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>3 5 10<br>10 15 20<br>20 30 25<br>40 22 10</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>2</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>4 10 50<br>10 100 20 90<br>80 100 60 70<br>70 20 30 40<br>50 20 100 10</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>dfs를 통해 현재 국경을 공유하는 나라를 하나의 그룹으로 연합의 그룹번호를 매긴다.</li><li>이후 각 그룹에 속하는 나라의 수를 cnt에 카운트하고, 각 그룹의 속하는 나라의 인구수의 합을 sum에 저장한다.</li><li>또한 벡터v에 같은 그룹에 해당하는 나라끼리 좌표를 저장한다.</li><li>cnt[k]가 2이상이라면 k그룹에 속한 나라끼리 국경을 공유했다는 뜻이 된다.<ul><li>따라서, cnt[k]가 2이상인 경우 v[k]에 저장된 각 나라의 좌표에 접근하여 (sum[k] / cnt[k])를 통해 인구 이동을 계산한다.</li><li>이때, 계산 후에 벡터를 초기화한다.</li></ul></li><li>반복문이 1회 반복될 때마다 인구 이동 횟수를 카운트한다.</li><li>국경을 공유하는 나라가 더 이상 없다면 반복문을 빠져나가고 종료한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> group[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[MAX + <span class="number">1</span>]; <span class="comment">// 각 그룹에 속하는 나라의 수</span></span><br><span class="line"><span class="keyword">int</span> sum[MAX + <span class="number">1</span>]; <span class="comment">// 각 그룹의 속하는 나라의 인구수의 합</span></span><br><span class="line"><span class="keyword">int</span> n, l, r;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> <span class="comment">// dfs를 통해 연합의 그룹번호를 매긴다.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (group[x][y] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">group[x][y] = num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[x][y] - a[nx][ny];</span><br><span class="line"><span class="keyword">if</span> (gap &lt; <span class="number">0</span>) gap = -gap;</span><br><span class="line"><span class="keyword">if</span> (gap &gt;= l &amp;&amp; gap &lt;= r) <span class="comment">//  나라의 인구 차이가 L명 이상, R명 이하라면</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, num); <span class="comment">// 같은 그룹으로 묶는다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(group, <span class="number">0</span>, <span class="keyword">sizeof</span>(group)); <span class="comment">// 그룹 번호 초기화</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (group[i][j] == <span class="number">0</span>) <span class="comment">// 그룹에 속하지 않는 나라인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(i, j, ++num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); <span class="comment">// 각 그룹에 속하는 나라의 수 초기화</span></span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum)); <span class="comment">// 각 그룹의 속하는 나라의 인구수의 합 초기화</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cnt[group[i][j]]++;</span><br><span class="line">sum[group[i][j]] += a[i][j];</span><br><span class="line">v[group[i][j]].push_back(make_pair(i, j)); <span class="comment">// 같은 그룹에 해당하는 나라의 좌표를 저장</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> check = <span class="literal">true</span>; <span class="comment">// 국경선을 공유하는 나라가 있는지 판별</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX; k++) <span class="comment">// 경우는 1부터 10000까지</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[k] &gt;= <span class="number">2</span>) <span class="comment">// 그룹에 속한 나라의 수가 2이상이면 국경을 공유한 것.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[k].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = v[k][i].first;</span><br><span class="line"><span class="keyword">int</span> y = v[k][i].second;</span><br><span class="line"></span><br><span class="line">a[x][y] = sum[k] / cnt[k]; <span class="comment">// 인구 이동 계산</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">check = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">v[k].<span class="built_in">clear</span>(); <span class="comment">// 벡터 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (check) <span class="keyword">break</span>; <span class="comment">// 국경을 공유하는 나라가 없다면 종료</span></span><br><span class="line">ans++; <span class="comment">// 인구 이동 횟수 카운트</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16234&quot;&gt;&lt;a href=&quot;#Problem-16234&quot; class=&quot;headerlink&quot; title=&quot;Problem 16234&quot;&gt;&lt;/a&gt;Problem 16234&lt;/h1&gt;&lt;h2 id=&quot;인구-이동&quot;&gt;&lt;a href=&quot;#인구-이
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14503번 로봇 청소기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/21/algorithm14503/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/21/algorithm14503/</id>
    <published>2020-03-20T17:05:12.000Z</published>
    <updated>2020-03-20T17:08:33.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14503"><a href="#Problem-14503" class="headerlink" title="Problem 14503"></a>Problem 14503</h1><h2 id="로봇-청소기"><a href="#로봇-청소기" class="headerlink" title="로봇 청소기"></a>로봇 청소기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.</p><p>로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.</p><p>로봇 청소기는 다음과 같이 작동한다.</p><ol><li>현재 위치를 청소한다.</li><li>현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.<ol><li>왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.</li><li>왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.</li><li>네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.</li><li>네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.</li></ol></li></ol><p>로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)</p><p>둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.</p><p>셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.</p><p>로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>로봇 청소기가 청소하는 칸의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14503" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14503</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 1 0<br>1 1 1<br>1 0 1<br>1 1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>11 10<br>7 4 0<br>1 1 1 1 1 1 1 1 1 1<br>1 0 0 0 0 0 0 0 0 1<br>1 0 0 0 1 1 1 1 0 1<br>1 0 0 1 1 0 0 0 0 1<br>1 0 1 1 0 0 0 0 0 1<br>1 0 0 0 0 0 0 0 0 1<br>1 0 0 0 0 0 0 1 0 1<br>1 0 0 0 0 0 1 1 0 1<br>1 0 0 0 0 0 1 1 0 1<br>1 0 0 0 0 0 0 0 0 1<br>1 1 1 1 1 1 1 1 1 1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>57</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀 함수를 통해 문제의 조건을 그대로 구현해야 한다.</li><li>청소를 완료한 구역은 2를 저장하여 구분하였고, 0, 1, 2, 3이 북, 서, 남, 동이므로 dx, dy에 순서를 맞춰주었다.</li><li>먼저 청소하지 않은 구역이면 청소를 하고 방의 개수를 카운트한다.</li><li>calc_dir이라는 0, 1, 2, 3 다음 다시 0이 되도록 계산을 해주는 함수를 구현하여<ul><li>왼쪽부터 4방향을 확인하는데, 왼쪽으로 회전하는 것은 현재 방향에서 -1을 해주면 된다.</li><li>바라보는 방향의 방이 청소가 안된 빈칸이라면 재귀를 수행하여 다음 칸으로 이동하고, 이후 나머지 방향은 추가로 검사하지 않는다.</li></ul></li><li>위의 과정이 끝나 네 방향 모두 청소가 되었거나 벽이라면<ul><li>현재 방향에서 -2를 해주어 후진 방향을 설정하고 후진할 방향이 벽이라면 정답을 출력 후 종료,</li><li>벽이 아니라면 후진을 한다. 이 때, 원래의 방향을 유지하며 후진을 수행한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;; <span class="comment">// 0  : 북, 1 : 서, 2 : 남, 3 : 동</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_dir</span><span class="params">(<span class="keyword">int</span> dir, <span class="keyword">int</span> rotation)</span> <span class="comment">// 청소기의 회전</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = dir + rotation;</span><br><span class="line"><span class="keyword">if</span> (res &gt; <span class="number">3</span>) res -= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(res &lt; <span class="number">0</span>) res += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>) <span class="comment">// 청소하지 않았다면</span></span><br><span class="line">&#123;</span><br><span class="line">a[x][y] = <span class="number">2</span>; <span class="comment">// 청소</span></span><br><span class="line">ans++; <span class="comment">// 카운트</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span> (cnt--) <span class="comment">// 4방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line">dir = calc_dir(dir, <span class="number">-1</span>); <span class="comment">// 왼쪽으로 회전</span></span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) <span class="comment">// 빈칸이라면 청소</span></span><br><span class="line">&#123;</span><br><span class="line">go(nx, ny, dir);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 다음 칸으로 넘어간 이후 나머지 방향은 검사 x</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 검사 끝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네 방향 모두 청소가 이미 되어있거나 벽인 경우</span></span><br><span class="line"><span class="keyword">int</span> rear = calc_dir(dir, <span class="number">-2</span>); <span class="comment">// 후진 방향 설정</span></span><br><span class="line"><span class="keyword">int</span> nx = x + dx[rear];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[rear];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span>) <span class="comment">// 후진도 못한다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 출력 후 종료</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 후진한다</span></span><br><span class="line">&#123;</span><br><span class="line">go(nx, ny, dir); <span class="comment">// 방향은 유지</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sx, sy, dir;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; dir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">go(sx, sy, dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14503&quot;&gt;&lt;a href=&quot;#Problem-14503&quot; class=&quot;headerlink&quot; title=&quot;Problem 14503&quot;&gt;&lt;/a&gt;Problem 14503&lt;/h1&gt;&lt;h2 id=&quot;로봇-청소기&quot;&gt;&lt;a href=&quot;#로봇-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2580번 스도쿠</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/19/algorithm2580/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/19/algorithm2580/</id>
    <published>2020-03-19T01:30:12.000Z</published>
    <updated>2020-03-19T01:39:02.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2580"><a href="#Problem-2580" class="headerlink" title="Problem 2580"></a>Problem 2580</h1><h2 id="스도쿠"><a href="#스도쿠" class="headerlink" title="스도쿠"></a>스도쿠</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 몇 몇 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.</p><p>0 3 5 4 6 9 2 7 8<br>7 8 2 1 0 5 6 0 9<br>0 6 0 2 7 8 1 3 5<br>3 2 1 0 4 6 8 9 7<br>8 0 4 9 1 3 5 0 6<br>5 9 6 8 2 0 4 1 3<br>9 1 7 6 5 2 0 8 0<br>6 0 3 7 0 1 9 5 2<br>2 5 8 3 9 4 7 6 0</p><p>나머지 빈 칸을 채우는 방식은 다음과 같다.</p><ol><li>각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li><li>굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li></ol><p>위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.</p><p><strong>1</strong> 3 5 4 6 9 2 7 8</p><p>또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.</p><p>4 6 9<br>1 <strong>3</strong> 5<br>2 7 8</p><p>이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.</p><p>1 3 5 4 6 9 2 7 8<br>7 8 2 1 3 5 6 4 9<br>4 6 9 2 7 8 1 3 5<br>3 2 1 5 4 6 8 9 7<br>8 7 4 9 1 3 5 2 6<br>5 9 6 8 2 7 4 1 3<br>9 1 7 6 5 2 3 8 4<br>6 4 3 7 8 1 9 5 2<br>2 5 8 3 9 4 7 6 1</p><p>게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.</p><p>스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2580" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2580</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>0 3 5 4 6 9 2 7 8<br>7 8 2 1 0 5 6 0 9<br>0 6 0 2 7 8 1 3 5<br>3 2 1 0 4 6 8 9 7<br>8 0 4 9 1 3 5 0 6<br>5 9 6 8 2 0 4 1 3<br>9 1 7 6 5 2 0 8 0<br>6 0 3 7 0 1 9 5 2<br>2 5 8 3 9 4 7 6 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1 3 5 4 6 9 2 7 8<br>7 8 2 1 3 5 6 4 9<br>4 6 9 2 7 8 1 3 5<br>3 2 1 5 4 6 8 9 7<br>8 7 4 9 1 3 5 2 6<br>5 9 6 8 2 7 4 1 3<br>9 1 7 6 5 2 3 8 4<br>6 4 3 7 8 1 9 5 2<br>2 5 8 3 9 4 7 6 1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>각각의 동일한 행, 열, 3 * 3 사각형에 중복되는 수가 들어가지 않도록 하여 백트래킹을 하면 된다.</li><li>입력을 받으며 각 행에 존재하는 수를 check배열에 행과 열을 구분하여 체크한다.<ul><li>이 때, 사각형에 존재하는 수를 체크하는 방법은 3x3 사각형을 순서대로 0 ~ 8번이라고 정의하고</li><li>현재 행, 열에 대해 (행 / 3) * 3 + (열 / 3)을 수행하면 현재 몇 번째 사각형인지 얻을 수 있다.</li></ul></li><li>이제 재귀 함수를 통해 백트래킹을 구현한다.</li><li>9행 9열을 0 ~ 80까지로 표현하여 현재 행은 (행 / 9), 현재 열은 (열 % 9)로 구할 수 있다.</li><li>현재 입력 배열의 수가 0인 경우(빈칸) 같은 행, 열, 사각형에 없는 수만 선택하여 수를 채우고 재귀를 수행한다.</li><li>index가 81이 되었다면 답을 구한 것이므로 출력 후 프로그램을 종료한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> check_row[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check_col[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check_square[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x / <span class="number">3</span>) * <span class="number">3</span> + (y / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">81</span>) <span class="comment">// 답을 구했으면 출력 후 프로그램 종료</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = index / <span class="number">9</span>; <span class="comment">// 0 ~ 80 을 행, 열로 변환</span></span><br><span class="line"><span class="keyword">int</span> y = index % <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check_row[x][i] &amp;&amp; !check_col[i][y] &amp;&amp; !check_square[square(x, y)][i]) <span class="comment">// 같은 행, 열, 사각형에 없는 수만 확인</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[x][i] = check_col[i][y] = check_square[square(x, y)][i] = <span class="literal">true</span>; <span class="comment">// 수를 넣었으므로 체크</span></span><br><span class="line">a[x][y] = i;</span><br><span class="line">go(index + <span class="number">1</span>); <span class="comment">// 수를 넣고 넘어감</span></span><br><span class="line">a[x][y] = <span class="number">0</span>; <span class="comment">// 확인 후 초기화</span></span><br><span class="line">check_row[x][i] = check_col[i][y] = check_square[square(x, y)][i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">go(index + <span class="number">1</span>); <span class="comment">// 0이 아니라면 계속 진행</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">check_row[i][a[i][j]] = <span class="literal">true</span>; <span class="comment">// i번째 행에 존재하는 수 체크</span></span><br><span class="line">check_col[a[i][j]][j] = <span class="literal">true</span>; <span class="comment">// j번째 열에 존재하는 수 체크</span></span><br><span class="line">check_square[square(i, j)][a[i][j]] = <span class="literal">true</span>; <span class="comment">// n번째 사각형에 존재하는 수 체크</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2580&quot;&gt;&lt;a href=&quot;#Problem-2580&quot; class=&quot;headerlink&quot; title=&quot;Problem 2580&quot;&gt;&lt;/a&gt;Problem 2580&lt;/h1&gt;&lt;h2 id=&quot;스도쿠&quot;&gt;&lt;a href=&quot;#스도쿠&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1201번 NMK</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/18/algorithm1201/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/18/algorithm1201/</id>
    <published>2020-03-18T05:01:12.000Z</published>
    <updated>2020-03-18T05:07:08.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1201"><a href="#Problem-1201" class="headerlink" title="Problem 1201"></a>Problem 1201</h1><h2 id="NMK"><a href="#NMK" class="headerlink" title="NMK"></a>NMK</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>1부터 N까지의 수를 한 번씩 이용해서 최대 부분 증가 수열의 길이가 M이고, 최대 부분 감소 수열의 길이가 K인 수열을 출력한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N M K가 주어진다. N은 500보다 작거나 같은 자연수, M과 K는 N보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 정답을 출력한다. 정답이 없다면-1을 출력한다</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1201" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1201</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2 1 4 3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>적어도 m개는 증가수열에 포함되어야 하고 적어도 k개는 감소수열에 포함되어야 한다. 두 수열은 최대 1개의 정수를 공유 가능</p><ul><li>[ex) m = 3, k = 2 -&gt; 1 2 4 3 과 같이 3개가 증가하고 이어서 4를 공유하여 2개가 감소하는 경우 최소 길이]</li><li>따라서 n &gt;= m + k -1 를 만족해야 한다.</li></ul></li><li><p>예를 들어, 1 2 3 4 5 6 7 8 9를 4개씩 묶는다고 생각해보자.</p><ul><li>(1 2 3 4)(5 6 7 8)(9) 와 같이 묶고, 각 구간을 뒤집는다.</li><li>(4 3 2 1)(8 7 6 5)(9) 가 될 것이다. 이 경우, 각 구간 내에서는 증가하는 부분이 없으므로 구간의 개수가 증가하는 최대 부분수열의 개수가 된다. 또한 구간의 최대 길이가 감소한는 부분 수열의 최대 길이가 될 것이다.</li></ul></li><li><p>감소하는 부분 수열의 길이를 k가 되도록 하기 위해 오름차순으로 정렬된 k개의 수에 대해 앞에서부터 한번은 최대 k개가 되도록 묶어 뒤집어 준다.</p></li><li><p>또한 m개의 증가 수열을 만들어 주기 위해 뒤집힌 묶음의 개수가 m개가 되어야 한다.</p></li><li><p>즉, m개의 구간을 묶을 때, 적어도 한 번은 k개가 되도록 수를 묶어 모든 구간을 뒤집어 주면 정답을 구할 수 있다.</p></li><li><p>이때, n이 m * k보다 커지게 된다면, m개의 구간을 k개씩 묶고 나서도 1개 이상의 수가 남기 때문에 이 경우 정답을 구할 수 없다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; m + k - <span class="number">1</span> || n &gt; m * k) <span class="comment">// 불가능한 범위 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">a[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 구간을 나눌 지점을 저장할 벡터</span></span><br><span class="line">s.push_back(<span class="number">0</span>); <span class="comment">// 첫 구간의 시작</span></span><br><span class="line">s.push_back(k); <span class="comment">// 첫 구간의 끝</span></span><br><span class="line">n -= k; <span class="comment">// 남은 수의 개수</span></span><br><span class="line">m--; <span class="comment">// 남은 구간 수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q = m == <span class="number">0</span> ? <span class="number">1</span> : n / m; <span class="comment">// 남은 구간이 없다면 1</span></span><br><span class="line"><span class="keyword">int</span> r = m == <span class="number">0</span> ? <span class="number">0</span> : n % m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 남은 구간 수 만큼</span></span><br><span class="line">&#123; <span class="comment">// r(나머지)가 0이 될때까지 각 구간에 1씩 추가한다.</span></span><br><span class="line">s.push_back(s.back() + q + (r &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));  <span class="comment">// 마지막 원소에 나눌 구간 크기만큼 더하여 추가</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0</span>) r--; <span class="comment">// 나머지 감소</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">reverse(a.<span class="built_in">begin</span>() + s[i], a.<span class="built_in">begin</span>() + s[i + <span class="number">1</span>]); <span class="comment">// s에 저장된 구간으로 나누어 뒤집음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1201&quot;&gt;&lt;a href=&quot;#Problem-1201&quot; class=&quot;headerlink&quot; title=&quot;Problem 1201&quot;&gt;&lt;/a&gt;Problem 1201&lt;/h1&gt;&lt;h2 id=&quot;NMK&quot;&gt;&lt;a href=&quot;#NMK&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

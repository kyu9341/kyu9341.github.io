<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-02-17T03:25:57.877Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 16929번 Two Dots</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/</id>
    <published>2020-02-17T03:24:28.000Z</published>
    <updated>2020-02-17T03:25:57.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16929"><a href="#Problem-16929" class="headerlink" title="Problem 16929"></a>Problem 16929</h1><h2 id="Two-Dots"><a href="#Two-Dots" class="headerlink" title="Two Dots"></a>Two Dots</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>Two Dots는 Playdots, Inc.에서 만든 게임이다. 게임의 기초 단계는 크기가 N×M인 게임판 위에서 진행된다.</p><p>각각의 칸은 색이 칠해진 공이 하나씩 있다. 이 게임의 핵심은 같은 색으로 이루어진 사이클을 찾는 것이다.</p><p>다음은 위의 게임판에서 만들 수 있는 사이클의 예시이다.</p><p>점 k개 d1, d2, …, dk로 이루어진 사이클의 정의는 아래와 같다.</p><ul><li>모든 k개의 점은 서로 다르다.</li><li>k는 4보다 크거나 같다.</li><li>모든 점의 색은 같다.</li><li>모든 1 ≤ i ≤ k-1에 대해서, di와 di+1은 인접하다. 또, dk와 d1도 인접해야 한다. 두 점이 인접하다는 것은 각각의 점이 들어있-는 칸이 변을 공유한다는 의미이다.</li></ul><p>게임판의 상태가 주어졌을 때, 사이클이 존재하는지 아닌지 구해보자.</p><p>2 ≤ N, M ≤ 50</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판의 크기 N, M이 주어진다. 둘째 줄부터 N개의 줄에 게임판의 상태가 주어진다. 게임판은 모두 점으로 가득차 있고, 게임판의 상태는 점의 색을 의미한다. 점의 색은 알파벳 대문자 한 글자이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>사이클이 존재하는 경우에는 “Yes”, 없는 경우에는 “No”를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 4<br>AAAA<br>ABCA<br>AAAA</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>Yes</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 4<br>AAAA<br>ABCA<br>AADA</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>No</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>Yes</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>Yes</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>No</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>문제에서 주어진 조건에 맞는 사이클이 형성되는지 찾는 문제이다. dfs를 통해 해결할 수 있다.</p></li><li><p>방문 여부를 체크할 배열과 탐색을 시작한 점부터 이동한 거리를 나타낼 배열을 선언한다.</p></li><li><p>인접한 같은 색깔의 점인 경우 dfs를 수행한다.</p><ul><li>이때, 사이클을 이루는지 여부를 확인하는 방법은 다음과 같다.<ul><li>cnt변수를 탐색을 진행할 때마다 1씩 증가시킨다.</li><li>처음 방문하게 되는 점의 dist배열에 현재 cnt를 저장한다.</li><li>재귀를 수행할 때 이미 방문했던 노드이며, cnt - dist[x][y] &gt;= 4 인 경우 사이클이 형성된다.</li></ul></li></ul></li><li><p>사이클이 형성되지 않는 경우</p></li></ul><p><img src="https://kyu9341.github.io/img/cycle2.png" alt="cycle"></p><ul><li>사이클이 형성되는 경우</li></ul><p><img src="https://kyu9341.github.io/img/cycle1.png" alt="cycle"></p><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> color[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">// 시작점부터 이동한 거리</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 게임판의 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check[x][y]) <span class="comment">// 이미 방문했던 노드인데</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt - dist[x][y] &gt;= <span class="number">4</span>) <span class="comment">// 이동 횟수에서 현재 위치에 저장된 시작점과의 거리 차가 4 이상 = 싸이클</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line">dist[x][y] = cnt; <span class="comment">// 현재 x,y가 시작점에서 몇번 이동했는지 저장, 시작점은 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (color[nx][ny] == color[x][y]) <span class="comment">// 같은 색깔의 점인 경우(방문여부는 관계x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(nx, ny, cnt + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">color[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"No"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>))</span><br><span class="line">ans = <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16929&quot;&gt;&lt;a href=&quot;#Problem-16929&quot; class=&quot;headerlink&quot; title=&quot;Problem 16929&quot;&gt;&lt;/a&gt;Problem 16929&lt;/h1&gt;&lt;h2 id=&quot;Two-Dots&quot;&gt;&lt;a href=&quot;#T
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1707번 이분 그래프</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/</id>
    <published>2020-02-15T11:05:15.000Z</published>
    <updated>2020-02-16T04:44:13.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1707"><a href="#Problem-1707" class="headerlink" title="Problem 1707"></a>Problem 1707</h1><h2 id="이분-그래프"><a href="#이분-그래프" class="headerlink" title="이분 그래프"></a>이분 그래프</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.</p><p>그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V(1≤V≤20,000)와 간선의 개수 E(1≤E≤200,000)가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호가 빈 칸을 사이에 두고 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1707" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1707</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2<br>3 2<br>1 3<br>2 3<br>4 4<br>1 2<br>2 3<br>3 4<br>4 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>YES<br>NO</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그래프를 다음과 같이 A와 B로 나눌 수 있으면 <strong>이분 그래프</strong> 라고 한다.</li></ul><p><img src="https://kyu9341.github.io/img/bipartite_graph.png" alt="bipartite_graph"></p><ul><li>A에 포함된 정점끼리 연결된 간선이 없음</li><li>B에 포함된 정점끼리 연결된 간선이 없음</li><li>모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에</li></ul><hr><ul><li><p>check배열을 bool타입 대신 int형으로 선언하여 방문하지 않은 노드는 0, 방문한 노드인데 1번 그룹이라면 1, 2번 그룹이라면 2로 저장한다.</p><ul><li>(dfs or bfs)를 통해 탐색을 수행하며 다음 노드로 넘어가면 그룹을 바꿔서 지정해준다. 이때 다음에 방문한 노드가 같은 그룹에 속한 노드라면 이분 그래프가 아니다.</li></ul></li><li><p>(dfs or bfs)에서 다음 노드가 방문하지 않은 노드라면 다음 노드로 재귀 호출하며 현재 1번 그룹이라면 다음은 2번을 넘겨주고 현재 2번이라면 1번을 넘겨준다.</p></li><li><p>다음 노드가 방문을 했던 노드인데 현재 노드와 같은 그룹이라면 이분 그래프가 아니다.</p></li><li><p>각 테스트케이스를 시작할 때마다 인접 노드와 방문 내역을 초기화 해야한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">20001</span>];</span><br><span class="line"><span class="keyword">int</span> check[<span class="number">20001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 0 : 방문 x, 1 : 1번 그룹에 포함, 2 : 2번 그룹에 포함</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c)</span> <span class="comment">// c : 다음 방문할 노드의 그룹 ( 1 or 2 ) , 이분그래프이면 true, 아니면 false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = c; <span class="comment">// c 그룹 방문 처리</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i]; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (!check[next]) <span class="comment">// 다음 정점을 방문 안했으면 동작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dfs(next, <span class="number">3</span> - c)) <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// false를 리턴받았으면 false리턴</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[next] == check[node]) <span class="comment">// 다음 정점이 이미 방문했던 정점인데 현재 정점과 같은 그룹이면 이분그래프가 아님</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">check[start] = c; <span class="comment">// 그룹 지정</span></span><br><span class="line">q.push(start); <span class="comment">// 첫 노드 push</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">3</span> - check[node];</span><br><span class="line">check[next] = c; <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1로 방문 처리</span></span><br><span class="line">q.push(next); <span class="comment">// 방문처리하며 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[node] == check[next])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].<span class="built_in">clear</span>(); <span class="comment">// 인접 노드 초기화</span></span><br><span class="line">check[i] = <span class="number">0</span>; <span class="comment">// 방문 내역 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">a[n].push_back(m);</span><br><span class="line">a[m].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) <span class="comment">// 모든 정점을 확인하여 이분 그래프가 아닌 경우가 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="number">0</span>) <span class="comment">// 아직 방문 안한 노드에 대해서 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bfs(i, <span class="number">1</span>) == <span class="literal">false</span>) <span class="comment">// dfs(i, 1) 도 가능</span></span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1707&quot;&gt;&lt;a href=&quot;#Problem-1707&quot; class=&quot;headerlink&quot; title=&quot;Problem 1707&quot;&gt;&lt;/a&gt;Problem 1707&lt;/h1&gt;&lt;h2 id=&quot;이분-그래프&quot;&gt;&lt;a href=&quot;#이분-그래프&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11052번 카드 구매하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/09/algorithm11052/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/09/algorithm11052/</id>
    <published>2020-02-09T10:32:18.000Z</published>
    <updated>2020-02-24T12:49:15.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11052"><a href="#Problem-11052" class="headerlink" title="Problem 11052"></a>Problem 11052</h1><h2 id="카드-구매하기"><a href="#카드-구매하기" class="headerlink" title="카드 구매하기"></a>카드 구매하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.</p><p>PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 아이디와 얼굴이 적혀있는 카드이다. 각각의 카드에는 등급을 나타내는 색이 칠해져 있고, 다음과 같이 8가지가 있다.</p><ul><li>전설카드</li><li>레드카드</li><li>오렌지카드</li><li>퍼플카드</li><li>블루카드</li><li>청록카드</li><li>그린카드</li><li>그레이카드</li></ul><p>카드는 카드팩의 형태로만 구매할 수 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, … 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재한다.</p><p>민규는 카드의 개수가 적은 팩이더라도 가격이 비싸면 높은 등급의 카드가 많이 들어있을 것이라는 미신을 믿고 있다. 따라서, 민규는 돈을 최대한 많이 지불해서 카드 N개 구매하려고 한다. 카드가 i개 포함된 카드팩의 가격은 Pi원이다.</p><p>예를 들어, 카드팩이 총 4가지 종류가 있고, P1 = 1, P2 = 5, P3 = 6, P4 = 7인 경우에 민규가 카드 4개를 갖기 위해 지불해야 하는 금액의 최댓값은 10원이다. 2개 들어있는 카드팩을 2번 사면 된다.</p><p>P1 = 5, P2 = 2, P3 = 8, P4 = 10인 경우에는 카드가 1개 들어있는 카드팩을 4번 사면 20원이고, 이 경우가 민규가 지불해야 하는 금액의 최댓값이다.</p><p>마지막으로, P1 = 3, P2 = 5, P3 = 15, P4 = 16인 경우에는 3개 들어있는 카드팩과 1개 들어있는 카드팩을 구매해 18원을 지불하는 것이 최댓값이다.</p><p>카드 팩의 가격이 주어졌을 때, N개의 카드를 구매하기 위해 민규가 지불해야 하는 금액의 최댓값을 구하는 프로그램을 작성하시오. N개보다 많은 개수의 카드를 산 다음, 나머지 카드를 버려서 N개를 만드는 것은 불가능하다. 즉, 구매한 카드팩에 포함되어 있는 카드 개수의 합은 N과 같아야 한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)</p><p>둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11052" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11052</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>1 5 6 7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>10</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>5<br>10 9 8 7 6</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>50</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>10<br>1 1 2 3 5 8 13 21 34 55</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>55</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>10<br>5 10 11 12 13 30 35 40 45 47</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>50</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[n] = 카드 n개를 갖기 위해 지불하는 금액의 최댓값</li><li>카드팩 + 카드팩 + 카드팩 + … + <strong>카드팩</strong> = n  –&gt; <strong>카드팩</strong> 은 카드가 몇개? 알수없음 (i개)<ul><li>카드팩 + 카드팩 + 카드팩 + … + -&gt; n - i 개</li><li>d[n - i] + p[i]</li></ul></li><li>즉, d[n] = max(d[n - i] + p[i]) (1 &lt;= i &lt;= n)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i]; <span class="comment">// Pi 입력</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// d[n] = max(d[n - i] + p[i]) (1 &lt;= i &lt;= n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = d[i - j] + p[j];</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; temp)</span><br><span class="line">d[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11052&quot;&gt;&lt;a href=&quot;#Problem-11052&quot; class=&quot;headerlink&quot; title=&quot;Problem 11052&quot;&gt;&lt;/a&gt;Problem 11052&lt;/h1&gt;&lt;h2 id=&quot;카드-구매하기&quot;&gt;&lt;a href=&quot;#카드
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 9095번 1, 2, 3 더하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/09/algorithm9095/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/09/algorithm9095/</id>
    <published>2020-02-09T06:32:18.000Z</published>
    <updated>2020-02-24T12:49:49.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-9095"><a href="#Problem-9095" class="headerlink" title="Problem 9095"></a>Problem 9095</h1><h2 id="1-2-3-더하기"><a href="#1-2-3-더하기" class="headerlink" title="1, 2, 3 더하기"></a>1, 2, 3 더하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.</p><ul><li>1+1+1+1</li><li>1+1+2</li><li>1+2+1</li><li>2+1+1</li><li>2+2</li><li>1+3</li><li>3+1<br>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/9095" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/9095</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>4<br>7<br>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>7<br>44<br>274</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[n] = n을 1, 2, 3의 합으로 나타내는 방법의 수</li><li>o + o + o + … + <strong>o</strong> = n  –&gt; <strong>o</strong> 의 자리에 올 수 있는 수 : 1, 2, 3<ul><li>[  합 : n - 1    ] + 1 = n;</li><li>[  합 : n - 2    ] + 2 = n;</li><li>[  합 : n - 3    ] + 3 = n;</li></ul></li><li>d[n] = d[n - 1] + d[n - 2] + d[n - 3]<ul><li>d[0] = 1 // 공집합, 모든 숫자를 0개씩 사용하는 경우 1</li><li>d[1] = 1 // 1</li><li>d[2] = 2 // 1+1, 2</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ul><li><p>동적 계획법</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">11</span>]; <span class="comment">// n &lt; 11, d[n] = n을 1, 2, 3의 합으로 나타내는 방법의 수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t; <span class="comment">// testcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum123_top_down(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="comment">// d[0] = 1(공집합, 모든 숫자를 0개씩 사용), d[1] = 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="comment">// 1 + 1, 2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 메모되어있으면 리턴</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// d[n] = d[n - 1] + d[n - 2] + d[n - 3]</span></span><br><span class="line">d[n] = sum123_top_down(n - <span class="number">1</span>) + sum123_top_down(n - <span class="number">2</span>) + sum123_top_down(n - <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] + d[i - <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>부르트 포스(재귀)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; goal) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 1, 2, 3으로 원하는 수를 만들 수 없는 경우</span></span><br><span class="line"><span class="keyword">if</span> (sum == goal) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 만든 경우</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">count += go(sum + i, goal);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(<span class="number">0</span>, n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-9095&quot;&gt;&lt;a href=&quot;#Problem-9095&quot; class=&quot;headerlink&quot; title=&quot;Problem 9095&quot;&gt;&lt;/a&gt;Problem 9095&lt;/h1&gt;&lt;h2 id=&quot;1-2-3-더하기&quot;&gt;&lt;a href=&quot;#1-2-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11727번 2xn 타일링 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11727/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11727/</id>
    <published>2020-02-08T11:32:18.000Z</published>
    <updated>2020-02-24T12:49:29.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11727"><a href="#Problem-11727" class="headerlink" title="Problem 11727"></a>Problem 11727</h1><h2 id="2xn타일링2"><a href="#2xn타일링2" class="headerlink" title="2xn타일링2"></a>2xn타일링2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 직사각형을 1x2와 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11727" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11727</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>8</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>171</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>12</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>2731</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>2xn타일링 문제와 동일하게 진행되지만 2x2타일이 따로 존재한다는 점에서 다음과 같이 진행한다.</li><li>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수<ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li><li><ol start="3"><li>2x2 타일을 하나 붙인다.</li></ol></li></ul></li><li>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수 * 2</li><li>d[n] = d[n - 1] + d[n - 2] * 2</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 2×n 직사각형을 1x2와 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling_top_down(n) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2xn 타일링 문제에서 d[n - 2]인 경우가 두배가 된 것.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] * <span class="number">2</span>; <span class="comment">// d[n] = d[n - 1] + d[n - 2]\*2</span></span><br><span class="line">d[i] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling_top_down(n - <span class="number">1</span>) + tiling_top_down(n - <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">d[n] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11727&quot;&gt;&lt;a href=&quot;#Problem-11727&quot; class=&quot;headerlink&quot; title=&quot;Problem 11727&quot;&gt;&lt;/a&gt;Problem 11727&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링2&quot;&gt;&lt;a href=&quot;#2x
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11726번 2xn타일링</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/</id>
    <published>2020-02-08T06:45:13.000Z</published>
    <updated>2020-02-17T15:35:03.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11726"><a href="#Problem-11726" class="headerlink" title="Problem 11726"></a>Problem 11726</h1><h2 id="2xn타일링"><a href="#2xn타일링" class="headerlink" title="2xn타일링"></a>2xn타일링</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><p>아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11726" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11726</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>9</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>55</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>먼저 메모이제이션 할 배열 d[]를 선언한다.</p></li><li><p>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</p><ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li></ul></li><li><p>즉, 2xn 크기의 직사각형을 채우는 방법의 수는</p></li><li><p>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수</p></li><li><p>d[n] = d[n - 1] + d[n - 2]</p></li><li><p>피보나치 수열과 같은 형태로 점화식이 만들어진다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="comment">// n이 d[1] = 1, d[2] = 2이므로</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 구한 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling(n - <span class="number">1</span>) + tiling(n - <span class="number">2</span>); <span class="comment">// d[n] = d[n - 1] + d[n - 2]</span></span><br><span class="line">d[n] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>];</span><br><span class="line">d[i] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11726&quot;&gt;&lt;a href=&quot;#Problem-11726&quot; class=&quot;headerlink&quot; title=&quot;Problem 11726&quot;&gt;&lt;/a&gt;Problem 11726&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링&quot;&gt;&lt;a href=&quot;#2xn
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1676번 팩토리얼 0의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1676/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1676/</id>
    <published>2020-02-08T06:32:18.000Z</published>
    <updated>2020-02-24T12:38:32.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1676"><a href="#Problem-1676" class="headerlink" title="Problem 1676"></a>Problem 1676</h1><h2 id="팩토리얼-0의-개수"><a href="#팩토리얼-0의-개수" class="headerlink" title="팩토리얼 0의 개수"></a>팩토리얼 0의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 구한 0의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1676" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1676</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.<ul><li>(뒤에서부터 연속으로 등장하는 0의 개수이므로)</li></ul></li><li>n!에서는 2의 개수가 항상 5의 개수보다 많으므로 5의 개수만 세어준다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.</span></span><br><span class="line"><span class="comment">// n!에서는 2의 개수가 항상 5의 개수보다 많으므로 5의 개수만 세어준다.</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = i;</span><br><span class="line"><span class="keyword">while</span> (tmp % <span class="number">5</span> == <span class="number">0</span>) <span class="comment">// 5의 개수 count</span></span><br><span class="line">&#123;</span><br><span class="line">tmp /= <span class="number">5</span>; <span class="comment">// 5를 하나 이상 인자로 가지는 수 처리</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1676&quot;&gt;&lt;a href=&quot;#Problem-1676&quot; class=&quot;headerlink&quot; title=&quot;Problem 1676&quot;&gt;&lt;/a&gt;Problem 1676&lt;/h1&gt;&lt;h2 id=&quot;팩토리얼-0의-개수&quot;&gt;&lt;a href=&quot;#팩토리
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1463번 1로 만들기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/</id>
    <published>2020-02-08T05:30:51.000Z</published>
    <updated>2020-02-17T15:24:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1463"><a href="#Problem-1463" class="headerlink" title="Problem 1463"></a>Problem 1463</h1><h2 id="1로-만들기"><a href="#1로-만들기" class="headerlink" title="1로 만들기"></a>1로 만들기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p><ol><li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li><li>X가 2로 나누어 떨어지면, 2로 나눈다.</li><li>1을 뺀다.</li></ol><p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1463" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1463</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>10</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>먼저 메모이제이션 할 배열 d[]를 선언한다.</li><li>점화식 d[n] = n을 1로 만드는 최소 연산 횟수 를 정의한다.<ul><li>[n을 n / 3으로 만드는 연산 횟수 : 1번], [n/3을 1로 만드는 연산 횟수 : d[n / 3]번]  //  1번 + d[n / 3]번</li><li>n -&gt; [n / 2] -&gt; 1  //  1번 + d[n / 2]번</li><li>n -&gt; [n - 1] -&gt; 1  //  1번 + d[n - 1]번</li><li>=&gt; d[n] = min(d[n / 3], d[n / 2], d[n - 1]) + 1</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000001</span>]; <span class="comment">// d[n] : n을 1로 만드는 최소 연산 횟수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식 구현</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 1을 만든 경우 d[1] = 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 수행했던 연산인 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n]; <span class="comment">// 메모이제이션</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = go(n - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 최솟값을 더 편하게 구하기 위해 먼저 처리</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 2로 나누어 떨어지는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp; <span class="comment">// 새로운 방식이 더 적은 연산을 필요로 하면 바꿔줌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 초기값 지정</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">3</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1463&quot;&gt;&lt;a href=&quot;#Problem-1463&quot; class=&quot;headerlink&quot; title=&quot;Problem 1463&quot;&gt;&lt;/a&gt;Problem 1463&lt;/h1&gt;&lt;h2 id=&quot;1로-만들기&quot;&gt;&lt;a href=&quot;#1로-만들기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2004번 조합 0의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm2004/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm2004/</id>
    <published>2020-02-08T01:32:18.000Z</published>
    <updated>2020-02-24T12:39:35.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2004"><a href="#Problem-2004" class="headerlink" title="Problem 2004"></a>Problem 2004</h1><h2 id="조합-0의-개수"><a href="#조합-0의-개수" class="headerlink" title="조합 0의 개수"></a>조합 0의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>nCm의 끝자리 0의 개수를 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정수 n, m(0≤m≤n≤2,000,000,000, n!=0)이 들어온다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 0의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2004" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2004</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>25 12</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.<ul><li>(뒤에서부터 연속으로 등장하는 0의 개수이므로)</li></ul></li><li>nCm = n! / (n-m)!*m!</li><li>조합의 0의 개수는 n!의 0의 개수에서 (n-m)!의 0의 개수와 m!의 0의 개수를 빼주면 된다.</li><li>조합의 0의 개수는 항상 5의 개수가 더 많지 않을 수 있으므로 2와 5의 개수 중 더 작은 값을 구하면 된다.</li><li>범위가 매우 크기 때문에 int형이 아닌 long long 형을 사용한다. (int형 사용시 런타임에러)</li><li>이때 2와 5의 개수를 구하는 방법은 팩토리얼의 0의 개수를 구할 때와는 다르게 구한다.<ul><li>최대 2,000,000,000의 수가 들어오기 때문에 시간 초과가 발생할 수 있음</li><li>n!의 i의 개수를 구한다고 한다면</li><li>먼저 count에 n / i를 더한다.</li><li>n을 i로 나누어도 i^2의 배수들은 i가 남아있기 때문에 count에 n / i^2 을 더한다.</li><li>i^3의 배수같은 경우는 i^2으로 나누어도 i가 남아있기 때문에 count에 n / i^3을 더한다.</li><li>위의 과정을 반복한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; zeros(<span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> five = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">5</span>; i &lt;= n; i *= <span class="number">5</span>) <span class="comment">// 5의 개수 카운트</span></span><br><span class="line">five += n / i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; i *= <span class="number">2</span>) <span class="comment">// 2의 개수 카운트</span></span><br><span class="line">two += n / i;</span><br><span class="line"><span class="keyword">return</span> &#123;two, five&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; resM, resN, resNM;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>, five = <span class="number">0</span>;</span><br><span class="line">resM = zeros(m);</span><br><span class="line">resN = zeros(n);</span><br><span class="line">resNM = zeros(n - m);</span><br><span class="line"></span><br><span class="line">two = resN.first - resM.first - resNM.first; <span class="comment">// n의 2의 개수에서 m과 (n-m)의 2의 개수를 빼줌</span></span><br><span class="line">five = resN.second - resM.second - resNM.second;  <span class="comment">// n의 5의 개수에서 m과 (n-m)의 5의 개수를 빼줌</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(two, five) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2004&quot;&gt;&lt;a href=&quot;#Problem-2004&quot; class=&quot;headerlink&quot; title=&quot;Problem 2004&quot;&gt;&lt;/a&gt;Problem 2004&lt;/h1&gt;&lt;h2 id=&quot;조합-0의-개수&quot;&gt;&lt;a href=&quot;#조합-0의
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17087번 숨박꼭질 6</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm17087/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm17087/</id>
    <published>2020-02-07T11:32:18.000Z</published>
    <updated>2020-02-24T12:41:17.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17087"><a href="#Problem-17087" class="headerlink" title="Problem 17087"></a>Problem 17087</h1><h2 id="숨박꼭질-6"><a href="#숨박꼭질-6" class="headerlink" title="숨박꼭질 6"></a>숨박꼭질 6</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수빈이는 동생 N명과 숨바꼭질을 하고 있다. 수빈이는 현재 점 S에 있고, 동생은 A1, A2, …, AN에 있다.</p><p>수빈이는 걸어서 이동을 할 수 있다. 수빈이의 위치가 X일때 걷는다면 1초 후에 X+D나 X-D로 이동할 수 있다. 수빈이의 위치가 동생이 있는 위치와 같으면, 동생을 찾았다고 한다.</p><p>모든 동생을 찾기위해 D의 값을 정하려고 한다. 가능한 D의 최댓값을 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1 ≤ N ≤ 105)과 S(1 ≤ S ≤ 109)가 주어진다. 둘째 줄에 동생의 위치 Ai(1 ≤ Ai ≤ 109)가 주어진다. 동생의 위치는 모두 다르며, 수빈이의 위치와 같지 않다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>가능한 D값의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17087" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17087</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 7 11</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 81<br>33 105 57</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>24</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>1 1<br>1000000000</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>999999999</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>수빈이의 위치와 동생의 위치를 모두 하나의 벡터에 오름차순으로 담는다.</li><li>이후 벡터의 인덱스를 i라고 하면 모든 v[i+1] - v[i] 의 최대공약수를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> <span class="comment">// 유클리드 호제법 (최대공약수)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, s; <span class="comment">// n : 동생 수, s : 수빈이의 위치</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; v(n); <span class="comment">// 수빈이의 위치와 동생의 위치를 담을 벡터</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">v.push_back(s); <span class="comment">// 수빈이의 위치 추가</span></span><br><span class="line"></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// 오름차순 정렬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res = v[<span class="number">1</span>] - v[<span class="number">0</span>]; <span class="comment">// 초기값 설정</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, j = i + <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); i++, j++)</span><br><span class="line">&#123;</span><br><span class="line">res = gcd(res, v[j] - v[i]); <span class="comment">// 다음 원소와의 차이의 최대공약수(모든 차이 값의 최대공약수)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17087&quot;&gt;&lt;a href=&quot;#Problem-17087&quot; class=&quot;headerlink&quot; title=&quot;Problem 17087&quot;&gt;&lt;/a&gt;Problem 17087&lt;/h1&gt;&lt;h2 id=&quot;숨박꼭질-6&quot;&gt;&lt;a href=&quot;#숨박꼭
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1929번 소수 구하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm1929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm1929/</id>
    <published>2020-02-07T10:32:18.000Z</published>
    <updated>2020-02-24T12:35:40.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1929"><a href="#Problem-1929" class="headerlink" title="Problem 1929"></a>Problem 1929</h1><h2 id="소수-구하기"><a href="#소수-구하기" class="headerlink" title="소수 구하기"></a>소수 구하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>계산 결과를 소숫점 둘째 자리까지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 16</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>5<br>7<br>11<br>13</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>에라토스테네스의 체<ul><li>2부터 n까지의 모든 수를 써놓는다.</li><li>아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.</li><li>그 수는 소수이다.</li><li>이제 그 수의 배수를 모두 지운다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">1000001</span>] = &#123; <span class="literal">false</span> &#125;; <span class="comment">// 각 숫자의 소수 여부를 체크할 bool배열</span></span><br><span class="line"><span class="keyword">int</span> m, n; <span class="comment">// 소수 범위 (1 ≤ M ≤ N ≤ 1,000,000)</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">check[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 1은 소수가 아님</span></span><br><span class="line"><span class="comment">//  에라토스테네스의 체</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++) <span class="comment">// i^2이 n을 넘어가면 i의 배수는 이미 모두 지워짐</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!check[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j*i &lt;= n; j++) <span class="comment">// i*i이상의 i의 배수를 모두 지워줌</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i * j &gt; <span class="number">1000000</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">check[i * j] = <span class="literal">true</span>; <span class="comment">// 소수가 아니면 true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[i])</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1929&quot;&gt;&lt;a href=&quot;#Problem-1929&quot; class=&quot;headerlink&quot; title=&quot;Problem 1929&quot;&gt;&lt;/a&gt;Problem 1929&lt;/h1&gt;&lt;h2 id=&quot;소수-구하기&quot;&gt;&lt;a href=&quot;#소수-구하기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17103번 골드바흐 파티션</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm17103/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm17103/</id>
    <published>2020-02-07T06:32:18.000Z</published>
    <updated>2020-02-24T12:44:30.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17103"><a href="#Problem-17103" class="headerlink" title="Problem 17103"></a>Problem 17103</h1><h2 id="골드바흐-파티션"><a href="#골드바흐-파티션" class="headerlink" title="골드바흐 파티션"></a>골드바흐 파티션</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><ul><li>골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.</li></ul><p>짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 &lt; N ≤ 1,000,000을 만족한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17103" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17103</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>6<br>8<br>10<br>12<br>100</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1<br>1<br>2<br>1<br>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>전체 범위의 소수들을 모두 구한다.(에라토스테네스의 체 이용)</li><li>이후 n - b = a 가 소수인 경우. 즉, 골드바흐의 추측을 만족하는 경우에 n = a + b 를 출력</li></ul><hr><ul><li>위와 같이 골드바흐의 추측 문제와 같은 방식으로 접근하여 파티션의 개수만 출력한다.<ul><li>이때 중복을 제거해야 하므로 count를 2로 나눈 몫을 출력하는데,</li><li>6 = 3 + 3, 10 = 5 + 5 와 같은 경우 중복이 발생하지 않는 한 쌍이 존재하므로</li><li>현재 입력받은 수 num을 기준으로 num / 2가 소수라면 count를 2로 나눈 몫에 1을 더하여 중복이 발생하지 않는 경우를 더해주어 출력하고</li><li>아니라면 count를 2로 나누어 중복을 제거 후 출력한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> prime[MAX]; <span class="comment">// 소수를 담을 배열</span></span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// 인덱스가 소수이면 false인 배열</span></span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>; <span class="comment">// 소수의 개수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">check[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 1은 소수가 아님</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX; i++) <span class="comment">// 에라토스테네스의 체</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="literal">false</span>) <span class="comment">// 아직 (소수가 아니라고)판별되지 않았다면</span></span><br><span class="line">&#123;</span><br><span class="line">prime[pn++] = i; <span class="comment">// 소수이면 prime에 저장</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; MAX; j += i) <span class="comment">// i*i로 하면 정수 범위를 벗어날 수 있음</span></span><br><span class="line">&#123;</span><br><span class="line">check[j] = <span class="literal">true</span>; <span class="comment">// 소수의 배수는 모두 제거</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 파티션 수</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; prime[i] &lt; num; i++) <span class="comment">// 소수가 현재 입력 수 보다 작은동안</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[num - prime[i]]) <span class="comment">// n - b = a(소수)라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cout &lt;&lt; num &lt;&lt; " = " &lt;&lt; num - prime[i] &lt;&lt; " + " &lt;&lt; prime[i] &lt;&lt; '\n';</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!check[num / <span class="number">2</span>]) <span class="comment">// num / 2 가 소수라면 - 즉, 6 = 3 + 3 과 같이 중복이 발생하지 않는 파티션이 존재하는 경우</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count / <span class="number">2</span> + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 중복을 제거하고 1을 더함</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count / <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 중복 제거</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17103&quot;&gt;&lt;a href=&quot;#Problem-17103&quot; class=&quot;headerlink&quot; title=&quot;Problem 17103&quot;&gt;&lt;/a&gt;Problem 17103&lt;/h1&gt;&lt;h2 id=&quot;골드바흐-파티션&quot;&gt;&lt;a href=&quot;#골
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 17298번 오큰수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/07/algorithm17298/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/07/algorithm17298/</id>
    <published>2020-02-07T02:23:42.000Z</published>
    <updated>2020-02-24T12:33:10.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-17298"><a href="#Problem-17298" class="headerlink" title="Problem 17298"></a>Problem 17298</h1><h2 id="오큰수"><a href="#오큰수" class="headerlink" title="오큰수"></a>오큰수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.</p><p>예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, …, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>총 N개의 수 NGE(1), NGE(2), …, NGE(N)을 공백으로 구분해 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/17298" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/17298</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>3 5 2 7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>5 7 7 -1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4<br>9 5 4 8</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1 8 8 -1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>vector a에 입력받은 수열을 넣고 vector res에는 a의 각 값에 대한 오큰수를 넣는다.</li><li>stack s에는 vector a에서 다음 원소와 비교하여 아직 오큰수를 찾지 못한 수의 인덱스가 쌓인다.</li><li>스택이 비어있다면 현재 인덱스를 먼저 push한다</li><li>이후 비어있지 않고 현재 a의 원소a[i]가 스택의 가장 위에 있는 인덱스를 가지는 원소(a[s.top()])와 비교하여 더 크다면 a[i] 는 a[s.top()]의 오큰수이므로 res[s.top()]에 저장한다. 이후 pop을 수행한다.(반복문 내에서 조건하에 계속 반복)</li><li>오큰수를 아직 확인하지 못한 수(=현재 수열의 원소 because 다음번에 확인 가능하므로)의 인덱스를 push</li><li>위의 과정의 반복이 끝나고 스택에 남아있는 수들은 오큰수를 구하지 못한 수 이므로 -1로 처리</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">현재 수 보다 큰 수면서 오른쪽으로 가장 가까운 수 = 오큰수</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 다음 수가 오큰수가 아닌 수의 인덱스를 담을 스택</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">s.push(<span class="number">0</span>); <span class="comment">// 첫번째 원소 0으로 초기화</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s.empty())</span><br><span class="line">&#123;</span><br><span class="line">s.push(i); <span class="comment">// 스택이 비어있다면 현재 인덱스를 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.empty() &amp;&amp; a[i] &gt; a[s.top()]) <span class="comment">// 스택이 비어있지 않고 현재 수열의 원소가 아직 오큰수를 구하지 못한 수보다 크면</span></span><br><span class="line">&#123;</span><br><span class="line">res[s.top()] = a[i]; <span class="comment">// a[s.top()]의 오큰수는 a[i]</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">s.push(i); <span class="comment">// 오큰수를 아직 확인하지 못한 수(=현재 수열의 원소 because 다음번에 확인 가능하므로)의 인덱스를 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s.empty()) <span class="comment">// 위의 과정이 끝나고 오큰수를 구하지 못한 수들은 -1</span></span><br><span class="line">&#123;</span><br><span class="line">res[s.top()] = <span class="number">-1</span>;</span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-17298&quot;&gt;&lt;a href=&quot;#Problem-17298&quot; class=&quot;headerlink&quot; title=&quot;Problem 17298&quot;&gt;&lt;/a&gt;Problem 17298&lt;/h1&gt;&lt;h2 id=&quot;오큰수&quot;&gt;&lt;a href=&quot;#오큰수&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1935번 후위 표기식 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/06/algorithm1935/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/06/algorithm1935/</id>
    <published>2020-02-06T10:32:18.000Z</published>
    <updated>2020-02-24T12:32:17.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1935"><a href="#Problem-1935" class="headerlink" title="Problem 1935"></a>Problem 1935</h1><h2 id="후위-표기식-2"><a href="#후위-표기식-2" class="headerlink" title="후위 표기식 2"></a>후위 표기식 2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>후위 표기식과 각 피연산자에 대응하는 값들이 주어져 있을 때, 그 식을 계산하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 피연산자의 개수(1 ≤ N ≤ 26) 가 주어진다. 그리고 둘째 줄에는 후위 표기식이 주어진다. (여기서 피연산자는 A~Z의 영대문자이며, A부터 순서대로 N개의 영대문자만이 사용되며, 길이는 100을 넘지 않는다) 그리고 셋째 줄부터 N+2번째 줄까지는 각 피연산자에 대응하는 값이 주어진다. (3번째 줄에는 A에 해당하는 값, 4번째 줄에는 B에 해당하는값 , 5번째 줄에는 C …이 주어진다, 그리고 피연산자에 대응 하는 값은 정수이다)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>계산 결과를 소숫점 둘째 자리까지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1935" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1935</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>ABC*+DE/-<br>1<br>2<br>3<br>4<br>5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6.20</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>1<br>AA+A+<br>1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3.00</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>문자열의 현재 인덱스가 피연산자(영어 대문자)라면 해당 숫자로 변환하여 스택에 push한다.</li><li>연산자인 경우 스택의 가장 위의 두 수를 뽑아 순서를 뒤집어(아래의 숫자가 더 먼저 들어간 수 이므로) 연산 후 다시 push 한다.</li><li>위 과정을 반복 후 스택의 top원소를 소수점 둘째 자리까지만 표기하여 출력</li></ul><h3 id="C-소수점-조정"><a href="#C-소수점-조정" class="headerlink" title="C++ 소수점 조정"></a>C++ 소수점 조정</h3><ul><li>“cout &lt;&lt; fixed”라는 표현은 소숫점 아래 값을 고정하는 표현이다.</li><li>즉, cout &lt;&lt; fixed 이후에 precision(6)을 입력하면 소숫점 아래를 6으로 고정한다.</li><li>precision() -&gt; 자릿수를 조정하는 함수이다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str; <span class="comment">// 입력 문자열</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 피연산자 수</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">double</span>&gt; s; <span class="comment">// 피연산자를 담을 스택</span></span><br><span class="line"><span class="keyword">double</span> alphabet[<span class="number">26</span>]; <span class="comment">// 피연산자에 해당하는 숫자를 저장할 배열</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; alphabet[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] &gt;= <span class="string">'A'</span> &amp;&amp; str[i] &lt;= <span class="string">'Z'</span>) <span class="comment">// 피연산자일 경우 숫자로 변환하여 스택에 push</span></span><br><span class="line">&#123;</span><br><span class="line">s.push(alphabet[str[i] - <span class="string">'A'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 연산자인 경우 스택의 위의 두 수를 뽑아 순서를 뒤집어 연산 후 다시 push</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> a = s.top();</span><br><span class="line">s.pop();</span><br><span class="line"><span class="keyword">double</span> b = s.top();</span><br><span class="line">s.pop();</span><br><span class="line">s.push(cal(a, b, str[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> res = <span class="number">0.</span>;</span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">res = b + a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">res = b - a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'\*'</span>:</span><br><span class="line">res = b * a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">res = b / a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1935&quot;&gt;&lt;a href=&quot;#Problem-1935&quot; class=&quot;headerlink&quot; title=&quot;Problem 1935&quot;&gt;&lt;/a&gt;Problem 1935&lt;/h1&gt;&lt;h2 id=&quot;후위-표기식-2&quot;&gt;&lt;a href=&quot;#후위-표기
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 6588번 골드바흐의 추측</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/06/algorithm6588/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/06/algorithm6588/</id>
    <published>2020-02-06T10:32:18.000Z</published>
    <updated>2020-02-24T12:50:06.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-6588"><a href="#Problem-6588" class="headerlink" title="Problem 6588"></a>Problem 6588</h1><h2 id="골드바흐의-추측"><a href="#골드바흐의-추측" class="headerlink" title="골드바흐의 추측"></a>골드바흐의 추측</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다.</p><blockquote><p>4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.</p></blockquote><p>예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다. 또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.</p><p>이 추측은 아직도 해결되지 않은 문제이다.</p><p>백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.</p><p>각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)</p><p>입력의 마지막 줄에는 0이 하나 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스에 대해서, n = a + b 형태로 출력한다. 이때, a와 b는 홀수 소수이다. 숫자와 연산자는 공백 하나로 구분되어져 있다. 만약, n을 만들 수 있는 방법이 여러 가지라면, b-a가 가장 큰 것을 출력한다. 또, 두 홀수 소수의 합으로 n을 나타낼 수 없는 경우에는 “Goldbach’s conjecture is wrong.”을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/6588" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/6588</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8<br>20<br>42<br>0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>8 = 3 + 5<br>20 = 3 + 17<br>42 = 5 + 37</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>전체 범위의 소수들을 모두 구한다.(에라토스테네스의 체 이용)</li><li>이후 n - b = a 가 소수인 경우. 즉, 골드바흐의 추측을 만족하는 경우에 n = a + b 를 출력</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[MAX]; <span class="comment">// 소수들을 담을 배열</span></span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// check의 인덱스가 소수면 참</span></span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>; <span class="comment">// 소수의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX; i++) <span class="comment">// 에라토스테네스의 체</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="literal">false</span>)  <span class="comment">// 지워지지 않았다면(소수라면)</span></span><br><span class="line">&#123;</span><br><span class="line">prime[pn++] = i; <span class="comment">// 소수 배열에 추가</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= MAX; j += i) <span class="comment">//  i*i 부터 시작을 하면 정수의 범위를 넘어 런타임 에러가 남</span></span><br><span class="line">&#123;</span><br><span class="line">check[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pn ; i++) <span class="comment">// 3부터 시작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check[n - prime[i]]) <span class="comment">// n - prime[i] 가 소수면 성립</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" = "</span> &lt;&lt; prime[i] &lt;&lt; <span class="string">" + "</span> &lt;&lt; n - prime[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-6588&quot;&gt;&lt;a href=&quot;#Problem-6588&quot; class=&quot;headerlink&quot; title=&quot;Problem 6588&quot;&gt;&lt;/a&gt;Problem 6588&lt;/h1&gt;&lt;h2 id=&quot;골드바흐의-추측&quot;&gt;&lt;a href=&quot;#골드바흐의
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 10799번 쇠막대기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/06/algorithm10799/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/06/algorithm10799/</id>
    <published>2020-02-05T23:48:41.000Z</published>
    <updated>2020-02-05T23:49:55.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-10799"><a href="#Problem-10799" class="headerlink" title="Problem 10799"></a>Problem 10799</h1><h2 id="쇠막대기"><a href="#쇠막대기" class="headerlink" title="쇠막대기"></a>쇠막대기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.</p><p>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.<br>각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.<br>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.<br>아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.</p><p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.</p><p>레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.<br>쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다.<br>위 예의 괄호 표현은 그림 위에 주어져 있다.</p><p>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다.</p><p>쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/10799" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/10799</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>()(((()())(())()))(())</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>17</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>(((()(()()))(())()))(()())</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>24</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><p>이전에 풀어보았던 괄호 문제와 비슷한듯 싶어<br>스택을 이용하면 될듯 싶었다. 접근 방식은 아래와 같았다.</p><ul><li>하나의 막대기를 n개의 레이저로 자르면 -&gt; n + 1 개의 조각 생성</li><li>각각의 막대기에 몇 개의 레이저가 가해지는지 확인하여 모두 더하면 됨<ul><li>먼저 괄호를 보고 레이저와 막대기를 구분해야 했다.</li><li>레이저는 () 이므로 문자열의 현재 인덱스와 다음 인덱스를 보고 레이저가 맞다면</li><li>레이저가 통과하는 모든 막대기에 레이저 수를 하나씩 증가시킨다.(배열을 이용하여 n번째 막대기에 가해지는 레이저의 수를 raser[n]으로 지정하였다.)</li><li>레이저인 경우 위와 같이 처리하고 건너뛰고, 레이저가 아니라면 ‘(‘일 때 스택에 push, ‘)’일 때 pop을 하여 현재 스택의 사이즈를 보고 어떤 막대기인지를 판단했다.</li><li>이제 raser[]에 담긴 수를 확인하여 막대기마다 n + 1을 해 누적하면 되는데,</li><li>이것을 괄호가 닫힐 때 정산을 하면 된다.</li><li>결과를 출력할 변수에 raser[s.size()]+1 을 누적시키면 가장 위에 있는 막대기 중 하나에 발사되는 레이저 수를 구하게 되는 것이다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> input; <span class="comment">// 입력 문자열</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"></span><br><span class="line">getline(<span class="built_in">cin</span>, input);</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = input.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> raser[<span class="number">100000</span>] = &#123;&#125;; <span class="comment">// 막대기에 발사된 레이저의 수</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] == <span class="string">'('</span> &amp;&amp; input[i + <span class="number">1</span>] == <span class="string">')'</span>) <span class="comment">// 레이저인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line">raser[j]++; <span class="comment">// 스택의 사이즈(겹쳐진 막대기 수) 모두 1씩 증가</span></span><br><span class="line">&#125;</span><br><span class="line">i++; <span class="comment">// 문자 두 개를 확인했으니 한칸 넘어감</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 막대기의 시작 or 끝인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (input[i] == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.push(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (input[i] == <span class="string">')'</span>) <span class="comment">// 괄호가 닫힐 때 정산</span></span><br><span class="line">&#123;</span><br><span class="line">res += raser[s.<span class="built_in">size</span>()] + <span class="number">1</span>; <span class="comment">// 하나의 막대기에는 n + 1개의 조각이 생성</span></span><br><span class="line">raser[s.<span class="built_in">size</span>()] = <span class="number">0</span>; <span class="comment">// 초기화</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-10799&quot;&gt;&lt;a href=&quot;#Problem-10799&quot; class=&quot;headerlink&quot; title=&quot;Problem 10799&quot;&gt;&lt;/a&gt;Problem 10799&lt;/h1&gt;&lt;h2 id=&quot;쇠막대기&quot;&gt;&lt;a href=&quot;#쇠막대기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) 범위 기반 for문</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/19/C++range-based%20for%20statement/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/19/C++range-based%20for%20statement/</id>
    <published>2020-01-19T11:33:41.000Z</published>
    <updated>2020-01-19T12:39:10.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="범위-기반-for문-range-based-for-statement"><a href="#범위-기반-for문-range-based-for-statement" class="headerlink" title="범위 기반 for문 (range-based for statement)"></a>범위 기반 for문 (range-based for statement)</h2><p>일반적인 for문은 다음과 같은 형태이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[n] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 C++ 11에서는 범위기반 for문 이라는 새로운 형태의 루프를 도입하여 더 간결하게 배열 등의 모든 요소를 반복하는 방법을 제공한다.</p><p>범위 기반 for문의 기본 문법은 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(element_declaration : <span class="built_in">array</span>)</span><br><span class="line">statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 위의 기본 for문을 범위 기반 for문으로 표현하면 다음과 같다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[n] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래는 auto키워드를 이용하여 자동으로 적절한 자료형을 지정함.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 일반 for문을 간단하게 표현할 수 있다. 위의 방식들은 각 원소의 참조를 x에 값이 복사되어 사용되기 때문에 원본이 훼손되지는 않지만 원소를 수정할 수 없다. 또한 복사하는데 비용도 발생한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 아래와 같이 사용하면 arr의 모든 원소는 10으로 변경된다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : arr)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const로 지정하면 원소를 복사하지 않고 원본도 훼손되지 않기 때문에 자료의 안전성을 갖춘다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>참조<br><a href="https://docs.microsoft.com/ko-kr/cpp/cpp/range-based-for-statement-cpp?view=vs-2019" target="_blank" rel="external nofollow noopener noreferrer">https://docs.microsoft.com/ko-kr/cpp/cpp/range-based-for-statement-cpp?view=vs-2019</a><br><a href="https://boycoding.tistory.com/210" target="_blank" rel="external nofollow noopener noreferrer">https://boycoding.tistory.com/210</a><br><a href="https://blockdmask.tistory.com/319" target="_blank" rel="external nofollow noopener noreferrer">https://blockdmask.tistory.com/319</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;범위-기반-for문-range-based-for-statement&quot;&gt;&lt;a href=&quot;#범위-기반-for문-range-based-for-statement&quot; class=&quot;headerlink&quot; title=&quot;범위 기반 for문 (range-ba
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) 입력 함수 - cin, cin.get(), getline()</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/17/C++getline()/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/17/C++getline()/</id>
    <published>2020-01-17T14:23:55.000Z</published>
    <updated>2020-01-19T00:26:24.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><ul><li>&lt;iostream&gt;에 포함되어 있다.</li><li>표준 입력 버퍼에서 개행 문자를 제외한 값을 가져온다.</li><li>공백이나 개행 입력 시 공백 이전까지의 값만 결과로 받아들인다.</li><li>개행 문자를 입력 버퍼에 남겨둔다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정수</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br></pre></td></tr></table></figure><p>위와 같이 사용이 가능하다.<br>이때 hello 같은 문자열이라면 문제 없이 입력을 받지만 Hello World!와 같이 띄어쓰기가 포함된 문장이라면 Hello 까지 밖에 입력이 되지 않을 것이다.<br>cin의 &gt;&gt; 연산자에서는 공백문자에서 입력을 끊기 때문인데, 이러한 문제를 해결하기 위해서 getline()이라는 함수를 사용한다.</p><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p>getline()함수는 두 가지가 존재하는데 각가 다른 라이브러리에 존재한다. istream 라이브러리에 속한 cin.getline()함수와 string 라이브러리에 속하는 getline()함수가 있다.</p><ul><li><strong>istream 라이브러리의 cin.getline()</strong><ul><li>문자 배열이며 마지막 글자가 ‘\0’(terminator)인 c-string을 입력 받는데 사용</li><li>n-1개의 문자 개수만큼 읽어와 str에 저장 (n번째 문자는 NULL(‘\0’)로 바꾼다.)</li><li>세 번째 인자인 delim은 별도로 지정해주지 않으면 엔터(‘\n’)로 인식</li><li>delim을 지정해주면 그 제한자(delim)문자 직전까지 읽어서 str에 저장</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.getline(<span class="keyword">char</span>* str, streamsize n);</span><br><span class="line"><span class="built_in">cin</span>.getline(<span class="keyword">char</span>* str, streamsize n, <span class="keyword">char</span> dlim);</span><br></pre></td></tr></table></figure><p>cin.getline(변수 주소, 최대 입력 가능 문자수, 종결 문자);<br>ex) cin.getline(str, 100);</p><ul><li><strong>string 라이브러리의 getline()</strong><ul><li>최대 문자 수를 입력하지 않아도 됨.</li><li>원하는 구분자(delimiter)를 만날 때 까지 모든 문자열을 입력 받아 하나의 string 객체에 저장</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getline(istream&amp; is, <span class="built_in">string</span> str);</span><br><span class="line">getline(istream&amp; is, <span class="built_in">string</span> str, <span class="keyword">char</span> dlim);</span><br></pre></td></tr></table></figure><p>getline(입력스트림 오브젝트, 문자열을 저장할 string객체, 종결 문자);<br>ex) getline(cin, str);</p><h3 id="주의"><a href="#주의" class="headerlink" title="주의"></a>주의</h3><p>getline() 함수를 사용할 때 주의할 점이 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br></pre></td></tr></table></figure><p>위와 같은 상황을 보자. 위 코드대로 실행을 하면 n을 입력 받은 후 문자열을 입력받지 않고 바로 다음 코드로 넘어가게 된다. 이유는 버퍼에 정수 값을 입력한 뒤 누른 엔터(‘\n’)가 그대로 남아있어 getline()에 들어가기 때문이다. 이를 해결하기 위해 <strong>cin.ignore()</strong> 라는 함수를 사용할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br></pre></td></tr></table></figure><p> 위와 같이 변경하면 cin.ingore()가 입력 버퍼의 모든 내용을 제거해주어 getline()이 정상적으로 동작할 수 있다.</p><p> 추가적으로 cin.ignore() 함수에 대해 알아보자면<br> cin.ignore(int n, char dlim);<br> cin.ignore(읽어들일 문자의 개수, 종결 문자);<br> 와 같은 형태로도 사용이 가능하다.</p><h2 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h2><ul><li>표준 입력 버퍼에서 문자를 하나만 가져온다.</li><li>문자 하나만 입력이 가능하며 공백과 개행도 입력으로 포함한다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch1, ch2;</span><br><span class="line">ch1 = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">ch2 = <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure><blockquote><p>참조<br><a href="https://jhnyang.tistory.com/107" target="_blank" rel="external nofollow noopener noreferrer">https://jhnyang.tistory.com/107</a><br><a href="https://luyin.tistory.com/334" target="_blank" rel="external nofollow noopener noreferrer">https://luyin.tistory.com/334</a><br><a href="https://woodforest.tistory.com/168" target="_blank" rel="external nofollow noopener noreferrer">https://woodforest.tistory.com/168</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;cin&quot;&gt;&lt;a href=&quot;#cin&quot; class=&quot;headerlink&quot; title=&quot;cin&quot;&gt;&lt;/a&gt;cin&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&amp;lt;iostream&amp;gt;에 포함되어 있다.&lt;/li&gt;
&lt;li&gt;표준 입력 버퍼에서 개행 문자를 제외한 값을
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) STL sort()함수</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/12/C++STLsort/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/12/C++STLsort/</id>
    <published>2020-01-12T04:56:25.000Z</published>
    <updated>2020-01-17T14:23:49.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL-sort-함수"><a href="#STL-sort-함수" class="headerlink" title="STL sort() 함수"></a>STL sort() 함수</h2><p><algorithm> 헤더파일에서 제공하는 STL로서 주어진 범위 내에서 원소들을 정렬한다. 이때 정렬하는 방식을 사용자가 정의할 수 있고, 동일한 원소에 대해서는 그 순서가 보장되지 않는다. std::sort는 숫자 뿐만 아니라 대소 비교가 가능한 모든 원소에 대해서 정렬을 수행할 수 있다. 즉 int뿐 아니라 char, string 역시 정렬이 가능하며 사용자가 정의한 객체 역시 연산자 오버로딩을 정의하면 정렬이 가능하다.</algorithm></p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>2개 혹은 3개의 argument를 필요로 하는데, 첫 번째 두 개의 argument는 iterator로서 정렬하는 범위를 나타낸다. sort(start, end)</li><li>퀵 정렬을 기반으로 함수가 구현되어 있다. 평균 시간 복잡도 : O(NlogN)</li><li>세 번째 argument를 넣지 않으면 default로 오름차순 정렬이 수행된다.</li><li>사용자 정의 함수를 만들어 세 번째 인자로 넣어 정렬 기준을 정의할 수 있다.</li><li>기본적으로 두 개의 객체를 비교해서 첫 번째가 두 번째보다 작으면 true, 아니면 false를 반환한다.</li></ul><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><ul><li><strong>default - 오름차순 정렬</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">9</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">7</span> &#125;;</span><br><span class="line">sort(arr, arr + <span class="number">10</span>);</span><br><span class="line">printArray(arr, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>출력</strong></p><div style="width: 200px; height: 80px;">  <img src="https://kyu9341.github.io/img/sort1.png" style="width: 200px  ; height: 80px;"></div></blockquote></li></ul><ul><li><strong>내림차순 정렬</strong><br>내림차순 정렬은 세 번째 인자로 함수를 정의하여 사용할 수도 있고, <functional> 헤더파일에 선언되어 있는 greater&lt;자료형&gt;() 을 전달하여 내림차순으로 정렬을 수행할 수 있다.<br>(less&lt;자료형&gt;()은 오름차순 정렬을 해주지만 default와 동일하므로 생략한다.)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">desc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">// 내림차순 정렬을 수행할 비교 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">int</span>)time(<span class="literal">NULL</span>)); <span class="comment">// 시드 값 설정</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">int</span> vsize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vsize; i++)</span><br><span class="line">vec.push_back(rand() % <span class="number">10</span> + <span class="number">1</span>); <span class="comment">// 벡터에 1 ~ 10의 난수 삽입</span></span><br><span class="line"><span class="comment">// N ~ (M+N-1) 까지 난수 생성 : rand() % M + N</span></span><br><span class="line"></span><br><span class="line">printArray(vec, vsize);</span><br><span class="line">sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// [vec.begin(), vec.end()) 내림차순 정렬</span></span><br><span class="line">  <span class="comment">// greater&lt;int&gt;() 대신 desc를 넣어도 같은 결과</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printArray(vec, vsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>출력</strong></p><div style="width: 200px; height: 80px;">  <img src="https://kyu9341.github.io/img/sort2.png" style="width: 200px  ; height: 80px;"></div></blockquote></functional></li></ul><ul><li><strong>기준을 지정하여 정렬 - compare함수</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="built_in">vector</span>&lt;Student&gt; &amp;vec, <span class="keyword">int</span> n)</span> <span class="comment">//  출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[ 이름 : "</span> &lt;&lt; vec[i].name &lt;&lt; <span class="string">", 나이 : "</span> &lt;&lt; vec[i].age &lt;&lt; <span class="string">", 점수 : "</span> &lt;&lt; vec[i].score &lt;&lt; <span class="string">" ]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Student a, Student b)</span> <span class="comment">// 내림차순 정렬을 수행할 비교 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.score == b.score) <span class="comment">// 점수가 같으면 -&gt; 나이가 적은 순</span></span><br><span class="line"><span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 점수가 다르면 -&gt; 점수 높은 순(내림차순)</span></span><br><span class="line"><span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vec;</span><br><span class="line"><span class="keyword">int</span> vsize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vec.push_back(Student(<span class="string">"kwon"</span>, <span class="number">25</span>, <span class="number">100</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"kim"</span>, <span class="number">24</span>, <span class="number">88</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"shin"</span>, <span class="number">29</span>, <span class="number">97</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"jung"</span>, <span class="number">27</span>, <span class="number">75</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"park"</span>, <span class="number">22</span>, <span class="number">88</span>)); <span class="comment">// 점수가 같으면 나이가 적은 순</span></span><br><span class="line"></span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), compare);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>출력</strong></p><div style="width: 250px; height: 200px;">  <img src="https://kyu9341.github.io/img/sort3.png" style="width: 250px  ; height: 200px;"></div></blockquote></li></ul><ul><li><strong>연산자 오버로딩을 통한 정렬(operator overloading)</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">Student(<span class="built_in">string</span> name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line"><span class="keyword">this</span>-&gt;score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 오버로딩 '&lt;' (클래스 내부)</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Student&amp; student)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;age &lt; student.age; <span class="comment">// 나이 오름차순으로 정렬</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="built_in">vector</span>&lt;Student&gt;&amp; vec, <span class="keyword">int</span> n)</span> <span class="comment">//  출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[ 이름 : "</span> &lt;&lt; vec[i].name &lt;&lt; <span class="string">", 나이 : "</span> &lt;&lt; vec[i].age &lt;&lt; <span class="string">", 점수 : "</span> &lt;&lt; vec[i].score &lt;&lt; <span class="string">" ]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vec;</span><br><span class="line"><span class="keyword">int</span> vsize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vec.push_back(Student(<span class="string">"kwon"</span>, <span class="number">25</span>, <span class="number">100</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"kim"</span>, <span class="number">24</span>, <span class="number">88</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"shin"</span>, <span class="number">29</span>, <span class="number">97</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"jung"</span>, <span class="number">27</span>, <span class="number">75</span>));</span><br><span class="line">vec.push_back(Student(<span class="string">"park"</span>, <span class="number">22</span>, <span class="number">88</span>));</span><br><span class="line"></span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printStudent(vec, vsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>출력</strong></p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/sort4.png" style="width: 250px    ; height: 200px;"></div></blockquote><blockquote><p>참조<br><a href="https://www.acmicpc.net/blog/view/22" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/blog/view/22</a><br><a href="https://hongku.tistory.com/153" target="_blank" rel="external nofollow noopener noreferrer">https://hongku.tistory.com/153</a><br><a href="https://blockdmask.tistory.com/178" target="_blank" rel="external nofollow noopener noreferrer">https://blockdmask.tistory.com/178</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;STL-sort-함수&quot;&gt;&lt;a href=&quot;#STL-sort-함수&quot; class=&quot;headerlink&quot; title=&quot;STL sort() 함수&quot;&gt;&lt;/a&gt;STL sort() 함수&lt;/h2&gt;&lt;p&gt;&lt;algorithm&gt; 헤더파일에서 제공하는 STL로서 
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>크루스칼(Kruskal Algorithm) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/09/algorithmKruskal/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/09/algorithmKruskal/</id>
    <published>2020-01-09T11:21:30.000Z</published>
    <updated>2020-01-12T13:36:20.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="크루스칼-Kruskal-Algorithm"><a href="#크루스칼-Kruskal-Algorithm" class="headerlink" title="크루스칼(Kruskal Algorithm)"></a>크루스칼(Kruskal Algorithm)</h2><p>크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘이다. 즉, 최소 비용 신장 트리를 만들기 위한 대표적인 알고리즘이라고 할 수 있다. 흔히 여러 개의 도시가 있을 때 각 도시의 도로를 이용해 비용을 최소한으로 연결하고자 할 때 실제로 적용되는 알고리즘이다.</p><p>아래의 그래프를 보면 노드는 7개이고 간선의 갯수는 11개이다.</p><div style="width: 410px; height: 620px;">    <img src="https://kyu9341.github.io/img/kruskal1.png" style="width: 410px    ; height: 620px;"></div><p>위와 같은 그래프를 최소한의 비용으로 연결만 하고자 한다면 어떻게 해야할까?</p><p>일단 모든 노드를 최대한 적은 비용으로 연결만 시키면 되는 것이기 때문에 모든 간선의 정보를 오름차순으로 정렬하여 비용이 적은 간선부터 하나씩 그래프에 포함시키면 될 것이다.</p><ul><li><p>노드 1</p><ul><li>(1, 7) [12]</li><li>(1, 4) [28]</li><li>(1, 2) [67]</li><li>(1, 5) [17]</li></ul></li><li><p>노드 2</p><ul><li>(2, 4) [24]</li><li>(2, 5) [62]</li></ul></li><li><p>노드 3</p><ul><li>(3, 5) [20]</li><li>(3, 6) [37]</li></ul></li><li><p>노드 4</p><ul><li>(4, 7) [13]</li></ul></li><li><p>노드 3</p><ul><li>(5, 6) [45]</li><li>(5, 7) [73]</li></ul></li></ul><p>우선 위와 같이 간선의 정보들을 저장한다. 노드 1부터 노드 7까지 연결된 모든 간선을 정보를 저장한 것이다. 6, 7이 정보가 없는 이유는 이미 다른 노드들의 간선 정보에 모두 포함되었기 때문이다. 이렇게 총 11개의 간선 정보를 간선의 비용을 기준으로 오름차순 정렬을 수행해보자.</p><ul><li>정렬된 간선 정보<ul><li>(1, 7) [12]</li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><p>이제 다음과 같은 규칙에 따라 그래프를 연결하면 된다.</p><ol><li>정렬된 순서에 맞게 그래프에 포함시킨다.</li><li>포함시키기 전에는 사이클 테이블을 확인한다.</li><li>사이클을 형성하는 경우 간선을 포함하지 않는다.</li></ol><p>여기서 사이클은 그래프가 서로 연결되어 아래와 같이 사이클을 형성하는 경우이다. 최소 비용 신장 트리에서는 사이클이 발생하면 안된다. 모든 노드를 연결하기만 하면 되는데 사이클이 발생한다는 것은 이미 연결된 노드끼리 다시 연결한다는 뜻이기 때문이다.</p><div style="width: 300px; height: 400px;">    <img src="https://kyu9341.github.io/img/kruskal2.png" style="width: 300px    ; height: 400px;"></div><p>사이클이 발생의 여부는 저번 포스팅의 Union-Find 알고리즘을 적용하여 구할 수 있다.</p><p>초기 상태는 다음과 같을 것이다.</p><ul><li>정렬된 간선 정보<ul><li>(1, 7) [12]</li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><ul><li>사이클 테이블<table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table></li></ul><p>이제 첫 번째 간선부터 시작하면</p><h5 id="첫-번째-간선-선택"><a href="#첫-번째-간선-선택" class="headerlink" title="첫 번째 간선 선택"></a>첫 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 170px; height: 150px;">      <img src="https://kyu9341.github.io/img/kruskal3.png" style="width: 170px      ; height: 150px;">  </div></li></ul><h5 id="두-번째-간선-선택"><a href="#두-번째-간선-선택" class="headerlink" title="두 번째 간선 선택"></a>두 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li>(1, 7) [12]</li><li><strong>(4, 7) [13]</strong></li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">5</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 280px; height: 180px;">      <img src="https://kyu9341.github.io/img/kruskal4.png" style="width: 280px      ; height: 180px;">  </div></li></ul><h5 id="세-번째-간선-선택"><a href="#세-번째-간선-선택" class="headerlink" title="세 번째 간선 선택"></a>세 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 300px;">      <img src="https://kyu9341.github.io/img/kruskal5.png" style="width: 300px      ; height: 300px;">  </div></li></ul><h5 id="네-번째-간선-선택"><a href="#네-번째-간선-선택" class="headerlink" title="네 번째 간선 선택"></a>네 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal6.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="다섯-번째-간선-선택"><a href="#다섯-번째-간선-선택" class="headerlink" title="다섯 번째 간선 선택"></a>다섯 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal7.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="여섯-번째-간선-선택"><a href="#여섯-번째-간선-선택" class="headerlink" title="여섯 번째 간선 선택"></a>여섯 번째 간선 선택</h5><ul><li>정렬된 간선 정보<ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><p>이 때 1과 4가 이미 연결되어 있으므로 무시하고 넘어간다. 사이클 테이블의 값이 서로 동일한 것을 보면 된다.</p><ul><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal7.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="일곱-번째-간선-선택"><a href="#일곱-번째-간선-선택" class="headerlink" title="일곱 번째 간선 선택"></a>일곱 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li><strong>(3, 6) [37]</strong></li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal8.png" style="width: 300px      ; height: 400px;">  </div></li></ul><p>위와 같이 사이클 테이블의 값이 모두 1이 되며 최소 비용 신장 트리가 완성된 것을 볼 수 있다. 나머지 남은 4개의 간선은 모두 연결되어 있으므로 스킵하여 다음과 같이 완성된다.</p><h5 id="완성"><a href="#완성" class="headerlink" title="완성"></a>완성</h5><ul><li>정렬된 간선 정보<ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li><strong>(3, 6) [37]</strong></li><li><del>(5, 6) [45]</del></li><li><del>(2, 5) [62]</del></li><li><del>(1, 2) [67]</del></li><li><del>(5, 7) [73]</del></li></ul></li></ul><ul><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal9.png" style="width: 300px      ; height: 400px;">  </div></li></ul><p>따라서 총 비용은 12 + 13 + 17 + 20 + 24 + 37 = 123 이 된다. 코드로 구현해 보면 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> // 하나의 간선 정보를 담는 클래스</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">2</span>]; <span class="comment">// 서로 연결된 두 개의 노드 정보</span></span><br><span class="line"><span class="keyword">int</span> distance; <span class="comment">// 비용 정보</span></span><br><span class="line">Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> distance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;node[<span class="number">0</span>] = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;node[<span class="number">1</span>] = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;distance = distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Edge &amp;edge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;distance &lt; edge.distance; <span class="comment">// 거리가 작은 간선이 먼저 출력</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부모 노드를 찾는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="keyword">return</span> x; <span class="comment">// 부모 노드가 자신인 경우 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> parent[x] = getParent(parent, parent[x]);</span><br><span class="line"><span class="comment">// 부모 노드의 값과 자신이 다르다면 재귀 호출</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 부모 노드를 합치는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) parent[b] = a; <span class="comment">// 더 작은 값을 부모 노드로 지정</span></span><br><span class="line"><span class="keyword">else</span> parent[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 같은 부모를 가지는지 확인</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 같은 부모를 가진다면 1을 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 다르다면 0리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> node = <span class="number">7</span>; <span class="comment">// 노드의 개수</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">line</span> = <span class="number">11</span>; <span class="comment">// 간선의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; v; <span class="comment">// 간선 정보를 담을 벡터</span></span><br><span class="line"><span class="comment">// 11개의 간선 정보를 벡터에 담음</span></span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">7</span>, <span class="number">12</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">28</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">67</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">5</span>, <span class="number">17</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">24</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">62</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">20</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">3</span>, <span class="number">6</span>, <span class="number">37</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">45</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">5</span>, <span class="number">7</span>, <span class="number">73</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 간선의 비용을 기준으로 오름차순 정렬</span></span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 각 정점이 포함된 그래프가 어디인지 저장</span></span><br><span class="line"><span class="keyword">int</span> parent[node];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 합계</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123; <span class="comment">// 사이클이 발생하지 않는 경우 그래프에 포함</span></span><br><span class="line"><span class="keyword">if</span> (!findParent(parent, v[i].node[<span class="number">0</span>] - <span class="number">1</span>, v[i].node[<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">&#123; <span class="comment">// parent[]는 0부터 시작했기 때문에 각 노드 번호에서 1을 빼줘야 일치함</span></span><br><span class="line">sum += v[i].distance; <span class="comment">// 연결한 노드의 거리를 누적</span></span><br><span class="line">unionParent(parent, v[i].node[<span class="number">0</span>] - <span class="number">1</span>, v[i].node[<span class="number">1</span>] - <span class="number">1</span>); <span class="comment">// 연결되었으므로 부모를 합침</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 합계 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/kruskal10.png" style="width: 100px     ; height: 50px;"> </div><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230994142" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230994142</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;크루스칼-Kruskal-Algorithm&quot;&gt;&lt;a href=&quot;#크루스칼-Kruskal-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;크루스칼(Kruskal Algorithm)&quot;&gt;&lt;/a&gt;크루스칼(Kruskal Algori
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2021-02-04T06:42:04.301Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WEB - 하드웨어 가속</title>
    <link href="https://kyu9341.github.io/WEB/2021/02/03/WEB_GPU/"/>
    <id>https://kyu9341.github.io/WEB/2021/02/03/WEB_GPU/</id>
    <published>2021-02-03T12:12:28.000Z</published>
    <updated>2021-02-04T06:42:04.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="하드웨어-가속"><a href="#하드웨어-가속" class="headerlink" title="하드웨어 가속"></a>하드웨어 가속</h1><p>특정 작업을 CPU가 아닌 다른 특별한 장치를 통해 수행 속도를 높이는 것을 ‘하드웨어 가속(hardware accelerated)’이라 한다. 그래픽이나 사운드와 관련된 작업에 하드웨어 가속을 많이 사용한다.</p><p><strong>브라우저에서 하드웨어 가속은 GPU를 이용하여 CPU의 처리량을 줄이고, 브라우저의 렌더링을 효율화하는 것을 말한다. CSS 작업에 하드웨어 가속을 활성화하면, 작업 처리가 빨라져서 웹페이지의 렌더링을 보다 빠르게 할 수 있다.</strong></p><h2 id="프론트엔드-개발자가-GPU를-사용하는-방법"><a href="#프론트엔드-개발자가-GPU를-사용하는-방법" class="headerlink" title="프론트엔드 개발자가 GPU를 사용하는 방법"></a>프론트엔드 개발자가 GPU를 사용하는 방법</h2><p>프론트엔드 개발자가 브라우저 렌더링 시에 GPU를 사용하도록 만드려면 어떻게 해야할까? 이런 내용을 받아들이기 위해서는 먼저 브라우저의 <code>Layer Model</code>에 대해 이해해야 할 것 같다.</p><h2 id="Layer-Model-크롬-기준"><a href="#Layer-Model-크롬-기준" class="headerlink" title="Layer Model (크롬 기준)"></a>Layer Model (크롬 기준)</h2><p>최근 브라우저들은 <code>Layout</code> 과정 이후 <code>Update Layer Tree</code> 라는 단계가 생겼다. <code>Render Object</code> 는 <code>Layout</code> 이후 정해진 기준에 따라 Layer를 나눈다. Layer는 웹 페이지를 렌더링하기 위해 필요한 이미지 단위 요소로 브라우저의 Layer는 다음의 두 가지로 나뉜다.</p><ol><li><code>Render Layer</code></li><li><code>Graphics Layer</code></li></ol><p><img src="https://user-images.githubusercontent.com/49153756/106854300-65c3f700-66fe-11eb-844b-aea642a3987a.png" alt="render"></p><blockquote><p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="external nofollow noopener noreferrer">이미지 출처</a></p></blockquote><p>브라우저는 화면에 표현되는 요소를 <code>RenderObject 트리</code>로 구성한다. <code>RenderObject 트리</code>의 노드는 <code>z-index</code> 속성이나 중첩 등을 처리하기 고안된 <code>RenderLayer</code>에 대응된다.</p><p><code>RenderLayer</code> 가운데 실제 화면에 출력돼야 하는 노드는 다시 <code>GraphicsLayer</code>를 생성한다. <code>최상위(root) 노드</code>나 <code>&lt;canvas&gt;</code>, <code>&lt;video&gt;</code> 등이 <code>GraphicsLayer</code>를 생성하는 <code>RenderLayer</code>다.</p><h3 id="Render-Layer"><a href="#Render-Layer" class="headerlink" title="Render Layer"></a>Render Layer</h3><p>각 <code>Render Object</code>의 속성에 따라 <code>RenderLayer</code>에 할당된다. <code>RenderLayer</code> 는 페이지의 요소가 겹치는 컨텐츠나 반투명한 요소 등을 올바로 합성되어 표시하기 위해 존재하고, 일반적으로 아래와 같은 상황에 <code>RenderLayer</code> 가 생성된다고 한다.</p><ul><li>페이지의 루트 개체 (<code>root layer</code> : 최상위 레이어)</li><li><code>CSS position</code> 속성 (<code>relative</code>, <code>absolute</code> 또는 <code>transform</code>)</li><li>투명도를 가지는 경우</li><li>CSS 필터를 가지는 경우</li><li>3D 컨텍스트(<code>WebGL</code>) 혹은 하드웨어 가속 2D 컨텍스트를 가지는 <code>&lt;canvas&gt;</code> 엘리먼트</li><li><code>&lt;video&gt;</code> 엘리먼트</li></ul><p>동일한 좌표 공간을 공유하는 <code>RenderObject</code> 는 일반적으로 동일한 <code>RenderLayer</code> 에 속한다. 또한, <code>RenderObject</code>와 <code>RenderLayer</code> 는 반드시 1:1로 매핑되는 것은 아니다.</p><h3 id="Graphics-Layer"><a href="#Graphics-Layer" class="headerlink" title="Graphics Layer"></a>Graphics Layer</h3><p>특정 <code>RenderLayer</code> 가 <code>GraphicsLayer</code> 생성 조건을 만족하면 <code>GraphicsLayer</code> 단위로 렌더링한 뒤 최종적으로 GPU를 통해 합성된다. <code>GraphicsLayer</code> 는 GPU에 텍스쳐로 업로드된다.</p><p><code>RenderLayer</code> 가 아래 조건 중 하나라도 만족하면 <code>GraphicsLayer</code> 를 가질 수 있다.</p><ul><li>3D나 <code>perspective</code>를 표현하는 <code>CSS transform</code> 속성을 가진 경우</li><li>하드웨어 가속 디코딩을 사용하는 <code>&lt;video&gt;</code> 엘리먼트</li><li>3D 컨텍스트(<code>WebGL</code>) 혹은 하드웨어 가속 2D 컨텍스트를 가지는 <code>&lt;canvas&gt;</code> 엘리먼트</li><li>투명도(<code>opacity</code>) 속성 혹은 <code>webkit transform</code>의 애니메이션의 사용</li><li>가속 가능한 CSS 필터를 가진 경우</li><li>합성 레이어(<code>Compositing Layer</code>)를 하위 노드로 가진 경우</li><li><code>z-index</code> 값이 낮은 형제 레이어를 갖는 경우 (즉, 레이어의 상단에 렌더링되는 경우)</li></ul><p>즉, 프론트엔드 개발자가 브라우저 렌더링 시에 GPU를 사용하려면 위의 <code>GraphicsLayer</code> 를 생성하도록 개발하면 될 것이다.</p><h3 id="그럼-어떻게-사용하면-좋을까"><a href="#그럼-어떻게-사용하면-좋을까" class="headerlink" title="그럼 어떻게 사용하면 좋을까?"></a>그럼 어떻게 사용하면 좋을까?</h3><p><strong>Layout, Paint 비용 줄이기</strong></p><p><code>Layout</code> , <code>Paint</code> 를 발생시키는 속성 대신 GPU가 처리할 수 있는 변형을 이용하여 같은 효과를 구현한다.</p><ul><li><code>left</code> / <code>top</code> 에 의한 이동은 <code>transform: translate</code> 를 이용한다.</li><li><code>show</code> / <code>hide</code> 는 <code>alpha</code> 값을 이용하는 <code>opacity</code> 속성을 이용한다.</li></ul><p>위와 같이 사용한다면 CPU에서 레이아웃을 다시 계산하지 않아도 GPU단에서 바로 처리가 가능하다. <code>Layout</code> , <code>Paint</code> 과정을 다시 거치지 않고, 바로 GPU에서 <code>Composite</code> 과정만으로 처리할 수 있어 훨씬 빠르게 렌더링을 할 수 있다.</p><h3 id="그렇다면-모든-작업을-GPU에게-몰아버리는-것이-좋을까"><a href="#그렇다면-모든-작업을-GPU에게-몰아버리는-것이-좋을까" class="headerlink" title="그렇다면, 모든 작업을 GPU에게 몰아버리는 것이 좋을까?"></a>그렇다면, 모든 작업을 GPU에게 몰아버리는 것이 좋을까?</h3><p><img src="https://user-images.githubusercontent.com/49153756/106854303-678dba80-66fe-11eb-9d47-77ae1632a82a.png" alt="GPU"></p><blockquote><p><a href="https://medium.com/@cwdoh/프론트엔드-개발자를-위한-크롬-렌더링-성능-인자-이해하기-4c9e4d715638" target="_blank" rel="external nofollow noopener noreferrer">이미지 출처</a></p></blockquote><p>위의 그림과 같이 CPU는 데이터를 처리하기 위해서 이를 메인 메모리(RAM)으로 가져와야 한다. 이와 마찬가지로 GPU에서 데이터를 처리하기 위해서는 VRAM이라는 비디오 메모리로 데이터를 가져와 처리하게 된다.</p><p>따라서, GPU에서 데이터를 처리하기 위해서는 RAM에서 VRAM으로 데이터를 전달하는 과정이 필요하다. 이 과정에서 texture를 계속해서 옮겨야 하는 상황이라면 그에 따른 오버헤드가 발생할 수 있다.</p><p>또한, 일반적으로 GPU가 texture를 받아 처리하기 위해서는 CPU에서 RAM에 texture를 로드하고, 이를 GPU로 보내게 된다. 즉, CPU가 GPU에서 사용될 데이터를 처리하는 시간이 소요된다.</p><h3 id="강제로-GPU-가속을-사용하도록-하는-방법"><a href="#강제로-GPU-가속을-사용하도록-하는-방법" class="headerlink" title="강제로 GPU 가속을 사용하도록 하는 방법"></a>강제로 GPU 가속을 사용하도록 하는 방법</h3><p>특정한 요소에 GPU 가속을 적용하고 싶은 경우에는 레이어 핵(layer hack)이라고 부르는 방법을 사용할 수 있다. 레이어 핵은 하드웨어 가속을 위해 <code>CSS 3D</code> 속성을 추가해 특정 요소를 <code>GraphicsLayer</code> 로 분리하도록 하는 기법이다. <code>transform</code> 속성에 <code>translate3d(0,0,0)</code>나 <code>translateZ(0)</code> 등을 지정함으로써 하드웨어 가속을 활성화할 수 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate3d</span>(0, 0, 0);</span><br></pre></td></tr></table></figure><p>그러나 레이어를 생성하는 것에는 그만한 비용이 필요하다. RAM이나 GPU의 메모리 사용량이 커지게 되고, 이러한 점은 데스크탑에 비해 메모리 용량이 크지 않은 모바일 기기에서 큰 영향을 끼칠 수 있다. 따라서 하드웨어 가속을 적용할 때는 이를 통해 렌더링이 빨라지는지, 다른 문제는 발생하지 않는지 확인을 하고 적용해야 한다.</p><p>이런 레이어 핵을 대체하기 위한 새로운 CSS 속성이 등장했는데, 바로 <code>will-change</code> 라는 속성이다.</p><h3 id="will-change-속성"><a href="#will-change-속성" class="headerlink" title="will-change 속성"></a><code>will-change</code> 속성</h3><blockquote><p><a href="https://caniuse.com/?search=will-change" target="_blank" rel="external nofollow noopener noreferrer">지원 브라우저 확인</a></p></blockquote><p><code>will-change</code> 은 엘리먼트에 어떠한 변경을 할 것이라는 것을 브라우저에게 미리 알려주는 속성이다. 미리 알려주게 되면 브라우저는 해당 변경을 위한 작업을 사전에 최적화하여 실제 변경이 발생될 때 더 빠르게 업데이트를 할 수 있게 된다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">will-change</span>: <span class="selector-tag">transform</span>, <span class="selector-tag">opacity</span>;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>will-change</code> 속성에 앞으로 일어날 변경이 적용될 속성을 넣어주면 된다. 이 속성 또한 불필요한 곳에 남용하면 오히려 성능 저하를 불러올 수 있는데, 이에 대한 자세한 활용은 추후에 직접 사용해보며 알아보도록 해야겠다.</p><blockquote><p>참조</p><p><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome" target="_blank" rel="external nofollow noopener noreferrer">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a></p><p><a href="https://blog.jaysiyo.com/critical-rendering-path" target="_blank" rel="external nofollow noopener noreferrer">https://blog.jaysiyo.com/critical-rendering-path</a></p><p><a href="https://velog.io/@kimu2370/Layer-model" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@kimu2370/Layer-model</a></p><p><a href="http://pjh0718.blogspot.com/2017/03/blink-layer.html" target="_blank" rel="external nofollow noopener noreferrer">http://pjh0718.blogspot.com/2017/03/blink-layer.html</a></p><p><a href="https://web-atelier.tistory.com/39" target="_blank" rel="external nofollow noopener noreferrer">https://web-atelier.tistory.com/39</a></p><p><a href="https://sculove.github.io/slides/improveBrowserRendering/#/7" target="_blank" rel="external nofollow noopener noreferrer">https://sculove.github.io/slides/improveBrowserRendering/#/7</a></p><p><a href="https://medium.com/@cwdoh/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%ED%81%AC%EB%A1%AC-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%84%B1%EB%8A%A5-%EC%9D%B8%EC%9E%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-4c9e4d715638" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/@cwdoh/프론트엔드-개발자를-위한-크롬-렌더링-성능-인자-이해하기-4c9e4d715638</a></p><p><a href="https://d2.naver.com/helloworld/2061385" target="_blank" rel="external nofollow noopener noreferrer">https://d2.naver.com/helloworld/2061385</a></p><p><a href="https://d2.naver.com/helloworld/2922312" target="_blank" rel="external nofollow noopener noreferrer">https://d2.naver.com/helloworld/2922312</a></p><p><a href="https://medium.com/@gotppetto/%EC%9B%B9-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-gpu%EA%B0%80%EC%86%8D-1b027b2b355d" target="_blank" rel="external nofollow noopener noreferrer">https://medium.com/@gotppetto/웹-애니메이션-gpu가속-1b027b2b355d</a></p><p><a href="https://nykim.work/81" target="_blank" rel="external nofollow noopener noreferrer">https://nykim.work/81</a></p><p><a href="https://www.slideshare.net/deview/125-119068291" target="_blank" rel="external nofollow noopener noreferrer">https://www.slideshare.net/deview/125-119068291</a></p><p><a href="https://www.html5rocks.com/ko/tutorials/speed/high-performance-animations/" target="_blank" rel="external nofollow noopener noreferrer">https://www.html5rocks.com/ko/tutorials/speed/high-performance-animations/</a></p><p><a href="https://ui.toast.com/fe-guide/ko_PERFORMANCE" target="_blank" rel="external nofollow noopener noreferrer">https://ui.toast.com/fe-guide/ko_PERFORMANCE</a></p><p><a href="https://wit.nts-corp.com/2017/08/31/4861" target="_blank" rel="external nofollow noopener noreferrer">https://wit.nts-corp.com/2017/08/31/4861</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;하드웨어-가속&quot;&gt;&lt;a href=&quot;#하드웨어-가속&quot; class=&quot;headerlink&quot; title=&quot;하드웨어 가속&quot;&gt;&lt;/a&gt;하드웨어 가속&lt;/h1&gt;&lt;p&gt;특정 작업을 CPU가 아닌 다른 특별한 장치를 통해 수행 속도를 높이는 것을 ‘하드웨어 가
      
    
    </summary>
    
    
      <category term="WEB" scheme="https://kyu9341.github.io/categories/WEB/"/>
    
    
      <category term="WEB" scheme="https://kyu9341.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>WEB - 브라우저 동작 원리</title>
    <link href="https://kyu9341.github.io/WEB/2021/01/24/WEB_BrowserRendering/"/>
    <id>https://kyu9341.github.io/WEB/2021/01/24/WEB_BrowserRendering/</id>
    <published>2021-01-24T12:12:28.000Z</published>
    <updated>2021-02-06T07:46:09.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="브라우저-동작-원리"><a href="#브라우저-동작-원리" class="headerlink" title="브라우저 동작 원리"></a>브라우저 동작 원리</h1><h3 id="렌더링-과정-요약"><a href="#렌더링-과정-요약" class="headerlink" title="렌더링 과정(요약)"></a>렌더링 과정(요약)</h3><ul><li>HTML을 파싱하여 <strong>DOM 객체</strong>를 생성하고, CSS를 파싱하여 <strong>CSSOM</strong>을 만든다.</li><li>이 두개를 합쳐서 실제로 웹 브라우저에 보여져야할 요소를 표현한 <strong>렌더 트리</strong>를 만든다.</li><li>이 렌더 트리를 기준으로 <strong>레이아웃을 배치</strong>하고 <strong>색을 칠하는 등의 작업</strong>을 한다.</li></ul><h2 id="Critical-Rendering-Path"><a href="#Critical-Rendering-Path" class="headerlink" title="Critical Rendering Path"></a>Critical Rendering Path</h2><ul><li>브라우저가 하나의 화면을 나타내는 과정</li></ul><ol><li>HTML데이터를 파싱한다.</li><li>파싱한 결과로 DOM Tree를 만든다.</li><li>파싱 중 CSS파일 링크를 만나면 CSS파일을 요청해서 받고, CSS 파일을 읽어 CSSOM(CSS Object Model)을 만든다.</li><li>DOM Tree와 CSSOM을 사용해 Render Tree를 만든다.</li><li>Render Tree의 노드들이 화면의 어디에 위치할지 계산한다.</li><li>웹페이지를 그린다.</li></ol><h3 id="1-HTML-데이터를-파싱"><a href="#1-HTML-데이터를-파싱" class="headerlink" title="1. HTML 데이터를 파싱"></a>1. HTML 데이터를 파싱</h3><p>브라우저는 응답으로 받아온 HTML문서를 DOM으로 만들기 위해 각각의 요소를 파싱한다. 이 과정에서 미디어파일(이미지나 비디오등)을 만나면 추가 요청을 보낸다. 또한 JavaScript를 만나면 실행할 때까지 파싱을 멈춘다.</p><h3 id="2-DOM-Tree-구성"><a href="#2-DOM-Tree-구성" class="headerlink" title="2. DOM Tree 구성"></a>2. DOM Tree 구성</h3><p><img src="https://user-images.githubusercontent.com/49153756/103270806-29fd8980-49fc-11eb-82e3-922feaed0cd4.png" alt="Screen Shot 2020-12-29 at 03 39 15 AM"></p><p>브라우저는 읽어들인 HTML 바이트 데이터를 해당 파일에 지정된 인코딩(ex: <code>UTF-8</code>)에 따라 문자열로 바꾸게 된다. 이렇게 바꾼 문자열을 다시 읽어서, HTML 토큰으로 변환한다. 태그의 경우 <code>StartTag</code>와 <code>EndTag</code>로 변환된다.</p><p>토큰들은 다시 노드로 바뀌는데(렉싱), <code>StartTag</code>와 <code>EndTag</code>사이에 있는 노드들은 자식노드로 들어간다. 즉 트리모양이 되는데, 이 과정이 끝나면 DOM Tree가 생성되는 것이다.</p><h3 id="3-CSSOM-구성"><a href="#3-CSSOM-구성" class="headerlink" title="3. CSSOM 구성"></a>3. CSSOM 구성</h3><p>HTML을 파싱하다 CSS링크를 만나면, CSS파일을 받아온다. CSS파일은 파싱과정을 거쳐 Tree형태의 CSSOM으로 만들어진다. CSS 파싱은 <code>cascading</code>규칙(부모의 특성을 자식이 이어받음)이 추가되는 점을 제외하고는 HTML파싱과 동일하다.</p><p>CSSOM(<code>CSS Object Model</code>)이 구성이 되어야 다음 과정으로 넘어갈 수 있기 때문에, CSS는 렌더링의 blocking 요소라고도 한다.</p><p><img src="https://user-images.githubusercontent.com/49153756/103270821-2e29a700-49fc-11eb-9fcd-8807a27df98e.png" alt="Screen Shot 2020-12-29 at 02 43 06 AM"></p><h3 id="4-Render-Tree-구성"><a href="#4-Render-Tree-구성" class="headerlink" title="4. Render Tree 구성"></a>4. Render Tree 구성</h3><p>DOM 및 CSSOM 트리는 결합되어 Render Tree를 형성한다. Render Tree는 DOM Tree에 있는 것들 중에 실제 페이지를 렌더링하는 데 필요한 노드들만 포함된다.</p><p>즉, <code>display:none</code>으로 설정되어 있는 것은 DOM Tree에 있어도 Render Tree에는 없다. 마찬가지로 DOM Tree 중 일부 노드(<code>&lt;head&gt;</code>, <code>&lt;title&gt;</code>, <code>&lt;script&gt;</code> 등)는 화면에 표현되는 노드가 아니기 때문에 Render Tree에 포함되지는 않는다.</p><h3 id="5-Layout-Reflow"><a href="#5-Layout-Reflow" class="headerlink" title="5. Layout(Reflow)"></a><strong>5. Layout(Reflow)</strong></h3><p>Render Tree가 만들어지면, 이제 각각의 노드들의 정확한 크기와 위치를 계산하는 과정을 거친다. 이 과정을 Layout과정이라고 한다. <code>position</code>, <code>width</code>, <code>height</code> 등 위치 및 크기에 관련된 부분들을 계산한다.</p><p><code>width:100%</code>인 상태에서 브라우저를 리사이즈하면, Render Tree는 변경되지 않고 Layout 이후 과정만 다시 거치게 된다.</p><h3 id="6-Paint"><a href="#6-Paint" class="headerlink" title="6. Paint"></a><strong>6. Paint</strong></h3><p><code>Layout</code>과정을 거쳐 계산을 마치면, 실제 그리는 작업(Paint)을 수행한다. 실제로 픽셀이 화면에 그려지며, 만약 <code>Render Layer</code>가 2개 이상이면 각각의 Layer를 그린 뒤 하나의 이미지로 <code>Composite</code>하는 과정을 거친 뒤 브라우저에 실제로 그려지게 된다.</p><p>색이 바뀐다거나 노드의 스타일이 바뀌는 걸로는 <code>Layout</code> 과정을 거치지 않고 <code>Paint</code>만 일어난다.</p><hr><h3 id="Reflow"><a href="#Reflow" class="headerlink" title="Reflow"></a>Reflow</h3><p><code>height</code>, <code>width</code>, <code>left</code>, <code>top</code>, <code>font-size</code>, <code>line-height</code> 등의 속성이 변경되는 경우 발생하며, 변경이 필요한 렌더 트리에 대한 유효성 확인 작업과 함께 <strong>노드의 크기와 위치를 다시 계산</strong>한다. 좀 더 정확하게는 노드의 크기 또는 위치가 바뀌어 현재 레이아웃에 영향을 미쳐 배치를 다시 해야 할 때 <code>Reflow</code>가 발생한다.</p><p>특정 요소에 <code>Reflow</code>가 발생하면 요소의 DOM 구조에 따라 자식 요소와 부모 요소 역시 다시 계산될 수 있으며, 경우에 따라서는 문서 전체에 <code>Reflow</code>가 발생할 수도 있다.</p><h3 id="Repaint"><a href="#Repaint" class="headerlink" title="Repaint"></a>Repaint</h3><p>변경 영역의 결과를 표현하기 위해 화면이 업데이트되는 것을 의미한다.(<code>Reflow</code>만 수행되면 실제 화면에 반영되지 않는다.) <strong><code>Reflow</code>가 발생하거나 배경색 변경 등의 단순한 스타일 변경과 같은 작업이 발생하는 경우에 발생한다.</strong> 간단하게는 화면을 변경해야 할 때 발생한다고 생각하면 된다. 이러한 작업을 <code>Repaint</code> 또는 <code>Redraw</code>라고 한다.</p><p><code>border-radius</code> , <code>shadow-box</code> 등의 속성이 변경되는 경우, <code>img</code>의 <code>src</code>가 변경되어 이미지가 <code>decode</code> 되는경우, <code>Layout</code>이 수행된 경우 발생한다.</p><p><code>Reflow</code>와 <code>Repaint</code> 모두 처리 비용이 발생하지만 <code>Repaint</code>보다 <code>Reflow</code>의 비용이 훨씬 높다. <code>Reflow</code>는 변경 범위에 따라 전체 페이지의 레이아웃을 변경해야 할 수도 있다. 어느 경우든 <code>Reflow</code>와 <code>Repaint</code> 때문에 UI의 화면 표현이 느려져 UX에 영향을 줄 수 있으므로 코드를 작성할 때 이를 최소화해야 한다.</p><blockquote><p>참조</p><p><a href="https://bearjin90.tistory.com/19" target="_blank" rel="external nofollow noopener noreferrer">https://bearjin90.tistory.com/19</a></p><p><a href="https://boxfoxs.tistory.com/408" target="_blank" rel="external nofollow noopener noreferrer">https://boxfoxs.tistory.com/408</a></p><p><a href="https://12bme.tistory.com/140" target="_blank" rel="external nofollow noopener noreferrer">https://12bme.tistory.com/140</a></p><p><a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="external nofollow noopener noreferrer">https://d2.naver.com/helloworld/59361</a></p><p><a href="https://it-ist.tistory.com/110" target="_blank" rel="external nofollow noopener noreferrer">https://it-ist.tistory.com/110</a></p><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko" target="_blank" rel="external nofollow noopener noreferrer">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko</a></p><p><a href="https://isme2n.github.io/devlog/2017/07/06/browser-rendering/" target="_blank" rel="external nofollow noopener noreferrer">https://isme2n.github.io/devlog/2017/07/06/browser-rendering/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;브라우저-동작-원리&quot;&gt;&lt;a href=&quot;#브라우저-동작-원리&quot; class=&quot;headerlink&quot; title=&quot;브라우저 동작 원리&quot;&gt;&lt;/a&gt;브라우저 동작 원리&lt;/h1&gt;&lt;h3 id=&quot;렌더링-과정-요약&quot;&gt;&lt;a href=&quot;#렌더링-과정-요약&quot; c
      
    
    </summary>
    
    
      <category term="WEB" scheme="https://kyu9341.github.io/categories/WEB/"/>
    
    
      <category term="WEB" scheme="https://kyu9341.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>2020 부스트캠프 멤버십 회고</title>
    <link href="https://kyu9341.github.io/BoostCamp/2020/12/31/BoostCamp_MemberShip_review/"/>
    <id>https://kyu9341.github.io/BoostCamp/2020/12/31/BoostCamp_MemberShip_review/</id>
    <published>2020-12-30T15:12:28.000Z</published>
    <updated>2021-01-03T17:35:50.777Z</updated>
    
    <content type="html"><![CDATA[<p>5개월간의 부스트캠프에서의 여정이 모두 끝났다. 부스트캠프 멤버쉽 과정에서는 챌린지에서 배우고 익힌 자바스크립트를 기반으로 다양한 프로젝트를 진행했다. 멤버쉽 4개월의 여정은 6주간의 학습 스프린트 기간과 8주간의 그룹 프로젝트 기간으로 나뉜다.</p><h2 id="학습-스프린트-기간"><a href="#학습-스프린트-기간" class="headerlink" title="학습 스프린트 기간"></a>학습 스프린트 기간</h2><p>학습스프린트 기간은 6주 동안 2주 단위의 개인 프로젝트를 3번 진행했다. 2주는 또 1주일은 백엔드 구현, 나머지 1주일은 프론트엔드 구현으로 나누어졌다. 이 기간 동안에는 대부분의 라이브러리 사용 없이 바닐라js로 직접 구현을 해서 사용해야 했다.</p><p>첫 번째 프로젝트에서는 템플릿 엔진을 사용하여 서버사이드 렌더링을 하는 방식으로 구현을 해야했다. 나는 예전에 pug를 사용하여 간단한 프로젝트를 해본 경험이 있어서 첫 미션은 생각보다 수월했다. <code>passport</code> 나 <code>express-session</code> 같은 라이브러리 사용이 금지되었기 때문에 세션이나 인증 과정을 직접 구현해볼 수 있어서 쿠키와 세션 방식의 인증 흐름을 이해하는데에 많은 도움이 되었다.</p><p>두 번째 프로젝트부터는 SPA로 구현을 해봤는데, 이 때부터 프론트가 재밌어지기 시작했다.. 처음으로 <code>Webpack</code> 과 <code>Babel</code> 에 대해 알게되고, 직접 설정도 해봤다. 나만의 <a href="https://github.com/kyu9341/Webpack-Boilerplate" target="_blank" rel="external nofollow noopener noreferrer">보일러 플레이트</a>도 만들어 보았다. 각각의 컴포넌트를 클래스로 만들어 root 노드를 시작으로 <code>appendChild</code> 를 해주는 식으로 구현을 했다. 처음 폴더 구조를 어떻게 구성할지에 대해 고민을 많이 했었는데, 이 때는 <code>components</code> 폴더에 각각의 컴포넌트를 <code>js</code> 파일과 <code>scss</code> 파일을 하나의 폴더로 묶어서 관리했다. 바닐라로 처음 SPA를 만들어본 것이기 때문에 상태관리도 처음 해봤다. 현재 로그인된 사용자에 대한 상태를 <code>App.js</code> 부터 거의 리프 노드까지 일일이 하위 클래스의 생성자에 넣어 내려주는 방식으로 구현을 했었는데, 상당히 불편했다..</p><p>세 번째 프로젝트에는 프론트에 옵저버 패턴을 적용해봤다. 각각의 관심사별 모델을 <code>Observable</code> 클래스를 상속하는 싱글톤 클래스의 형태로 만들고, 전역으로 관리했다. 모델의 상태가 변경될 때 마다 구독자들에게 상태 변화를 알리는 메소드인 <code>notify</code> 를 호출하여 모델이 변화하면 모델은 구독한 뷰가 다시 렌더링되는 방식으로 구현했다. 처음으로 직접 디자인 패턴을 적용해봤는데, 이래서 디자인 패턴을 사용하는구나! 라는 생각이 들었다. 하지만 설계를 잘못하게 되면 예상치 못한 불필요한 렌더링이 발생할 수 있다는 것도 알게되었다.</p><p>폴더 구조도 두 번째와는 다르게 <code>components</code> 하위에 실제 <code>DOM</code>트리에 그려질 구조와 일치하게 계층적으로 관리해보려 했다. 장점으로는 실제 구조와 일치하기 때문에 원하는 파일을 찾기 편했고, 단점으로는 재사용성이 있는 컴포넌트의 경우 따로 관리하지 않으면 <code>import</code> 경로가 길어지고, 위치가 헷갈릴 수 있었다.</p><p>또 svg를 통해 데이터 시각화도 해보고 토큰 기반 인증도 배포 자동화 스크립트도 짜서 적용해보고 다양한 시도를 해볼 수 있었던 미션이었다. ㅎㅎ</p><p>학습 스프린트 기간동안 아쉬웠던 점은 내가 너무 구현에만 집중하지 않았나 하는 점이다. 마스터 클래스마다 항상 여러 캠퍼분들이 <code>요구사항 구현 vs 학습</code> 에 대한 질문을 많이 하셨다. 나 또한 많이 고민을 하며 프로젝트를 진행했지만 계속 요구사항 구현에 대한 비중이 더 컸던 것이 아닌가 싶다. 물론 학습을 안한 것은 아니다. 그렇지만 구현을 조금 덜 하더라도 조금 더 깊이 있게 학습할만한 부분에 있어서 더 투자를 했어도 좋지 않았을까.. 하는 아쉬움이 남는다. <del>그래서 지금 하는중..</del></p><h3 id="코드-리뷰-🖊"><a href="#코드-리뷰-🖊" class="headerlink" title="코드 리뷰 🖊"></a>코드 리뷰 🖊</h3><p>학습 스프린트 기간에는 정해진 요일마다(격주로.. 백엔드 리뷰어 지원이 없어서 프론트만 리뷰를 받았다) 배정받은 리뷰어님께 코드 리뷰도 받을 수 있었는데, 나는 정말 좋은 리뷰어님을 만나게 되어 꼼꼼하게 리뷰를 받을 수 있었고 진짜 많이 배울 수 있었다.</p><p>학습 스프린트가 끝나고 그룹 프로젝트 시작 전에 1주일의 기간이 있었는데, 그 때 같이 리뷰를 받았던 캠퍼님과 함께 리뷰어님을 오프라인으로 만났다. 밥도 사주시고 좋은 이야기도 많이 해주셔서 정말 재밌고 뜻깊은 시간이었다!</p><h2 id="그룹-프로젝트-👨‍👨‍👧‍👦"><a href="#그룹-프로젝트-👨‍👨‍👧‍👦" class="headerlink" title="그룹 프로젝트 👨‍👨‍👧‍👦"></a>그룹 프로젝트 👨‍👨‍👧‍👦</h2><p>이번 부스트캠프에서는 작년과는 다르게 그룹 프로젝트를 8주짜리 프로젝트로 한 번에 하지 않고, 3주와 5주로 나누어 두 차례에 걸쳐 진행했다.</p><h3 id="3주-프로젝트"><a href="#3주-프로젝트" class="headerlink" title="3주 프로젝트"></a><strong>3주 프로젝트</strong></h3><p>3주 프로젝트는 모든 팀이 같은 주제(GitHub Issue Tracker)를 가지고 진행했다. <code>웹 3명 + IOS 2명 팀</code>과 <code>웹 4명팀</code> 이렇게 두 종류에서 랜덤으로 팀을 배정받았다. 나는 <code>웹 4명</code> 인 팀으로 배정받아 다행이라고 생각했었다.. 그러나 프로젝트 진행 2일만에 팀원 중 한 분이 대학원 진학으로 인해 부캠을 그만두시는 바람에 3명이서 프로젝트를 진행하게 되었다.</p><p>첫 주는 거의 팀내 컨벤션이나 백로그 및 API 명세서, 이슈 작성 등 설계에 많은 시간을 투자했고, OAuth를 통한 GitHub 로그인 기능까지만 구현을 했다. 처음에 겁도 없이 TDD를 도입해보자고 하는 바람에 백엔드는 TDD로 진행을 했다.. 처음 시도해봤을 때는 개발 전에 틀을 잡고 진행할 수 있고, <code>postman</code> 대신 테스트 코드를 돌리는 것으로 간편하게 테스트를 할 수 있어서 좋았다. 유지보수 시 리팩토링 후에 특히 유용했다. 하지만, 개발 속도는 현저하게 떨어지는 단점이 있었다.. 조금 더 프로젝트의 크기가 커서 유지보수할 일이 많은 프로젝트였다면 TDD의 효율이 좋았겠지만, 3주짜리 프로젝트에서 TDD를 도입하는 것은 좋은 선택은 아니었던 것 같다.. (하지만 좋은 경험이었다!) 결국 프론트는 TDD를 적용하지 않았다.</p><p>프론트는 드디어 리액트를 사용하여 구현하게 되었는데, 3명의 팀원 중 리액트 경험이 있는 팀원이 한 분 계셨는데, 그분도 약간의 경험만 있으셨던 정도여서 초기에 학습에 많은 시간을 투자했다.</p><p>결국 목표했던 모든 기능을 구현하지는 못했지만 <code>hooks API</code> 의 사용법도 익히고 상태관리를 위해 <code>context API</code> 도 사용해보고 코드 퀄리티도 나름대로 팀원들과 많은 고민을 해가며 작성했기 때문에 뿌듯했다. 3주는 생각보다 많이 짧은 시간이었다.. 처음에는 <code>TypeScript</code> 까지 도입해보려 했는데 어림없는 생각이었던..</p><p>부스트캠프에서의 첫 팀 프로젝트를 하며 개발 프로세스를 경험할 수 있었고, 깃헙의 다양한 사용법도 익힐 수 있었다. 매일 아침 스크럼을 통해 진행 상황과 그날 할 일을 계획하고, 전날을 회고하며 개선점을 찾아봤다. 이슈 또한 템플릿을 작성하여 개발 전에 컴포넌트나 API 에 대한 명세 및 구조를 설계하여 이슈를 기반으로 개발을 진행했다. PR을 날릴 때에도 코드 리뷰를 꼼꼼하게 진행했다. <del>PR 크기가 좀..? 커졌던건 비밀..</del></p><h3 id="5주-프로젝트-🌊"><a href="#5주-프로젝트-🌊" class="headerlink" title="5주 프로젝트 🌊"></a><a href="https://github.com/boostcamp-2020/Project13-Web-Video-Editor" target="_blank" rel="external nofollow noopener noreferrer">5주 프로젝트 🌊</a></h3><p>마지막 5주 프로젝트는 네이버 기업과제로 진행됐다. 1지망부터 5지망까지를 선택하여 제출했는데, 주제들이 모두 흥미롭고 재미있어 보였다. 나는 1지망으로 “클라이언트 기반 웹 동영상 편집기” 라는 주제를 선택했고, 배정받을 수 있었다..! 이 주제를 선택한 이유는 음.. 어려워 보이고 재밌어 보여서..? 선택했다. 영상 편집이라는 주제도 흥미로웠고, 개발 요구사항의 <code>WebCodecs</code>, <code>WebGL</code>, <code>Web Assembly</code> 등의 처음 보는 기술들이 궁금했다.</p><p>3주 그룹 프로젝트를 이미 경험해봐서 그런지 초기 컨벤션이나 프로젝트 환경 구축은 생각보다 빠르게 진행되었다. 5주 프로젝트에서는 <code>이슈</code> 템플릿 뿐만 아니라, <code>PR</code> 템플릿과 <code>commit</code> 템플릿도 만들어서 사용해봤다. 추가로 3주 프로젝트에서 도입하지 못했던 <code>TypeScript</code> 도 도입하고, 상태관리를 위해 <code>Redux</code> 와 <code>Redux-Saga</code> 까지 도입을 했다.</p><p>프로젝트 초기에 가장 어려웠던 것이 두 가지 있었는데, 첫 번째로 <code>WebCodecs</code>, <code>WebGL</code>, <code>Web Assembly</code>, <code>TypeScript</code>, <code>Redux</code>, <code>Redux-Saga</code> 모두 한 번도 사용해본 적없는 기술들이었다는 점이다. 많은 기술을 빠르게 익히기 위해서 팀을 두 명씩 나누어 각각 하나의 주제를 학습하고 정리하여 공유하는 방식으로 다양한 기술들을 학습했다. 다행이었던 것은 <code>WebGL</code> 경험이 있는 팀원분이 계셔서 편집 효과를 적용하는 부분에 큰 기여를 해주셨다.</p><p>두 번째로는 프로젝트의 워크플로우를 잡는 것이었다. 팀원 모두 영상에 대한 도메인 지식이 부족한 상태였기 때문에 영상을 어떻게 편집하고, <code>WebCodecs</code> 를 어느 시점에 적용하여 인코딩과 디코딩을 해야할지, 서버에는 어떤 형태로 영상을 저장해야 하는지, 오디오는 어떻게 mux 해야할지 감이 전혀 잡히지 않았었다. 그래서 팀원들과 영상에 대한 도메인 지식(<code>인코딩</code>, <code>디코딩</code>, <code>코덱</code>, <code>컨테이너 포맷</code> 등..)을 학습하고 나서야 워크플로우를 어떻게 잡을지 감이 조금 왔다. 하지만, <code>WebCodecs</code> 를 알아갈수록 구현되지 않은 API가 많았고, 여러가지 이유로 <code>mp4</code> 파일로 추출하기 위해서는 <code>WebCodecs</code> 사용을 포기해야 했다. (<code>WebCodecs</code> 을 쓰기 위해 <code>https</code> 배포도 했는데 ㅠㅠ)</p><p>영상이 어디까지 진행되고 있는지를 표시할 슬라이더 구현을 위해 <code>css animation</code> 을 공부해서 적용해봤는데, 갑자기 <code>css animation</code>에 재미가 붙어 여기저기에 짜잘하게 적용시켜보기도 했다. 또 프로젝트 특성상 영상을 로딩하고 다운로드 하는 등의 작업이 많아 로딩화면이 필요했는데, 팀원들끼리 LCC(Loading Component Contest)를 개최하여 캠퍼분들께 투표를 받아 1등한 로딩화면을 적용하기도 했다.</p><p><img src="https://user-images.githubusercontent.com/49153756/101557752-f8972c80-3a00-11eb-8a2f-91dc18c6bb9c.gif" alt></p><p><img src="https://user-images.githubusercontent.com/49153756/101557739-f208b500-3a00-11eb-896a-a0f5d707b02f.gif" alt></p><p>위의 두 개는 내가 만든 로딩 화면이다. 아쉽게 둘다 선정되지 못했…</p><p>또 많은 문제와 삽질이 있었지만 우여곡절 끝에 목표했던 기능을 거의 모두 완성했고, 좋은 평가를 받을 수 있었다. 정말 혼자였다면 완성할 수 없었을 프로젝트였고, 팀원들이 모두 열정적으로 프로젝트에 임해줘서 정말 고마웠다. 5주라는 한정된 시간 안에 요구사항을 모두 구현해야 했기에 테스트 코드는 작성하지 못해서 아쉬웠지만, 5주만에 이정도의 기능을 구현했다는 것만으로 대단한 것이라고 생각한다!</p><blockquote><p><a href="https://www.youtube.com/watch?v=7TCaBNmKwSU" target="_blank" rel="external nofollow noopener noreferrer">데모 영상 🎥</a></p></blockquote><p>데모 시간이나 네트워킹 데이에 다른 팀들이 한 프로젝트도 많이 둘러보았는데, 정말 다들 어려운 프로젝트를 진행했고 얼마나 많은 고민과 시간이 들어갔는지 느껴졌다..</p><h3 id="백엔드에서-프론트엔드로-🌉"><a href="#백엔드에서-프론트엔드로-🌉" class="headerlink" title="백엔드에서 프론트엔드로.. 🌉"></a>백엔드에서 프론트엔드로.. 🌉</h3><p>처음에는 백엔드 개발자를 지망하고 있던 터라, 학습 스프린트 첫 프로젝트는 백엔드를 위주로 진행했었다. 두 번째, 세 번째 프로젝트를 진행하며 SPA를 처음 구현해보았다. 나는 기존에 백엔드 위주로 프로젝트를 진행해봤다보니, 템플릿 엔진을 사용한 MPA의 잦은 페이지 전환에 익숙해져 있었다. SPA는 필요한 부분만 렌더링 하여 페이지 전환 없이 원하는 동작을 할 수 있어 UX적으로 크게 매력적으로 다가왔고, 페이지의 각 컴포넌트들을 모듈 단위로 개발하여 조립해가는 것이 재미있었다. 점점 프론트엔드에 흥미가 생기기 시작했고 결국 프론트엔드 개발자를 목표로 하게 되었다. 5주 프로젝트의 주제를 선정할 때까지 많은 고민을 했는데, 3주 프로젝트에서 리액트를 처음 상용해보며 점점 마음이 굳혀졌던 것 같다. 프론트엔드가 변화가 빠르다. 그에 맞춰 공부하고 개발하는 것이 즐겁고, 새로운 기술을 빠르게 선점할 수도 있다는 점이 매력적이었다.</p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>부스트캠프에서의 마지막 설문에 답하며 부스트캠프를 시작하기 전의 나의 모습을 떠올려보았다. 나는 백엔드 개발자를 지망하고 있었고, 때문에 졸업 작품 주제를 spring을 사용하여 웹 개발을 진행중이었다. 부스트캠프는 자바스크립트 풀스택 과정이었기에 약간의 고민은 됐었지만 언어가 중요한 것이 아니고 웹에 대한 전반적인 이해를 갖추면 어떤 언어를 하더라도 잘 할 수 있을거라고 생각했기에 웹에 대한 전반적인 이해를 갖춘 백엔드 개발자가 되는 것을 목표로 지원했다.</p><p>처음 지원할 때에는 자바스크립트를 제대로 사용할 줄도 모르고 기본 문법만 조금 알던 상태였지만, 이제는 가장 편한 언어이고 제일 자신있는 언어가 되었다. 백엔드밖에 몰랐던(<del>사실 백엔드도 잘 몰랐던</del>) 나는 이제 프론트엔드 개발자가 되기 위해 공부하고 있게 되었고, 깃헙을 제대로 사용하여 팀원들과 협업을 진행하는 방법, 협업의 가치를 배웠다. 가장 중요한 것은 내가 앞으로 나아가야 할 방향과 목표가 뚜렸해졌고, 무엇을 알고 무엇을 모르는지 알게되었다. 하고싶은 것도 정말 많아졌다.</p><p>올해는 여러모로 나한테 뜻깊은 해였다. 4학년 1학기 모든 과목을 A+받아 처음으로 1등을 해봤고, 전액 장학금을 받고 그대로 맥북을 구매했다. 또 챌린지 시작 직전에 정보처리기사 실기시험을 보느라 미리 js공부도 못하고 들어가게 되었지만, 결과적으로 멤버십도 합격하고 기사도 합격해서 뿌듯했다.</p><p>그렇지만 올해 가장 잘한 일은 역시 부스트캠프에 지원한 것이다. 내 인생에서 가장 많이 성장한 5개월이었다. 정말 실력있는 캠퍼분들을 많이 만나고 함께 할 수 있어서 영광이었고, 부스트캠프를 수료한 모두 잘될거라 믿고 뜻하시는 바를 이루기 바란다. 멤버십에도 챌린지 때와 마찬가지로 서로 롤링페이퍼를 써줬는데, 모두 좋은 말씀해주셔서 감사합니다~</p><p><img src="https://user-images.githubusercontent.com/49153756/103464213-4b9c9f00-4d75-11eb-86de-406908489a83.png" alt="rolling_paper"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;5개월간의 부스트캠프에서의 여정이 모두 끝났다. 부스트캠프 멤버쉽 과정에서는 챌린지에서 배우고 익힌 자바스크립트를 기반으로 다양한 프로젝트를 진행했다. 멤버쉽 4개월의 여정은 6주간의 학습 스프린트 기간과 8주간의 그룹 프로젝트 기간으로 나뉜다.
      
    
    </summary>
    
    
      <category term="BoostCamp" scheme="https://kyu9341.github.io/categories/BoostCamp/"/>
    
    
      <category term="boostcamp" scheme="https://kyu9341.github.io/tags/boostcamp/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트(JavaScript) - this</title>
    <link href="https://kyu9341.github.io/JavaScript/2020/12/24/JavaScript_this/"/>
    <id>https://kyu9341.github.io/JavaScript/2020/12/24/JavaScript_this/</id>
    <published>2020-12-23T15:12:28.000Z</published>
    <updated>2021-01-17T18:19:42.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>오늘은 자바스크립트에서 자주 헷갈리는 <code>this</code> 에 대해 알아보겠다.</p><h2 id="this란"><a href="#this란" class="headerlink" title="this란?"></a>this란?</h2><p>자바스크립트에서는 함수 선언 시에 <code>this</code> 에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수 호출 시 어떻게 호출되었는지에 따라 <code>this</code> 에 바인딩할 객체가 동적으로 결정된다. 즉, 함수 호출 전까지는 <code>this</code> 에 값이 할당되어있지 않는다.<br>그럼 이제 각각의 상황에서 <code>this</code> 에 어떤 값이 할당되는지 알아보자!</p><h3 id="전역공간에서-this"><a href="#전역공간에서-this" class="headerlink" title="전역공간에서 this"></a>전역공간에서 <code>this</code></h3><ul><li>브라우저에서 <code>this</code> : <code>window</code></li><li>Node.js 에서 <code>this</code> : <code>global</code></li></ul><h3 id="함수-내부에서-this"><a href="#함수-내부에서-this" class="headerlink" title="함수 내부에서 this"></a>함수 내부에서 <code>this</code></h3><ul><li>기본적으로 전역 객체를 가리킨다.</li><li>defalut 값이 전역 객체, 바뀔 수 있음 (call, bind, apply)</li></ul><p><strong>내부함수에서의 우회법</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">20</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.b();</span><br></pre></td></tr></table></figure><p>아래와 같이 스코프체인을 이용하여 <code>obj</code>의 <code>this</code>에 접근이 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">20</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.a); <span class="comment">// 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    c();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.b();</span><br></pre></td></tr></table></figure><h3 id="화살표-함수에서-this"><a href="#화살표-함수에서-this" class="headerlink" title="화살표 함수에서 this"></a>화살표 함수에서 <code>this</code></h3><ul><li><p>화살표 함수에는 <code>this</code> 가 없다.</p></li><li><p>화살표 함수 내부에서 <code>this</code> 에 접근하면 외부에서 값을 가져온다.</p><p>→ 일반 변수 서칭과 마찬가지로 <code>this</code> 값을 외부 렉시컬 스코프에서 찾는다.</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  func() &#123;</span><br><span class="line">    <span class="keyword">const</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    arrow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.func(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>위의 예시를 보면, <code>arrow</code> 가 화살표 함수이기 때문에 <code>this.a</code> 는 화살표 함수 바깥의 메서드인 <code>func</code> 가 가리키는 대상과 같아진다. 즉, <code>arrow</code> 내부에서 <code>obj.a === this.a</code></p><h3 id="메소드-호출-시-this"><a href="#메소드-호출-시-this" class="headerlink" title="메소드 호출 시 this"></a>메소드 호출 시 <code>this</code></h3><ul><li>메소드 호출 주체 (메소드명 앞)<ul><li>ex) <code>a.b()</code> → <code>this === a</code></li><li>ex) <code>a.b.c()</code> → <code>this === a.b</code></li></ul></li></ul><h3 id="callback에서-this"><a href="#callback에서-this" class="headerlink" title="callback에서 this"></a>callback에서 <code>this</code></h3><ul><li>기본적으로는 함수 내부에서와 동일</li><li>제어권을 가진 함수가 callback의 this를 명시한 경우 그에 따른다.</li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external nofollow noopener noreferrer"><code>call()</code></a> , <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external nofollow noopener noreferrer"><code>apply()</code></a>, <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer"><code>bind()</code></a> 사용하여 this를 설정할 수 있음<ul><li><code>func.call(thisArg[, arg1[, arg2[, ...]]])</code></li><li><code>func.apply(thisArg, [argsArray])</code></li><li><code>func.bind(thisArg[, arg1[, arg2[, ...]]])</code></li></ul></li></ul><p><code>thisArg</code> : <code>func</code> 를 실행할 때 인식하게 할 <code>this</code> 를 설정한다.<br><code>call()</code> 과 <code>apply()</code> 는 <code>thisArg</code> 자리에 <code>this</code> 로 인식할 객체를 넣고, 즉시 함수를 호출하는 점은 동일하다. 다른 점은 매개변수로 넘겨줄 인자들을 <code>,</code> 로 나열하느냐, 아니면 배열(<code>[]</code>) 에 담아서 한번에 넘겨주느냐의 차이이다.<br><code>bind()</code> 는 <code>call()</code> 과 같은 방식으로 사용하지만 즉시 <code>func</code> 를 호출하는 것이 아니라 <code>this</code> 를 바인딩하여 새로운 함수를 생성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  b: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.call(obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">func.apply(obj, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">func.bind(obj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)();</span><br><span class="line"><span class="comment">// 1 2 3 --&gt; 모두 같은 결과</span></span><br></pre></td></tr></table></figure><h3 id="생성자-함수에서-this"><a href="#생성자-함수에서-this" class="headerlink" title="생성자 함수에서 this"></a>생성자 함수에서 <code>this</code></h3><ul><li>인스턴스를 가리킨다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kwon = <span class="keyword">new</span> Person(<span class="string">'Kwon'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">console</span>.log(kwon); <span class="comment">// Person &#123;name: "Kwon", age: 25&#125;</span></span><br></pre></td></tr></table></figure><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li>내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다.</li><li><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external nofollow noopener noreferrer"><code>call()</code></a> , <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external nofollow noopener noreferrer"><code>apply()</code></a>, <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external nofollow noopener noreferrer"><code>bind()</code></a> 를 사용하여 this를 설정할 수 있다.</li><li>화살표 함수는 자신만의 <code>this</code>를 가지지 않는다. 화살표 함수 안에서 <code>this</code>를 사용하면, 외부에서 <code>this</code> 값을 가져온다.</li></ul><blockquote><p>참조</p><p><a href="https://ko.javascript.info/arrow-functions" target="_blank" rel="external nofollow noopener noreferrer">https://ko.javascript.info/arrow-functions</a></p><p><a href="https://ko.javascript.info/object-methods" target="_blank" rel="external nofollow noopener noreferrer">https://ko.javascript.info/object-methods</a></p><p><a href="https://poiemaweb.com/js-this" target="_blank" rel="external nofollow noopener noreferrer">https://poiemaweb.com/js-this</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;p&gt;오늘은 자바스크립트에서 자주 헷갈리는 &lt;code&gt;this&lt;/code&gt; 에 대해 알아보겠다.&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>WEB - SOP와 CORS</title>
    <link href="https://kyu9341.github.io/WEB/2020/10/24/WEB_CORS/"/>
    <id>https://kyu9341.github.io/WEB/2020/10/24/WEB_CORS/</id>
    <published>2020-10-24T12:12:28.000Z</published>
    <updated>2021-02-16T13:59:02.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>(<code>Cross-Origin Resource Sharing</code> - 교차 출처 리소스 공유)</p><p>요즘에는 웹 프론트 엔드(클라이언트)와 api 서버를 따로 구성하는 경우가 많은데, 이러한 경우에 프론트 엔드에서 다른 <code>Origin</code> 의 api 서버로 요청을 보내면 문제가 발생하게 된다. 이 문제를 <code>CORS</code> 문제라고 부른다.</p><p>여기서 말하는 <code>Origin</code> 이란, 아래의 세 가지 요소를 조합한 것을 말한다.</p><ul><li>URL 스키마 (<code>http</code>, <code>https</code>)</li><li>hostname (<code>localhost</code>, <a href="http://naver.com" target="_blank" rel="external nofollow noopener noreferrer"><code>naver.com</code></a> 등..)</li><li>포트 (<code>80</code> , <code>3000</code> , <code>8080</code> 등..)</li></ul><h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><p>예전에는 브라우저에서 요청을 보내면, 서버는 해당하는 로직을 수행한 뒤 HTML 페이지를 렌더링 한 뒤 브라우저에 반환해주는 방식이 일반적이었다. 즉, 하나의 서버(동일한 <code>Origin</code>)에서 모든 작업이 수행되었다.</p><p>그렇기 때문에 웹 사이트에서 다른 서버로 요청을 보낸다는 것을 무언가 보안상 악의적인 행동을 하려는 것으로 생각했다. 그래서 브라우저에서는 같은 <code>Origin</code>이 아니라면 요청을 막아버리는 선택을 했던 것이고, 이것이 <code>SOP</code> 정책이다. 하지만 점점 웹 사이트에서 하는 일이 많아지면서 이러한 정책이 불편해지기 시작했고, 그에 따라 이러한 <code>SOP</code> 를 우회하기 위한 방법들이 나오기 시작했다.</p><p>그 방법들 중 하나가 <code>JSONP</code> 라는 방법인데, HTML의 script 태그의 경우에는 다른 <code>Origin</code> 의 파일을 불러오는 것이 가능했고 이 것을 리소스 요청을 주고받는데 우회적으로 사용한 것이었다. 스크립트를 불러오는 것처럼 사용을 하지만 실제로는 서버에서 데이터를 반환하는 용도로 사용을 했다.</p><p>이러한 방식의 우회로를 계속 두고 볼 수 없지만, 너무 수요가 많았기 때문에 공식적으로 특정한 제약조건 속에서 <code>cross-origin</code> 요청을 허용하도록 나온 정책이 <code>CORS</code> 이다.</p><p>이제 <code>SOP</code> 와 <code>CORS</code> 에 대해 하나씩 살펴보자.</p><h2 id="SOP-Same-Origin-Policy"><a href="#SOP-Same-Origin-Policy" class="headerlink" title="SOP (Same Origin Policy)"></a>SOP (Same Origin Policy)</h2><p><strong>SOP</strong>는 동일 출처 정책으로 하나의 <code>Origin</code> 에서 로드된 문서나 스크립트가 다른 <code>Origin</code> 의 자원과 상호작용하지 못하도록 제한하는 것을 말한다. 이 정책에 의해 <code>XMLHttpRequest</code> 객체를 사용하는 등 <code>AJAX</code> 통신으로 어떠한 자원에 접근할 때 동일한 <code>Origin</code> 인 경우에만 접근이 가능하다.</p><p><img src="https://user-images.githubusercontent.com/49153756/97000786-3552b580-1572-11eb-8bcd-f63b2b1a176a.png" alt="sop"></p><p>예를 들어, 나의 api 서버가 <code>http://localhost:3000</code> 에서 제공이 되고, 그 api를 <code>http://localhost:8080</code> 에서 호출할 수 없는 것이다. 호출을 한다면 다음과 같은 에러 메세지를 볼 수 있다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load '[<span class="string">http://localhost:3000</span>](<span class="link">http://localhost:3000/</span>)'.</span><br><span class="line">No 'Access-Control-Allow-Origin' header is present on the requested resource.</span><br><span class="line">Origin '[<span class="string">http://localhost:8080</span>](<span class="link">http://localhost:8080/</span>)' is therefore not allowed access.</span><br></pre></td></tr></table></figure><p>자, <code>SOP</code> 에 대해 알아봤으니 본론인 <code>CORS</code> 에 대해 알아보겠다.</p><h2 id="CORS-Cross-Origin-Resource-Sharing"><a href="#CORS-Cross-Origin-Resource-Sharing" class="headerlink" title="CORS (Cross-Origin Resource Sharing)"></a>CORS (Cross-Origin Resource Sharing)</h2><p>위에서 언급했던 <code>SOP</code> 에 대한 서버단의 해결책이 바로 <code>CORS</code> 이다. 이 정책의 특징은 서버에서 외부 요청을 허용할 경우 <code>AJAX</code> 요청이 가능해진다는 것이다. <code>MDN</code> 에서는 다음과 같이 정의한다.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**교차 출처 리소스 공유(Cross-Origin<span class="built_in"> Resource </span>Sharing, CORS)는 추가 HTTP 헤더를 사용하여,</span><br><span class="line">한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록</span><br><span class="line">브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때</span><br><span class="line">교차 출처 HTTP 요청을 실행합니다.**</span><br></pre></td></tr></table></figure><p>한마디로 하자면, <code>Cross-Origin</code>에서 <code>Http Request</code>를 가능하게 해주는 표준 규약이다.</p><p>그렇다면 이제 <code>CORS</code> 상황에서 어떻게 동작할까?</p><h2 id="CORS-동작방식"><a href="#CORS-동작방식" class="headerlink" title="CORS 동작방식"></a>CORS 동작방식</h2><p>기본적으로 브라우저에서 다른 출처의 자원을 요청할 때 <code>HTTP</code> 프로토콜을 사용하여 요청을 보내는데, 이 때 브라우저는 요청 헤더에 <code>Origin</code> 이라는 필드에 현재 요청을 보내는 출처를 담아 보낸다.</p><p>ex) <code>Origin: http://localhost:8080</code></p><p>이 후 서버에서 요청을 받고 응답을 할 때 응답 헤더의 <code>Access-Control-Allow-Origin</code> 라는 필드에 요청한 자원에 접근하는 것이 허용된 출처를 담아 응답한다. 그러면 브라우저에서 응답을 받고, 요청 시에 보냈던 <code>Origin</code> 과 응답 받은 <code>Access-Control-Allow-Origin</code> 을 비교하여 응답의 유효성을 판단한다.</p><p><code>MDN</code> 에서는 <code>CORS</code> 동작 방식에 대해 세 가지 시나리오를 설명한다.</p><ul><li><code>Simple Request</code> (단순 요청)</li><li><code>Preflight Request</code> (사전 요청)</li><li><code>Credentialed Request</code> (인증 정보를 포함한 요청)</li></ul><p>각각의 시나리오를 알아보기 전에 이해를 돕기 위해 브라우저에서의 요청과 서버에서의 응답에 대한 헤더의 종류를 알아보고 가자.</p><h3 id="클라이언트-요청-헤더-종류"><a href="#클라이언트-요청-헤더-종류" class="headerlink" title="클라이언트 요청 헤더 종류"></a>클라이언트 요청 헤더 종류</h3><ul><li><code>Origin</code> : 요청을 보내는 페이지의 출처(도메인)</li><li><code>Access-Control-Request-Method</code> : 실제 요청하려는 메소드를 알려주기 위해 <code>preflight request</code> 시 사용된다.</li><li><code>Access-Control-Request-Headers</code> : 마찬가지로 실제 요청에 포함될 있는 헤더를 알려주기 위해 사용된다.</li></ul><h3 id="서버-응답-헤더-종류"><a href="#서버-응답-헤더-종류" class="headerlink" title="서버 응답 헤더 종류"></a>서버 응답 헤더 종류</h3><ul><li><code>Access-Control-Allow-Origin</code> : 허용할 출처 → 모든 <code>Origin</code> 에 대해 허용하려면 와일드카드 (<code>*</code>) 를 사용한다.</li><li><code>Access-Control-Expose-Headers</code> : 브라우저가 접근할 수 있는 헤더를 정의</li><li><code>Access-Control-Max-Age</code> : 브라우저에서 <code>preflight request</code> 요청 결과를 캐시할 수 있는 시간(초) 이렇게 퍼미션 정보를 캐싱해두면 브라우저는 일정 기간 동안 <code>preflight request</code> 없이 본 요청을 보낼 수 있다.</li><li><code>Access-Control-Allow-Credentials</code> : 클라이언트 요청이 쿠키를 통해서 자격 증명을 해야 하는 경우에 true. true를 응답 받은 클라이언트는 실제 요청 시 서버에서 정의된 규격의 인증 값이 담긴 쿠키를 같이 보내야 한다.</li><li><code>Access-Control-Allow-Methods</code> : 요청을 허용하는 메소드. 기본값은 <code>GET</code>, <code>POST</code>이며 <code>preflight request</code> 에 대한 응답으로 사용되고, 클라이언트에서의 요청이 이 헤더에 포함되는 메서드인 경우 실제 요청을 보낸다.</li><li><code>Access-Control-Allow-Headers</code> : 실제 요청 시 사용할 수 있는 헤더</li></ul><h3 id="Simple-Request"><a href="#Simple-Request" class="headerlink" title="Simple Request"></a>Simple Request</h3><p><code>Simple Request</code> 는 아래의 세 가지 조건을 모두 만족할 때 가능한 요청이다.</p><ol><li>요청 메서드가 <code>GET</code> <code>POST</code> <code>HEAD</code> 중 하나인 경우</li><li><code>POST</code> 메서드라면, <code>Content-Type</code> 이 아래 중 하나여야 한다.<ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li><li><code>CORS-safelisted request-header</code>로 정의된 헤더 외에 커스텀 헤더를 사용하면 안된다.</li></ol><p>하지만 위의 조건을 모두 만족하는 경우는 사실 드물다. 일반적으로 <code>HTTP API</code> 는 <code>Content-Type</code> 으로 <code>application/json</code> 타입을 가지도록 설계를 하고, JWT와 같은 토큰 방식의 인증에서는 <code>Authorization</code> 헤더를 사용하여 사용자 인증이 진행되는데, 위에서 말한 조건의 헤더에 포함되지 않기 때문이다.</p><p><img src="https://user-images.githubusercontent.com/49153756/97000918-734fd980-1572-11eb-9906-24fbd3f606bc.png" alt="simple"><br><code>Simple Request</code> 는 바로 본 요청을 서버에 보낸 후, 서버의 응답 헤더에 <code>Access-Control-Allow-Origin</code> 과 같은 값을 보내주면 그 때 브라우저가 <code>CORS</code> 정책의 위반 여부를 검사하는 방식이다. 만약 검사를 했을 때 정책을 위반하는 경우라면 서버로부터 받은 응답을 브라우저가 사용하지 않고 버리게 된다.</p><h3 id="Preflight-Request"><a href="#Preflight-Request" class="headerlink" title="Preflight Request"></a>Preflight Request</h3><p>이제 일반적으로 <code>CORS</code> 상황에서 가장 많이 마주하게 되는 시나리오를 보자. 위에서 언급한 <code>Simple Request</code> 의 조건에 만족하지 않는 경우에는 <code>Preflight Request</code> 방식으로 진행이 되는데, 이 방식은 <code>Simple Request</code> 처럼 바로 본 요청을 보내지 않고 먼저 <code>Preflight Request</code> 라고 하는 예비 요청을 먼저 보내게 된다.</p><p>아래는 최근에 가계부 미션 때 만들었던 프로젝트의 <code>Preflight Request</code> 를 흐름도로 간단하게 그려보았다.</p><p><img src="https://user-images.githubusercontent.com/49153756/97000912-71861600-1572-11eb-950b-ab23f8cc5ad4.png" alt="preflight"></p><p>자바스크립트에서 <code>fetch API</code> 를 사용하면 먼저 <code>Preflight Request</code> 을 보내는데, <code>OPTIONS</code> 라는 HTTP 메서드를 사용한다. 이 때, 헤더에 본 요청에서 어떤 메서드를 사용하고, 어떤 헤더를 사용할 것인지에 대한 정보를 담아 예비 요청을 보내면 서버는 어떤 메서드를 허용하고, 어떤 헤더를 허용하는지 정보를 담아 응답한다.</p><p>브라우저는 사용할 메서드와 헤더가 허용되는지 응답 받은 정보와 비교하여 본 요청을 보낼지 판단하고, 문제가 없다면 본 요청을 보내게 된다. 이 후 본 요청이 수행되는 과정은 위의 <code>Simple Request</code> 와 동일하게 진행된다.</p><h3 id="Credentialed-Request"><a href="#Credentialed-Request" class="headerlink" title="Credentialed Request"></a>Credentialed Request</h3><p>마지막 시나리오는 <code>Cookie</code> 나 인증 관련한 정보가 포함된 요청을 사용하는 방법이다. 자바스크립트를 이용해 보내는 <code>cross-origin</code> 요청의 경우 기본적으로 쿠키나 인증 정보와 같은 <strong>자격 증명</strong>이 함께 전송되지 않는다.</p><p>이 때, 인증과 관련된 정보를 담고 싶다면 <code>XMLHttpRequest</code> 를 사용하는 경우에는 <code>withCredentials</code> 속성을 <code>true</code> 로 설정해주면 되고, <code>fetch API</code> 를 사용하는 경우는 <code>Request()</code> 의 <code>credentials</code> 옵션을 설정해주면 된다.</p><ul><li><code>credentials</code> 에는 다음과 같은 옵션을 설정할 수 있다.<ul><li><code>omit</code> : 절대로 cookie 들을 전송하거나 받지 않는다.</li><li><code>same-origin</code> : URL이 호출 script 와 동일 출처(same origin)에 있다면, user credentials (cookies, basic http auth 등..)을 전송한다. (기본값)</li><li><code>include</code> : cross-origin 호출이라 할지라도 언제나 user credentials (cookies, basic http auth 등..)을 전송한다.</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url, &#123;</span><br><span class="line">  method,</span><br><span class="line">  mode: <span class="string">'cors'</span>,</span><br><span class="line">  credentials: <span class="string">'include'</span>,</span><br><span class="line">  headers,</span><br><span class="line">  body,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위와 같이 <code>fetch API</code> 의 옵션에 <code>include</code> 를 설정해주면 해당 <code>url</code> 에 해당하는 쿠키를 함께 보낼 수 있게 된다. 이 경우에 정상적으로 응답을 받기 위해서는 서버 측에서 응답 헤더로 <code>Access-Control-Allow-Credentials</code> 에 <code>true</code> 값을 넣어주어야 한다. 그렇지 않으면 브라우저는 응답을 거부해 버린다.</p><p><img src="https://user-images.githubusercontent.com/49153756/97022531-30e8c580-158f-11eb-8e36-5c72558845e6.png" alt="credentialed"></p><p>또한, <code>include</code> 옵션인 경우 어떤 <code>Origin</code> 에서 어떤 요청이 왔는지에 대한 정보를 서버가 신뢰하기 위해서 <code>Access-Control-Allow-Origin</code> 에 와일드 카드인 <code>*</code> 를 사용할 수 없고, 명시적으로 허용할 <code>Origin</code> 의 정보를 넣어주어야 한다.</p><p><code>Express</code> 의 경우 서버 측에서 다음과 같이 설정할 수 있다. (<code>cors</code> 미들웨어를 사용)</p><ul><li><a href="https://github.com/expressjs/cors" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/expressjs/cors</a></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(</span><br><span class="line">  cors(&#123;</span><br><span class="line">    origin: <span class="literal">true</span>,</span><br><span class="line">    credentials: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><ul><li><code>CORS</code> 는 같은 <code>Origin</code> 에서만 자원 공유가 가능하다는 <code>SOP</code> 의 불편함에서 나온 정책이다.</li><li><code>CORS</code> 의 동작 방식에는 <code>simple request</code> , <code>preflight request</code> , <code>credentialed request</code> 가 있다.<ul><li><code>simple request</code> 는 특정한 조건이 갖춰진 경우에만 가능한 요청이다.</li><li><code>preflight request</code> 는 본 요청을 보내기 전에 사전 요청을 보내어 이 요청을 보내는 것이 안전한지 확인하는 과정이 추가된다.</li><li><code>credentialed request</code> 는 쿠키나 인증 관련 정보가 포함된 요청으로 프론트와 서버에서 각각 추가적인 설정을 해주어야 한다.</li></ul></li></ul><blockquote><p>참조<br><a href="https://ko.javascript.info/fetch-crossorigin" target="_blank" rel="external nofollow noopener noreferrer">https://ko.javascript.info/fetch-crossorigin</a> &gt; <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/CORS" target="_blank" rel="external nofollow noopener noreferrer">https://developer.mozilla.org/ko/docs/Web/HTTP/CORS</a> &gt; <a href="https://evan-moon.github.io/2020/05/21/about-cors/" target="_blank" rel="external nofollow noopener noreferrer">https://evan-moon.github.io/2020/05/21/about-cors/</a> &gt; <a href="https://sjh836.tistory.com/93" target="_blank" rel="external nofollow noopener noreferrer">https://sjh836.tistory.com/93</a> &gt; <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials" target="_blank" rel="external nofollow noopener noreferrer">https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials</a> &gt; <a href="https://developer.mozilla.org/ko/docs/Web/API/Request/Request" target="_blank" rel="external nofollow noopener noreferrer">https://developer.mozilla.org/ko/docs/Web/API/Request/Request</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h1&gt;&lt;p&gt;(&lt;code&gt;Cross-Origin Resource Sharing&lt;/code&gt; - 교차 출처 리소스 공유)&lt;/p
      
    
    </summary>
    
    
      <category term="WEB" scheme="https://kyu9341.github.io/categories/WEB/"/>
    
    
      <category term="WEB" scheme="https://kyu9341.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>OS - 프로세스 Context Switching</title>
    <link href="https://kyu9341.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2020/10/04/OS_Process_Context_Switching/"/>
    <id>https://kyu9341.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2020/10/04/OS_Process_Context_Switching/</id>
    <published>2020-10-04T13:12:28.000Z</published>
    <updated>2020-10-04T13:46:38.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h2><p>멀티 프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업을 <code>Context Switching</code>이라 한다.</p><h3 id="Intterupt-인터럽트"><a href="#Intterupt-인터럽트" class="headerlink" title="Intterupt(인터럽트)"></a>Intterupt(인터럽트)</h3><p>인터럽트는 CPU가 프로그램을 실행하고 있을 때, 실행 중인 프로그램 외부에서 예외 상황이 발생하여 처리가 필요한 경우 CPU에게 알려 예외 상황을 처리할 수 있도록 하는 것이다.</p><ul><li><strong><code>Context Switching</code> 을 위한 인터럽트 종류</strong><ul><li><code>I/O request</code> : 입출력 요청</li><li><code>time slice expired</code> : CPU 사용시간이 만료</li><li><code>fork a child</code> : 자식 프로세스 생성</li><li><code>wait for an interrupt</code> : 인터럽트 처리 대기</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/49153756/95016480-389f0380-068e-11eb-93c0-0da3b80b5f57.png" alt="image"></p><p>위 이미지는 공룡책에서 나오는 <code>Context Switching</code> 에 대한 이미지이다. <code>P0</code> 가 실행 중인데,<code>intterupt</code> 가 발생했다. 그럼 현재 실행 중이었던 <code>P0</code> 의 정보들(<code>PC(Program Counter)</code>, <code>SP(Stack Pointer)</code> 등의 레지스스터 정보)을 해당 프로세스의 <code>PCB</code> (여기서는 <code>PCB0</code>)에 저장한다.  그리고 <code>P1</code> 을 실행시키기 위해 <code>PCB1</code> 에 저장되어 있던 <code>P1</code> 의 정보를 가져와 프로세스를 실행시킨다.</p><p>이 때, <code>Context Switching</code> 이 진행되는 동안 CPU는 아무 일도 하지 못하기 때문에 <code>Context Switching</code> 이 잦아지면 <code>overhead</code>가 많이 발생하게 되어 효율이 떨어질 수 있다.</p><p>[ <code>Context Switching</code> 에서 <code>overhead</code> :  <code>Context Switching</code> 에 걸린 시간과 메모리 ]</p><p><strong>그렇다면 이렇게 <code>overhead</code> 가 발생하게 되는데도 <code>Context Switching</code> 을 하는 이유는 뭘까?</strong><br>→ 프로세스 수행 중 <code>I/O 이벤트</code> 가 발생해 <code>waiting</code> 상태로 전환시키는 경우, CPU가 아무런 일을 하지 않아 발생하는 낭비보다 <code>overhead</code> 가 발생하더라도 <code>Context Switching</code> 을 통해 다른 프로세스를 실행시키는 것이 더 효율적이기 때문이다.</p><h3 id="PCB-프로세스-제어-블록"><a href="#PCB-프로세스-제어-블록" class="headerlink" title="PCB(프로세스 제어 블록)"></a>PCB(프로세스 제어 블록)</h3><ul><li>운영체제가 프로세스를 제어하기 위해 정보를 저장하는 자료구조이다.</li><li>프로세스 상태 관리와 <code>Context Switching</code>을 위해 필요하다.</li><li>모든 프로세스는 고유의 PCB를 가지며, 프로세스 생성 시 PCB가 생성되고 주기억장치에 유지되다가 프로세스가 완료되면 PCB는 제거된다.</li></ul><h4 id="PCB에서-유지되는-정보"><a href="#PCB에서-유지되는-정보" class="headerlink" title="PCB에서 유지되는 정보"></a>PCB에서 유지되는 정보</h4><ul><li>PID : 운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별번호</li><li>프로세스 상태 : 준비, 대기, 실행 등의 상태 정보</li><li>PC(프로그램 카운터) : CPU가 다음에 실행할 명령어를 가리키는 값</li><li>Priority (스케줄링 우선순위) : 운영체제가 여러 개의 프로세스가 CPU에서 실행되는 순서를 결정하는 것을 스케줄링이라 하는데, 이 스케줄링에서의 우선순위 정보</li><li>CPU 레지스터 및 일반 레지스터</li><li>메모리 관리 정보 : 해당 프로세스의 주소 공간 등의 정보</li><li>입출력 상태 정보 : 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록 등</li><li>계정 정보 : CPU 사용 시간, 실제 사용된 시간 등</li><li>포인터<ul><li>부모 프로세스와 자식 프로세스에 대한 포인터</li><li>프로세스가 위치한 메모리 주소에 대한 포인터</li><li>할당된 자원에 대한 포인터</li></ul></li></ul><hr><blockquote><p>참조<br>운영체제 10판<br>Context Switching<br><a href="https://jeong-pro.tistory.com/93" target="_blank" rel="external nofollow noopener noreferrer">https://jeong-pro.tistory.com/93</a><br><a href="https://velog.io/@jacob0122/Context-Switching" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@jacob0122/Context-Switching</a><br><a href="https://jhnyang.tistory.com/33" target="_blank" rel="external nofollow noopener noreferrer">https://jhnyang.tistory.com/33</a><br><a href="https://jins-dev.tistory.com/entry/컨텍스트-스위치Context-Switching-에-대한-정리" target="_blank" rel="external nofollow noopener noreferrer">https://jins-dev.tistory.com/entry/컨텍스트-스위치Context-Switching-에-대한-정리</a><br><a href="https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@adam2/%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Context-Switching&quot;&gt;&lt;a href=&quot;#Context-Switching&quot; class=&quot;headerlink&quot; title=&quot;Context Switching&quot;&gt;&lt;/a&gt;Context Switching&lt;/h2&gt;&lt;p&gt;멀티 프로세스 환경
      
    
    </summary>
    
    
      <category term="운영체제" scheme="https://kyu9341.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
    
      <category term="운영체제" scheme="https://kyu9341.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
  </entry>
  
  <entry>
    <title>OS - 프로세스 메모리 구조</title>
    <link href="https://kyu9341.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2020/10/04/OS_Process_Structure/"/>
    <id>https://kyu9341.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2020/10/04/OS_Process_Structure/</id>
    <published>2020-10-04T12:12:28.000Z</published>
    <updated>2020-10-23T16:16:16.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로세스란"><a href="#프로세스란" class="headerlink" title="프로세스란?"></a>프로세스란?</h2><p>프로세스란 운영체제 입장에서 하나의 작업 단위이며, 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다.</p><h3 id="프로그램과-프로세스"><a href="#프로그램과-프로세스" class="headerlink" title="프로그램과 프로세스"></a>프로그램과 프로세스</h3><p><img src="https://user-images.githubusercontent.com/49153756/97027422-a9528500-1595-11eb-8c57-c5445c9d315c.png" alt="image"></p><p>프로그램은 일반적으로 하드 디스크 등의 보조기억장치에 저장된 실행 코드를 뜻하고, 프로세스는 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다. 즉, 실행 중인 프로그램을 뜻한다. 예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행되는 것이다.</p><h3 id="시분할-방식"><a href="#시분할-방식" class="headerlink" title="시분할 방식"></a>시분할 방식</h3><p>하나의 cpu(프로세서)는 한 순간에 하나의 프로세스만 실행할 수 있다. 그럼에도 여러 프로세스를 동시에 실행시킬 수 있는 것은 cpu가 처리하는 시간을 잘게 쪼개 여러 프로세스에 배분하는 방식으로 동작하기 때문이다.</p><hr><h2 id="프로세스-메모리-구조"><a href="#프로세스-메모리-구조" class="headerlink" title="프로세스 메모리 구조"></a>프로세스 메모리 구조</h2><p>UNIX 시스템은 실행 중인 프로세스에게 4GB의 가상 메모리 공간을 할당하는데, 상위 1GB는 커널이, 하위 3GB는 사용자 프로그램이 차지한다.</p><p><img src="https://user-images.githubusercontent.com/49153756/95016525-769c2780-068e-11eb-9c04-22da6a232278.png" alt="image"></p><h3 id="stack-영역"><a href="#stack-영역" class="headerlink" title="stack 영역"></a>stack 영역</h3><p>프로그램이 자동으로 사용하는 메모리 영역으로 함수 호출과 관계되는 지역변수와 매개변수가 저장된다. 함수 호출 시 생성되며, 함수가 끝나면 반환된다. stack 사이즈는 각 프로세스마다 할당되지만 프로세스가 메모리에 로드될 때 stack 사이즈가 고정되어 있어 런타임 시 stack 사이즈를 바꿀 수 없다. 명령 실행 시 자동으로 증가 또는 감소하기 때문에 보통 메모리의 마지막 번지를 지정한다.</p><h3 id="heap-영역"><a href="#heap-영역" class="headerlink" title="heap 영역"></a>heap 영역</h3><p>필요에 의해 메모리를 동적으로 할당할 때 사용하는 메모리 영역으로 동적 메모리 영역이라고 부른다. C 에서 <code>malloc()</code> <code>calloc()</code> 등의 함수를 사용하여 메모리 크기를 할당할 수 있으며, 메모리 주소 값에 의해서만 참조되고 사용되는 영역이다.</p><ul><li>위의 stack과 heap영역은 사실 같은 공간을 공유한다. heap이 메모리의 낮은 주소부터 할당되면 stack은 높은 주소부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 <code>stack overflow</code>, <code>heap overflow</code> 라고 한다.</li></ul><h3 id="Data-영역-BSS-GVAR"><a href="#Data-영역-BSS-GVAR" class="headerlink" title="Data 영역 (BSS, GVAR)"></a>Data 영역 (BSS, GVAR)</h3><p>프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며, 전역변수, 정적변수, 배열, 구조체 등이 저장된다. Data 영역은 다시 <code>BSS</code> 영역과 <code>Data(GVAR)</code> 영역으로 나누어지는데, 초기화된 데이터는 Data 영역에 저장되고, 초기화되지 않은 데이터는 BSS 영역에 저장된다.</p><ul><li><code>BSS</code>영역, <code>Data</code>영역을 구분하는 이유?<ul><li>초기화 된 데이터는 초기 값을 저장해야 하므로 Data 영역에 저장되어 rom에 저장된다. 하지만 초기화 되지 않은 데이터 까지 rom에 저장되면 큰 size의 rom이 필요하므로 구분한다. ( 초기화 되지 않은 데이터는 ram에 저장)</li></ul></li></ul><h3 id="Text-Code-영역"><a href="#Text-Code-영역" class="headerlink" title="Text (Code) 영역"></a>Text (Code) 영역</h3><p>텍스트 영역은 실행 명령을 포함하는 <strong>코드들이 들어가는 부분</strong>이다.<br>프로그램을 시작 할 때 컴파일한 프로그램(기계어)이 저장되어 있고, <strong>읽기 전용 영역</strong>이기에 프로세스가 함부로 변경 할 수 없고 변경 시 오류를 발생시킨다.<br>코드 자체를 구성하는 메모리 영역으로 Hex 파일이나 Bin 파일 메모리이다. 프로그램 명령이 위치하는 곳으로 기계어로 제어되는 메모리 영역이다.</p><hr><blockquote><p>참조<br>운영체제 10판<br>process<br><a href="https://ko.wikipedia.org/wiki/프로세스" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/프로세스</a><br><a href="https://recorda.tistory.com/entry/20160503프로세스-메모리-구조" target="_blank" rel="external nofollow noopener noreferrer">https://recorda.tistory.com/entry/20160503프로세스-메모리-구조</a><br><a href="https://bnzn2426.tistory.com/56?category=778369" target="_blank" rel="external nofollow noopener noreferrer">https://bnzn2426.tistory.com/56?category=778369</a><br><a href="https://inuplace.tistory.com/290?category=884574" target="_blank" rel="external nofollow noopener noreferrer">https://inuplace.tistory.com/290?category=884574</a><br><a href="https://jwprogramming.tistory.com/16" target="_blank" rel="external nofollow noopener noreferrer">https://jwprogramming.tistory.com/16</a><br><a href="https://bowbowbow.tistory.com/16" target="_blank" rel="external nofollow noopener noreferrer">https://bowbowbow.tistory.com/16</a><br><a href="https://www.programmersought.com/article/98613694619/" target="_blank" rel="external nofollow noopener noreferrer">https://www.programmersought.com/article/98613694619/</a><br><a href="https://m.blog.naver.com/PostView.nhn?blogId=ryutuna&amp;logNo=100188393620&amp;proxyReferer=https:%2F%2Frecorda.tistory.com%2Fentry%2F20160503프로세스-메모리-구조" target="_blank" rel="external nofollow noopener noreferrer">https://m.blog.naver.com/PostView.nhn?blogId=ryutuna&amp;logNo=100188393620&amp;proxyReferer=https:%2F%2Frecorda.tistory.com%2Fentry%2F20160503프로세스-메모리-구조</a><br><a href="http://tcpschool.com/c/c_memory_structure" target="_blank" rel="external nofollow noopener noreferrer">http://tcpschool.com/c/c_memory_structure</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;프로세스란&quot;&gt;&lt;a href=&quot;#프로세스란&quot; class=&quot;headerlink&quot; title=&quot;프로세스란?&quot;&gt;&lt;/a&gt;프로세스란?&lt;/h2&gt;&lt;p&gt;프로세스란 운영체제 입장에서 하나의 작업 단위이며, 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그
      
    
    </summary>
    
    
      <category term="운영체제" scheme="https://kyu9341.github.io/categories/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
    
      <category term="운영체제" scheme="https://kyu9341.github.io/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/"/>
    
  </entry>
  
  <entry>
    <title>Express - 미들웨어</title>
    <link href="https://kyu9341.github.io/Express/2020/09/12/JavaScript_express_middleware/"/>
    <id>https://kyu9341.github.io/Express/2020/09/12/JavaScript_express_middleware/</id>
    <published>2020-09-12T12:12:28.000Z</published>
    <updated>2020-09-12T12:58:46.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MiddleWare"><a href="#MiddleWare" class="headerlink" title="MiddleWare"></a>MiddleWare</h1><p>미들웨어는 express의 핵심이다. 요청과 응답의 중간에 위치하여 미들웨어라고 하며, 라우터와 에러 핸들로 또한 미들웨어의 일종이므로 미들웨어가 express의 전부라고 봐도 무방하다.</p><p>미들웨어 함수는 req(요청) 객체, res(응답) 객체, 그리고 애플리케이션 요청-응답 사이클 도중 그 다음의 미들웨어 함수에 대한 액세스 권한을 갖는 함수이다.</p><p>다음 미들웨어 함수에 대한 액세스는 next 함수를 이용해서 다음 미들웨어로 현재 요청을 넘길 수 있다. next라는 말에서 알 수 있듯이 next를 통해 미들웨어는 순차적으로 처리한다.(순서가 중요!)</p><p>next 함수는 인자의 종류로 구분이 가능한데, 인자를 아무것도 넣지 않으면 단순하게 다음 미들웨어로 넘어간다. next 함수의 인자로 route를 넣어 <code>next(&#39;route&#39;)</code> 와 같이 사용하면, 라우터에 연결된 나머지 미들웨어들을 건너뛰고 주소와 일치하는 다음 라우터로 넘어가게 된다. 그 외에 다른 값을 인자로 넣으면 다른 미들웨어나 라우터를 모두 건너 뛰고 바로 에러 핸들러로 이동하며 넣어준 값은 에러에 대한 내용으로 간주된다.</p><p>미들웨어는 주로 app.use와 함께 사용되고, 미들웨어는 use 메서드로 app에 장착한다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'pug'</span>);</span><br><span class="line">app.set(<span class="string">'port'</span>, process.env.PORT || <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">app.use(logger(<span class="string">'dev'</span>));</span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(cookieParser(process.env.COOKIE_SECRET));</span><br></pre></td></tr></table></figure><p>반드시 미들웨어 안에서 <code>next()</code>를 호출해야 다음 미들웨어로 넘어간다.  <code>logger</code> 나 <code>express.json()</code> , <code>express.urlencode</code> , <code>cookieParser</code> , <code>express.static</code> 모두 내부적으로는 <code>next()</code> 를 호출하기 때문에 다음 미들웨어로 넘어갈 수 있는 것이다.</p><h2 id="미들웨어-종류"><a href="#미들웨어-종류" class="headerlink" title="미들웨어 종류"></a>미들웨어 종류</h2><h3 id="morgan"><a href="#morgan" class="headerlink" title="morgan"></a>morgan</h3><p>요청에 대한 정보를 콘솔에 기록해주는 미들웨어 <code>app.use(logger(&#39;dev&#39;))</code>  에서 함수의 인자로 <code>dev</code> <code>short</code> <code>common</code> <code>combined</code> 등을 줄 수 있다. 개발 시에는 <code>dev</code> 나 <code>short</code> 를 많이 사용하고, 배포 시에는 <code>common</code> 이나 <code>combined</code> 를 많이 사용한다.</p><h3 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h3><p>요청의 본문을 해석해주는 미들웨어이다. 보통 폼 데이터나 ajax 요청의 데이터를 처리한다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br></pre></td></tr></table></figure><p>express 4.16.0 버전부터는 <code>body-parser</code> 의 일부 기능이 express에 내장되어 따로 설치하지 않고 위와 같이 사용이 가능하다. <code>body-parser</code> 가 필요한 경우도 있는데, <code>json</code>, <code>url-encoded</code> 형식의 본문 외에도 <code>raw</code>, <code>text</code> 형식의 본문을 해석할 수 있기 때문이다.</p><p><code>json</code> 은 <code>json</code> 형식의 데이터 전달 방식이고, <code>URL-encoded</code> 는 주소 형식으로 데이터를 보내는 방식이다.</p><p>보통 폼 전송이  <code>URL-encoded</code> 방식을 주로 사용한다. <code>urlencode</code> 메소드를 보면 <code>{ extended: false }</code> 라는 옵션이 들어있는데, 이 옵션이 <code>false</code> 면 노드의 <code>querystring</code> 모듈을 사용하여 쿼리스트링을 해석하고, <code>true</code> 인 경우 <code>qs</code> 모듈을 사용하여 쿼리스트링을 해석한다. <code>qs</code> 모듈은 내장 모듈이 아니라 npm 패키지이며, <code>querystring</code> 모듈의 기능을 조금 더 확장한 모듈이다.</p><h3 id="cookie-parser"><a href="#cookie-parser" class="headerlink" title="cookie-parser"></a>cookie-parser</h3><p><code>cookie-parser</code> 는 요청에 동봉된 쿠키를 해석해준다. 쿠키는 <code>name=kwon;age=25</code> 와 같은 문자열 형식으로 오는데, 이것을 <code>{ name: &#39;kwon&#39;, age: &#39;25&#39; }</code> 와 같은 객체로 파싱해준다.</p><p><code>app.use(cookieParser(&#39;secret code&#39;))</code> 와 같이 첫 번째 인자로 문자열을 넣을 수 있는데, 암호화된 쿠키가 있는 경우, 인자로 넣은 문자열을 키로 삼아 복호화할 수 있다.</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 미들웨어는 정적인 파일들을 제공해주는 express의 내장 미들웨어이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br></pre></td></tr></table></figure><p>함수의 인자로 정적 파일들이 담긴 폴더를 지정한다. 위와 같은 경우 실세 서버의 폴더 경로에는 public이 들어있지만, 요청 주소에는 public 이 포함되지 않기 때문에 외부에 실제 경로가 유출되지 않아 보안상의 이점도 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/files'</span>, express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br></pre></td></tr></table></figure><p>위와 같이 사용하면 <code>/files</code> 라는 가상 경로를 통해 접근하게 할 수 있다.</p><p>static 미들웨어는 요청에 부합하는 정적 파일을 발견한 경우 응답으로 해당 파일을 전송하는데, 이러한 경우 다음에 나오는 라우터가 실행되지 않고, 파일을 찾지 못한 경우 다음 라우터로 요청을 넘긴다. 이렇게 자체적으로 정적 파일 라우터 기능을 수행하기 때문에 최대한 위쪽에 배치하는 것이 서버가 쓸데없는 미들웨어 작업을 하는 것을 막을 수 있다. 따라서, 보통 <code>morgan</code> 다음에 배치하는 것이 좋은데 <code>morgan</code> 보다 위로 올리면 정적 파일 요청이 기록되지 않기 때문이다. <code>json</code> <code>urlencoded</code> <code>cookie-parser</code> 는 정적 파일을 제공하는데 영향을 끼치지 않기 때문에 굳이 이런 미들웨어를 거칠 필요가 없다.</p><h3 id="path-모듈"><a href="#path-모듈" class="headerlink" title="path 모듈"></a>path 모듈</h3><p>위에서 사용된 <code>path</code> 는 경로에 관련된 모듈인데, 파일 경로를 작성할 때 문자열을 직접 자르고 합치는 것보다 path에서 제공하는 join함수를 사용하는 것이 편리하다. <code>__dirname</code> 은 node.js에서 제공하는 node파일의 경로를 담고 있는 글로벌 객체이다. <code>path.join()</code> 은 각 파라미터를 합쳐서 경로 문자열을 반환한다. 즉, 위와 같은 <code>path.join(__dirname, &#39;public&#39;)</code> 와 같은 경우 <code>&#39;현재 app.js 파일의 경로 + /public&#39;</code> 을 리턴한다.</p><h3 id="express-session"><a href="#express-session" class="headerlink" title="express-session"></a>express-session</h3><p>세션 관리용 미들웨어이며, <code>express-generator</code> 로 설치되지는 않기 때문에 따로 설치해주어야 한다.</p><ul><li><code>npm i express-session</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.use(cookieParser(process.env.COOKIE_SECRET));</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">false</span>,</span><br><span class="line">  secret: process.env.COOKIE_SECRET,</span><br><span class="line">  cookie: &#123;</span><br><span class="line">    httpOnly: <span class="literal">true</span>,</span><br><span class="line">    secure: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p><code>express-session</code> 은 인자로 세션에 대한 설정을 받는다.</p><ul><li><code>resave</code> : 요청이 왔을 때 세션에 수정 사항이 생기지 않더라도 세션을 다시 저장할지에 대한 설정</li><li><code>saveUninitialized</code> : 세션에 저장할 내역이 없더라도 세션을 저장할지에 대한 설정(보통 방문자 추적 시 사용)</li><li><code>secret</code> : 필수 항목. <code>cookie-parser</code> 의 비밀키와 같은 역할<ul><li><code>express-session</code> 은 세션 관리 시 클라이언트에 쿠키를 보낸다. 이를 세션 쿠키라고 하는데, 안전하게 쿠키를 전송하려면 쿠키에 서명(암호화)를 해야하고 쿠키를 서명하는 데 <code>secret</code> 의 값이 필요하다. <code>cookie-parser</code> 와 같이 설정해야 한다. (위의 코드에서는 <code>dotenv</code> 라이브러리를 사용하여 값을 따로 관리했다.  <code>dotenv</code>는 환경변수를 관리해주는 라이브러리인데, <code>.env</code> 파일에 전역적인 정보를 관리하고 <code>.gitignore</code> 에 <code>.env</code> 파일을 추가하여 공개되지 않도록 해야한다.)</li></ul></li><li><code>cookie</code> : 세션 쿠키에 대한 설정 (일반적인 쿠키 옵션이 모두 제공)<ul><li><code>httpOnly</code> : 이 옵션을 사용하면 클라이언트에서 쿠키에 접근하지 못하도록 한다.</li><li><code>secure</code> : <code>false</code> 면 <code>https</code> 가 아닌 환경에서도 사용 가능, <code>true</code> 면 <code>https</code> 에서만 사용 가능<ul><li>배포 시에는 <code>ture</code> 로 바꿔서 배포하는 것이 좋음</li></ul></li></ul></li></ul><h3 id="connect-flash"><a href="#connect-flash" class="headerlink" title="connect-flash"></a>connect-flash</h3><p>일회성 메세지들을 웹 브라우저에 나타낼 때 유용한 미들웨어다.</p><ul><li><code>npm i connect-flash</code></li></ul><p><code>connect-flash</code> 는 <code>cookie-parser</code> 와 <code>express-session</code> 을 사용하기 때문에 이 두 미들웨어보다 아래에 위치시켜야 한다. <code>connect-flash</code> 를 사용하면 <code>req</code> 객체에 <code>req.flash()</code> 메소드를 추가한다. <code>req.flash(key, value)</code> 의 형태로 해당하는 키에 값을 저장하고, <code>req.flash(key)</code> 로 해당 <code>key</code> 의 <code>value</code> 를 불러올 수 있다.</p><p>일회성 메세지이기 때문에 로그인이나 회원가입 에러 같은 일회성 경고 메세지 등에 유용할 것이다.</p><blockquote><p>참조<br><a href="https://psyhm.tistory.com/8" target="_blank" rel="external nofollow noopener noreferrer">https://psyhm.tistory.com/8</a><br><a href="https://psyhm.tistory.com/6" target="_blank" rel="external nofollow noopener noreferrer">https://psyhm.tistory.com/6</a><br><a href="https://nodejs.org/dist/latest-v8.x/docs/api/modules.html#modules_dirname" target="_blank" rel="external nofollow noopener noreferrer">https://nodejs.org/dist/latest-v8.x/docs/api/modules.html#modules_dirname</a><br><a href="https://victorydntmd.tistory.com/23" target="_blank" rel="external nofollow noopener noreferrer">https://victorydntmd.tistory.com/23</a><br>Node.js 교과서</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MiddleWare&quot;&gt;&lt;a href=&quot;#MiddleWare&quot; class=&quot;headerlink&quot; title=&quot;MiddleWare&quot;&gt;&lt;/a&gt;MiddleWare&lt;/h1&gt;&lt;p&gt;미들웨어는 express의 핵심이다. 요청과 응답의 중간에 위치하여 
      
    
    </summary>
    
    
      <category term="Express" scheme="https://kyu9341.github.io/categories/Express/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
      <category term="Express" scheme="https://kyu9341.github.io/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>2020 부스트캠프 챌린지 회고</title>
    <link href="https://kyu9341.github.io/BoostCamp/2020/08/30/BoostCamp_Challenge_review/"/>
    <id>https://kyu9341.github.io/BoostCamp/2020/08/30/BoostCamp_Challenge_review/</id>
    <published>2020-08-29T15:12:28.000Z</published>
    <updated>2021-01-03T17:35:43.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020-부스트캠프-챌린지-회고"><a href="#2020-부스트캠프-챌린지-회고" class="headerlink" title="2020 부스트캠프 챌린지 회고"></a>2020 부스트캠프 챌린지 회고</h1><p>드디어 부스트캠프 챌린지의 4주가 모두 끝났다.. 처음 시작할 때는 매주 마다 회고를 작성해 보아야지! 라고 생각을 했었지만 챌린지가 모두 끝난 이제서야 작성을 해본다.</p><p><a href="https://boostcamp.connect.or.kr/" target="_blank" rel="external nofollow noopener noreferrer">https://boostcamp.connect.or.kr/</a></p><p>정말 밀도있는 한달이었다. 가장 좋았던 점은 내가 평소에 부족하다고 느끼고 공부하고 싶었던 cs지식들을 미션을 통해 공부할 수 있었던 점이다. 또한 그 주제를 자바스크립트로 직접 구현해보며 그것이 어떻게 동작을 하는지 그 개념에 대해 제대로 이해할 수 있었다.</p><h3 id="자바스크립트와-친해지기"><a href="#자바스크립트와-친해지기" class="headerlink" title="자바스크립트와 친해지기"></a>자바스크립트와 친해지기</h3><p>부스트캠프에 오기 전까지 웹 프로젝트를 간단하게 두 번정도 경험을 해보았지만 항상 백엔드 위주로 개발을 하고 프론트 쪽은 템플릿엔진을 사용해서 개발했기 때문에 자바스크립트를 제대로 다뤄볼 기회가 없었다. 노드를 사용하여 간단한 프로젝트를 진행하기도 했지만 자바스크립트에 대한 이해는 많이 부족한 상황에서 시간에 쫓기며 진행한 프로젝트였기 때문에 아쉬움이 남았었다.</p><p>챌린지를 시작하기 전에 자바스크립트 공부를 좀 하고 싶었지만, 정보처리기사 실기를 준비하는라 제대로 공부도 못하고 와서 걱정이 많이 했었다.</p><p>처음에는 readline 모듈을 사용하며 입력을 받는 것부터 비동기 처리 등 생소한 부분이 너무 많았기 때문에 자바스크립트에 적응이 안돼서 어려움을 겪었다. 하지만 미션을 하나 둘 수행해 나가면서 16개의 미션을 모두 마친 지금, 자바스크립트가 이젠 가장 익숙하고 편한 언어가 되어버린 것 같다. <del>부작용으로 다른 언어들을 잊어버리고 있는..?</del></p><h3 id="비교하지-말자"><a href="#비교하지-말자" class="headerlink" title="비교하지 말자"></a>비교하지 말자</h3><p>미션을 받고 문제를 이해하고 이제 개발을 시작하면 벌써 슬랙에서는 빠르게 구현하고 이런저런 예외들까지 고민하면서 만들고 있는 캠퍼분들이 있었다. 그런 캠퍼분들을 보며 나는 왜 아직도 이것밖에 못했지? 라는 생각을 하며 조급해지곤 했는데, 거기에 7시 마감이 위태위태했던 날에는 많은 스트레스를 받았다. 멤버십이 절실한 상황에서 7시 마감을 지키지 못하면 혹시나 영향이 갈까 많이 두렵기도 했고 남들보다 뒤쳐져서는 안된다고 생각했던 것 같다. 그러다 어느 순간 이런 생각이 들었다.</p><blockquote><p>‘나는 개발이 좋고 미션 하나하나가 내가 전부터 해보고 싶었던, 원했던 주제를 공부하고 있는데 왜 즐기지 못하고 남들과 비교하고 마감에 쫓기며 개발하고 있는거지?’</p></blockquote><p>내가 그토록 원했던 교육인데 좀 더 마음에 여유를 가지고 내 방식대로 내가 더 많이 얻어 갈 수 있는 공부를 해야겠다고 생각했다. (물론 도움은 많이 되고 있었다.) 그렇게 하다보면 좋은 결과도 따라올 거라고 생각했고, 이 후 7시 마감과 다른 캠퍼분들의 속도는 신경쓰지 않고 주제에 대한 학습에 조금 더 중점을 두고 내 속도로 개발을 했다. 그러다 보니 점점 즐겁게 학습하고 미션의 결과도 더 좋아질 수 있었다.</p><h3 id="배울게-많다"><a href="#배울게-많다" class="headerlink" title="배울게 많다"></a>배울게 많다</h3><p>부스트캠프에 와서 정말 다양한 사람들은 만날 수 있었는데, 챌린지 과정에서는 4주간 매주 팀원이 바뀌며 진행이 되었다. 좀 친해질만하면 계속 팀이 바뀌게 되어 아쉬운 점도 있었지만 새로운 캠퍼님들과 만날 수 있었고, 더 많은 사람들의 코드를 보며 다양한 스타일의 코드를 접해 볼 수 있었다.</p><p>이런 과정에서 느낀 점은 정말 잘하시는 분들이 많고, 멋있는 분들이 많다는 것이었다. 정말 코드를 예쁘게 짜시는 분, 자신의 생각을 조리있게 말하고 설득력 있게 팀을 이끌어 가시는 분, 정말 뛰어난 실력을 가지고 팀원들의 모범이 되는 분, 미션을 완벽하게 하진 못했지만 그 주제에 대해 깊이있는 이해를 하시는 분, 자신의 부족함을 인정하고 더 배우기 위해 노력하시는 분 등.. 정말 자신만의 강점들을 가지고 계신 분들이 많았다. 이런 멋진 캠퍼들을 보며 많은 자극을 느낄 수 있었고, 나도 팀원들에게 좋은 영향력을 끼치는 사람이 되기 위해 노력했다.</p><p>그러면서 나만의 강점은 무엇일까? 라는 생각을 계속 해왔었다. 챌린지 마지막에 서로 롤링페이퍼를 써주었는데, 여러 캠퍼분들이 코드가 깔끔하고 많이 배웠다는 말씀을 많이 해주셨다. 정말 감사했고, 한편으로는 나도 다른 사람들에게 조금은 좋은 영향을 주었다는 생각에 뿌듯하기도 했다.</p><p>부스트캠프 챌린지 과정에서의 4주는 내 인생에서 가장 가치있는 4주라고 말해도 과언이 아닐 것이다. 같은 곳을 바라보는 열정 가득하고 실력있는 사람들과 함께 서로의 의견을 나누고 함께 발전할 수 있는 기회를 가질 수 있어서 정말 행복했고, 나와 같은 팀을 했던 모든 분들께 감사의 인사를 드리고 싶다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2020-부스트캠프-챌린지-회고&quot;&gt;&lt;a href=&quot;#2020-부스트캠프-챌린지-회고&quot; class=&quot;headerlink&quot; title=&quot;2020 부스트캠프 챌린지 회고&quot;&gt;&lt;/a&gt;2020 부스트캠프 챌린지 회고&lt;/h1&gt;&lt;p&gt;드디어 부스트캠프 
      
    
    </summary>
    
    
      <category term="BoostCamp" scheme="https://kyu9341.github.io/categories/BoostCamp/"/>
    
    
      <category term="boostcamp" scheme="https://kyu9341.github.io/tags/boostcamp/"/>
    
  </entry>
  
  <entry>
    <title>NPM - line-controller 패키지 배포</title>
    <link href="https://kyu9341.github.io/NPM/2020/08/29/npm_line_controller/"/>
    <id>https://kyu9341.github.io/NPM/2020/08/29/npm_line_controller/</id>
    <published>2020-08-28T15:12:28.000Z</published>
    <updated>2020-08-30T16:53:06.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-패키지-제작기"><a href="#npm-패키지-제작기" class="headerlink" title="npm 패키지 제작기"></a>npm 패키지 제작기</h2><p>블로그를 좀 꾸며 보려다 보니 이미 작성된 많은 글들에 카테고리별로 공통적인 line을 추가해야 할 일이 생겼다. 하나의 카테고리에 몇 가지 안되는 글이 있는 것은 괜찮았지만 100개 가까이 되는 카테고리인 경우에는 언제 하나하나 다 넣나 막막했다. 그래서 그냥 자동으로 원하는 line에 원하는 텍스트를 넣는 간단한 프로그램을 만들어 보았다.</p><p>만들어 본 김에 npm에 배포를 해보고 싶어서 몇 가지 기능을 좀 더 추가하여 배포해 보았다.</p><ul><li>초기 작성본</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WRITE_DIR = <span class="string">'./writeDirTest\\'</span>;</span><br><span class="line"><span class="keyword">const</span> TARGET_WORD = <span class="string">'algorithm3'</span>;</span><br><span class="line"><span class="keyword">const</span> NEWLINE = <span class="string">'\r\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UTF_8 = <span class="string">'utf8'</span>;</span><br><span class="line"><span class="keyword">const</span> TARGET_LINE_NUM = <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> INSERT_LINE = <span class="string">`tags:`</span>;</span><br><span class="line"><span class="keyword">const</span> INSERT_LINE2 = <span class="string">`\t- Algorithm`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileList = <span class="function">(<span class="params">dirPath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readdirSync(dirPath, (err, fileList) =&gt; fileList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterFileList = <span class="function">(<span class="params">fileList, targetWord</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileList.filter(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fileName.substr(<span class="number">0</span>, targetWord.length) === targetWord</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileContents = <span class="function">(<span class="params">fileName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(WRITE_DIR + fileName, UTF_8, (err, contents) =&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insert = <span class="function">(<span class="params">fileContent, targetLine</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contentArr = fileContent.split(NEWLINE);</span><br><span class="line">    contentArr.splice(targetLine, <span class="number">0</span>, INSERT_LINE, INSERT_LINE2);</span><br><span class="line">    <span class="keyword">return</span> contentArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insertLines = <span class="function">(<span class="params">targetDir, targetWord, targetLine</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileList = readFileList(targetDir);</span><br><span class="line">    <span class="keyword">const</span> filteredList = filterFileList(fileList, targetWord);</span><br><span class="line"></span><br><span class="line">    filteredList.forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileContents = readFileContents(fileName);</span><br><span class="line">        <span class="keyword">const</span> inserted = insert(fileContents, targetLine);</span><br><span class="line">        <span class="keyword">const</span> result = inserted.join(NEWLINE);</span><br><span class="line"></span><br><span class="line">        fs.writeFile(targetDir + fileName, result, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertLines(WRITE_DIR, TARGET_WORD, TARGET_LINE_NUM);</span><br></pre></td></tr></table></figure><p>위의 상태는 원하는 폴더에서 파일명이 <code>TARGET_WORD</code> 로 시작하는 파일의 <code>TARGET_LINE_NUM</code> 번째 라인에 원하는 텍스트를 추가하도록 구현했다. 이제 조금 더 확장성 있는 형태로 바꾸어보자.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WRITE_DIR = <span class="string">'./writeDirTest\\'</span>;</span><br><span class="line"><span class="keyword">const</span> TARGET_WORD = <span class="string">'algorithm3'</span>;</span><br><span class="line"><span class="keyword">const</span> NEWLINE = <span class="string">'\r\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UTF_8 = <span class="string">'utf8'</span>;</span><br><span class="line"><span class="keyword">const</span> TARGET_LINE_NUM = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> INSERT_LINE = <span class="string">`tags:`</span>;</span><br><span class="line"><span class="keyword">const</span> INSERT_LINE2 = <span class="string">`\t- Algorithm`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileList = <span class="function">(<span class="params">dirPath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readdirSync(dirPath, (err, fileList) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filterFileList = <span class="function">(<span class="params">fileList, targetWord</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileList.filter(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fileName.substr(<span class="number">0</span>, targetWord.length) === targetWord</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileContents = <span class="function">(<span class="params">fileName</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(WRITE_DIR + fileName, UTF_8, (err, contents) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insert = <span class="function">(<span class="params">fileContent, targetLine, lines</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contentArr = fileContent.split(NEWLINE);</span><br><span class="line">    contentArr.splice(targetLine - <span class="number">1</span>, <span class="number">0</span>, ...lines);</span><br><span class="line">    <span class="keyword">return</span> contentArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> insertLine = <span class="function">(<span class="params">targetDir, targetWord, targetLine, ...lines</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileList = readFileList(targetDir);</span><br><span class="line">    <span class="keyword">const</span> filteredList = filterFileList(fileList, targetWord);</span><br><span class="line"></span><br><span class="line">    filteredList.forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileContents = readFileContents(fileName);</span><br><span class="line">        <span class="keyword">const</span> inserted = insert(fileContents, targetLine, lines);</span><br><span class="line">        <span class="keyword">const</span> result = inserted.join(NEWLINE);</span><br><span class="line"></span><br><span class="line">        fs.writeFile(targetDir + fileName, result, () =&gt; &#123; &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insertLine(WRITE_DIR, TARGET_WORD, TARGET_LINE_NUM, INSERT_LINE, INSERT_LINE2);</span><br></pre></td></tr></table></figure><p>rest parameter 를 활용해서 원하는 만큼 인자를 받아서 받은 인자를 모두 삽입할 수 있도록 구현했다.</p><p>삽입 기능만 있으면 심심하니까 삭제, 수정, 조회 기능을 추가하고 os 별 호환이 가능하도록 개행문자를 os모듈에서 받아 오도록 하여 사용했다. 또한 디렉토리 내에서 파일명이 특정 문자열로 시작하는 파일에 적용되도록 구현했던 것을 파일명에 특정 문자열이 포함되기만 하면 되도록 수정하였다.</p><ul><li>최종 배포 코드</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"><span class="keyword">const</span> NEWLINE = os.EOL;</span><br><span class="line"><span class="keyword">const</span> UTF_8 = <span class="string">'utf8'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>원하는 디렉토리 내부의 파일 목록을 읽어온다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>dirPath 읽어올 디렉토리 경로</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Array&#125;</span> </span>파일 목록을 배열로 리턴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> readFileList = <span class="function">(<span class="params">dirPath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readdirSync(dirPath, (err, fileList) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error :'</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>파일 목록에서 파일명에 특정 문자열이 포함된 파일들의 목록을 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>fileList 전체 파일 목록</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetWord 특정 문자열</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Array&#125;</span> </span>targetWord가 파일명에 포함된 파일 목록 리턴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> filterFileList = <span class="function">(<span class="params">fileList, targetWord</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fileList.filter(<span class="function"><span class="params">fileName</span> =&gt;</span> fileName.indexOf(targetWord) &gt; <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>파일 내용을 동기적으로 읽어오는 함수</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>fileName 파일명</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetDir 디렉토리 경로</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>읽어온 파일 내용</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> readFileContents = <span class="function">(<span class="params">fileName, targetDir = <span class="string">''</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(targetDir + fileName, UTF_8, (err, contents) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error :'</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>특정 line에 lines을 삽입한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>fileContent 기존 파일 내용</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 삽입할 line number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>lines 삽입될 line들 목록</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>삽입된 결과 문자열을 리턴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> insert = <span class="function">(<span class="params">fileContent, targetLine, lines</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contentArr = fileContent.split(NEWLINE);</span><br><span class="line">    contentArr.splice(targetLine - <span class="number">1</span>, <span class="number">0</span>, ...lines);</span><br><span class="line">    <span class="keyword">return</span> contentArr.join(NEWLINE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>특정 line에 lines을 삽입한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>fileContent 기존 파일 내용</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>startLine 제거할 시작 line number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>deleteCount 제거될 line 개수</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>line이 제거된 결과 문자열을 리턴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> remove = <span class="function">(<span class="params">fileContent, startLine, deleteCount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contentArr = fileContent.split(NEWLINE);</span><br><span class="line">    contentArr.splice(startLine - <span class="number">1</span>, deleteCount);</span><br><span class="line">    <span class="keyword">return</span> contentArr.join(NEWLINE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>특정 line을 수정한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>fileContent 기존 파일 내용</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 수정할 line number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>text 수정할 내용</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>수정된 결과 문자열을 리턴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> update = <span class="function">(<span class="params">fileContent, targetLine, text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contentArr = fileContent.split(NEWLINE);</span><br><span class="line">    contentArr.splice(targetLine - <span class="number">1</span>, <span class="number">1</span>, text);</span><br><span class="line">    <span class="keyword">return</span> contentArr.join(NEWLINE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>특정 lines을 조회한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>fileContent 기존 파일 내용</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 조회할 line number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>selectCount 조회할 line 개수</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>조회된 결과 문자열을 리턴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> select = <span class="function">(<span class="params">fileContent, targetLine, selectCount</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contentArr = fileContent.split(NEWLINE);</span><br><span class="line">    <span class="keyword">return</span> contentArr.filter(<span class="function">(<span class="params">_, idx</span>) =&gt;</span></span><br><span class="line">        idx &gt;= targetLine - <span class="number">1</span> &amp;&amp; idx &lt; targetLine - <span class="number">1</span> + selectCount).join(NEWLINE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>targetDir에 있는 파일들 중 파일명에 targetWord가 포함되는 파일에 원하는 line들을 삽입한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetDir 원하는 디렉토리의 경로 ex) 'files/'</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetWord 파일명에 포함된 원하는 단어</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 삽입하고 싶은 라인 번호</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;...String&#125;</span> </span>lines 삽입하고 싶은 문자열 (여러 문자열 가능)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span> </span>수행된 프로미스. resolve에 삽입된 결과 파일의 내용이 담긴다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> insertLine = <span class="function">(<span class="params">targetDir, targetWord, targetLine, ...lines</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileList = readFileList(targetDir);</span><br><span class="line">        <span class="keyword">const</span> filteredList = filterFileList(fileList, targetWord);</span><br><span class="line"></span><br><span class="line">        filteredList.forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fileContents = readFileContents(fileName, targetDir);</span><br><span class="line">            <span class="keyword">const</span> result = insert(fileContents, targetLine, lines);</span><br><span class="line">            fs.writeFile(targetDir + fileName, result, UTF_8, err =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error :'</span>, err);</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>targetDir에 있는 파일들 중 파일명에 targetWord가 포함되는 파일에 원하는 line을 지운다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetDir 원하는 디렉토리의 경로 ex) 'files/'</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetWord 파일명에 포함된 원하는 단어</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 삭제하고 싶은 라인 번호</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>deleteCount 삭제를 원하는 라인 수 (default = 1) optional</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span> </span>수행된 프로미스. resolve에 목표 라인이 제거된 결과 파일의 내용이 담긴다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> deleteLine = <span class="function">(<span class="params">targetDir, targetWord, targetLine, deleteCount = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileList = readFileList(targetDir);</span><br><span class="line">        <span class="keyword">const</span> filteredList = filterFileList(fileList, targetWord);</span><br><span class="line"></span><br><span class="line">        filteredList.forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fileContents = readFileContents(fileName, targetDir);</span><br><span class="line">            <span class="keyword">const</span> result = remove(fileContents, targetLine, deleteCount)</span><br><span class="line"></span><br><span class="line">            fs.writeFile(targetDir + fileName, result, UTF_8, err =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error :'</span>, err);</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>targetDir에 있는 파일들 중 파일명에 targetWord가 포함되는 파일에 원하는 line을 수정한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetDir 원하는 디렉토리의 경로 ex) 'files/'</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>targetWord 파일명에 포함된 원하는 단어</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 수정하고 싶은 라인 번호</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>text 수정하고 싶은 문자열</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Promise&#125;</span> </span>수행된 프로미스. resolve에 수정된 결과 파일의 내용이 담긴다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> updateLine = <span class="function">(<span class="params">targetDir, targetWord, targetLine, text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileList = readFileList(targetDir);</span><br><span class="line">        <span class="keyword">const</span> filteredList = filterFileList(fileList, targetWord);</span><br><span class="line"></span><br><span class="line">        filteredList.forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fileContents = readFileContents(fileName, targetDir);</span><br><span class="line">            <span class="keyword">const</span> result = update(fileContents, targetLine, text)</span><br><span class="line"></span><br><span class="line">            fs.writeFile(targetDir + fileName, result, UTF_8, err =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'Error :'</span>, err);</span><br><span class="line">                resolve(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>fileName 파일의 원하는 line을 읽어온다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>fileName 읽고자 하는 파일의 경로 ex) 'files/abc.txt'</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>targetLine 읽고 싶은 시작 line 번호</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>selectCount 읽고자 하는 line 수 (default = 1) optional</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;String&#125;</span> </span>읽어온 결과 문자열</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> selectLine = <span class="function">(<span class="params">fileName, targetLine, selectCount = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileContents = readFileContents(fileName);</span><br><span class="line">    <span class="keyword">const</span> result = select(fileContents, targetLine, selectCount);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; insertLine, deleteLine, updateLine, selectLine, NEWLINE &#125;;</span><br></pre></td></tr></table></figure><p><code>jest 라이브러리</code>를 사용하여 간단한 테스트도 작성했다.</p><ul><li>테스트 코드</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  &#123; insertLine, deleteLine, updateLine, selectLine, NEWLINE &#125; = <span class="built_in">require</span>(<span class="string">'../lineController'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WRITE_DIR = <span class="string">'files/'</span>;</span><br><span class="line"><span class="keyword">const</span> TARGET_WORD = <span class="string">'3085'</span>;</span><br><span class="line"><span class="keyword">const</span> TARGET_FILE = <span class="string">'files/algorithm3085.md'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SELECT_LINE_TEST =</span><br><span class="line"><span class="string">`---</span></span><br><span class="line"><span class="string">layout: post</span></span><br><span class="line"><span class="string">title: "백준 3085번 사탕 게임"</span></span><br><span class="line"><span class="string">subtitle: "Baekjoon algorithm"</span></span><br><span class="line"><span class="string">date: 2020-02-24 09:51:12</span></span><br><span class="line"><span class="string">author: kwon</span></span><br><span class="line"><span class="string">categories: algorithm</span></span><br><span class="line"><span class="string">---`</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">"test lineEditor"</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">"selectLine"</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> selected = selectLine(TARGET_FILE, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        expect(SELECT_LINE_TEST).toEqual(selected);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">"insertLine"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> insertLine(WRITE_DIR, TARGET_WORD, <span class="number">1</span>, <span class="string">'insert'</span>, <span class="string">'insert2'</span>);</span><br><span class="line">        <span class="keyword">const</span> selected = selectLine(TARGET_FILE, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        expect(<span class="string">`insert<span class="subst">$&#123;NEWLINE&#125;</span>insert2`</span>).toEqual(selected);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">"updateLine"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> updateLine(WRITE_DIR, TARGET_WORD, <span class="number">1</span>, <span class="string">'update'</span>);</span><br><span class="line">        <span class="keyword">const</span> selected = selectLine(TARGET_FILE, <span class="number">1</span>);</span><br><span class="line">        expect(<span class="string">'update'</span>).toEqual(selected);</span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">"deleteLine"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> deleteLine(WRITE_DIR, TARGET_WORD, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> selected = selectLine(TARGET_FILE, <span class="number">1</span>);</span><br><span class="line">        expect(<span class="string">'---'</span>).toEqual(selected);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>npm 패키지를 배포해보는 것은 처음이었는데 생각보다 어렵지 않았다. 간단하게 배포 과정을 살펴보자면,</p><p>먼저 <a href="https://www.npmjs.com/" target="_blank" rel="external nofollow noopener noreferrer">npm</a> 사이트에 회원가입을 하고 이메일 인증까지 해야한다.</p><p>터미널에서 <code>npm login</code> 을 통해 로그인을 하고 <code>npm whoami</code> 를 통해 제대로 로그인이 되었는지 확인할 수 있다.</p><p>이제 패키지명을 결정해야 하는데, 처음 생각했던 것은 <code>line-editor</code> 였지만 이미 존재했기 때문에 <code>line-controller</code> 로 결정하게 되었다. 이제 <code>npm init</code> 을 통해 <code>package.json</code> 을 생성하여 패키지명, 버전, 설명, 라이센스 등을 설정해주면 된다.</p><p>배포하기 전에 로컬에서 직접 테스트를 해볼 수도 있었는데, <code>npm install [작성한 패키지 디렉토리 경로]</code> 를 하면 로컬에서 내가 만든 패키지를 다운받아 사용해볼 수 있다.</p><p>이후 <code>npm publish</code> 명령어를 통해 npm에 배포를 할 수 있었다.</p><ul><li><a href="https://www.npmjs.com/package/line-controller" target="_blank" rel="external nofollow noopener noreferrer">NPM page</a></li><li><a href="https://github.com/kyu9341/line-controller.js" target="_blank" rel="external nofollow noopener noreferrer">github</a></li></ul><p>필요에 의해 간단히 만들어본 프로그램이었지만 조금 다듬어서 npm에 배포까지 해보았다. 별거 아닌 것이긴 하지만 처음 패키지를 배포해봤다는 것에 의의를 둬본다.</p><blockquote><p>참조<br><a href="https://www.daleseo.com/js-npm-publish/" target="_blank" rel="external nofollow noopener noreferrer">https://www.daleseo.com/js-npm-publish/</a><br><a href="https://heropy.blog/2019/01/31/node-js-npm-module-publish/" target="_blank" rel="external nofollow noopener noreferrer">https://heropy.blog/2019/01/31/node-js-npm-module-publish/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-패키지-제작기&quot;&gt;&lt;a href=&quot;#npm-패키지-제작기&quot; class=&quot;headerlink&quot; title=&quot;npm 패키지 제작기&quot;&gt;&lt;/a&gt;npm 패키지 제작기&lt;/h2&gt;&lt;p&gt;블로그를 좀 꾸며 보려다 보니 이미 작성된 많은 글들에 카테고
      
    
    </summary>
    
    
      <category term="NPM" scheme="https://kyu9341.github.io/categories/NPM/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
      <category term="NPM" scheme="https://kyu9341.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>깃(Git) - .gitignore 파일 다루기</title>
    <link href="https://kyu9341.github.io/Git/2020/08/23/git_gitignore/"/>
    <id>https://kyu9341.github.io/Git/2020/08/23/git_gitignore/</id>
    <published>2020-08-22T15:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitignore-파일"><a href="#gitignore-파일" class="headerlink" title=".gitignore 파일"></a>.gitignore 파일</h2><p><code>.gitignore</code> 파일은 이름에서 느껴지듯이 git이 관리하지 않을 파일들을 지정해두는 파일이다.<br>프로젝트를 진행하다 보면 자동으로 생성되는 로그파일이나 외부 패키지, 깃에 공유되어서는 안되는 api키와 같은 내용이 작성된  <code>.env</code> 와 같은 파일들이 있을 것이다.<br><code>.gitignore</code> 에 원격 저장소에 commit 하고 싶지 않은 내용을 작성해두면 git에서 그 내용을 읽어 해당하는 디렉토리 또는 경로 패턴에 위치한 파일들을 버전관리에서 무시하도록 해준다.<br>이 때, <code>.gitignore</code> 는 항상 <code>.git</code> 폴더가 위치한 루트 디렉토리에 존재해야 한다.</p><h2 id="gitignore-생성"><a href="#gitignore-생성" class="headerlink" title=".gitignore 생성"></a>.gitignore 생성</h2><p><code>.git</code> 폴더가 있는 위치에 생성해주면 되는데, 윈도우의 경우 그냥 메모장으로 작성하여 txt파일이 아니라 모든 파일로 설정한 후에 파일명을 <code>.gitignore</code> 로 작성해주면 된다. 아니면 git bash 를 이용하여 해당 폴더로 이동한 뒤 <code>vim .gitignore</code> 명령으로 생성하여 작성해도 무방하다. 이후 버전관리를 하지 않을 목록을 작성하면 된다.</p><p>이 때, 이미 버전관리를 수행 중인 파일들을 <code>.gitignore</code> 에 작성하게 되면 git은 원래대로 그 파일들을 추적하게 된다. 이 경우에는 이미 버전 관리가 되고 있는 파일들을 수동으로 해당 파일들을 버전 관리에서 제외시켜주어야 한다. 다음의 명령어들을 사용하여 처리한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m "fixed untracked files"</span><br></pre></td></tr></table></figure><ul><li><code>git rm -r --cached .</code>  : 현재 Repository의 cache를 모두 삭제한다.</li><li><code>git rm -r --cached &lt;filename&gt;</code>  : <filename>해당하는 파일을 원격 저장소에서 삭제한다.<ul><li><code>git rm &lt;filename&gt;</code>  : 원격 저장소와 로컬 저장소에 있는 파일을 삭제한다.</li><li><code>git rm --cached &lt;filename&gt;</code> : 원격 저장소에 있는 파일을 삭제한다. 로컬 저장소에 있는 파일은 삭제하지 않는다</li><li><code>-r</code> 옵션 : 하위 디렉토리를 포함하여 모든 내용을 삭제한다.</li></ul></filename></li><li>이후 <code>git add .</code> 을 통해  <code>.gitignore</code>에 넣은 파일 목록들을 제외하고 다른 모든 파일을 다시 track하도록 설정한다.</li><li>위 작업 이후에는 반드시 커밋을 해준다.  <code>git commit -m &quot;fixed untracked files&quot;</code></li></ul><h2 id="gitignore-문법"><a href="#gitignore-문법" class="headerlink" title=".gitignore 문법"></a>.gitignore 문법</h2><table><thead><tr><th align="center">패턴</th><th>설명</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td><code>/</code> 를 제외한 모든 <strong>문자열</strong>과 매칭 (문자열 길이 0이상)</td></tr><tr><td align="center"><code>**</code></td><td><code>/</code> 를 포함한 모든 <strong>문자열</strong>과 매칭 (문자열 길이 0이상)</td></tr><tr><td align="center"><code>?</code></td><td><code>/</code> 를 제외한 하나의 <strong>문자</strong>와 매칭 (빈 문자 x)</td></tr><tr><td align="center"><code>[abc]</code></td><td><code>[]</code> 안에 있는 모든 각각의 <strong>문자</strong>들과 매칭 (a또는 b또는 c 중에 하나)</td></tr><tr><td align="center"><code>{a, b, c}</code></td><td><code>{}</code> 안에 있는 , 로 구분된 각각의 <strong>문자열</strong>들과 매칭</td></tr><tr><td align="center"><code>[^abc]</code></td><td><code>[]</code> 안에 있는 모든 각각의 문자들을 제외한 <strong>문자</strong>들과 매칭</td></tr><tr><td align="center"><code>[a-z]</code></td><td><code>[]</code> 안에서 - 사이에 있는 첫 문자와 마지막 문자 범위에 있는 모든 <strong>문자</strong>들에 대해 매칭 (a-z, A-Z, 0-9 등..)</td></tr><tr><td align="center"><code>/</code></td><td><code>/</code> 부터 시작하는 경로 패턴은 하위 디렉토리에 반복적으로 적용되지 않는다.</td></tr><tr><td align="center"><code>!</code></td><td><code>!</code> 로 시작하는 패턴은 <code>.gitignore</code>에서 <strong>제외</strong>되며, 무시되지 않는다.</td></tr><tr><td align="center"><code>#</code></td><td><code>#</code> 으로 시작하면 <strong>주석</strong>처리</td></tr></tbody></table><p><code>.gitignore</code> 파일은 Glob 패턴에 따라 작성이 된다. Glob 패턴은 와일드 카드 문자를 사용하여 일정한 패턴을 가진 파일 이름을 지정하기 위한 패턴이다. 정규표현식과 유사한 문법들이 많다.</p><h3 id="작성-예시"><a href="#작성-예시" class="headerlink" title="작성 예시"></a>작성 예시</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 확장자가 .js 인 파일은 무시</span></span><br><span class="line">*.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># .js 파일들은 모두 무시되지만, test.js만은 무시하지 않음</span></span><br><span class="line">!test.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 현재 디렉토리에 있는 /test.js파일은 무시되지만,</span></span><br><span class="line"><span class="comment"># subDir/test.js 같이 특정 디렉토리 하위에 있는 test.js는 무시되지 않음</span></span><br><span class="line">/test.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># node_modules/ 디렉토리에 있는 모든 파일을 무시</span></span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"><span class="comment"># src/ 하위의 .js파일만 무시</span></span><br><span class="line">src/*.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># src/ 하위에 존재하는 모든 디렉토리의 .txt 파일을 무시</span></span><br><span class="line">src/**/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 현재 디렉토리와 그 하위 디렉토리 내에 존재하는 모든 .js 파일을 무시</span></span><br><span class="line">/**/*.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 현재 디렉토리 내에 존재하는 모든 .js .ts 파일 무시</span></span><br><span class="line">/*.&#123;js, ts&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 현재 디렉토리 내에 있는 ex1.js ex2.js ex3.js 파일 무시</span></span><br><span class="line">/ex[1-3].js</span><br></pre></td></tr></table></figure><ul><li>참고로 개발 환경이나 언어를 입력하면 자동으로 해당하는  <code>.gitignore</code> 파일을 생성해주는 사이트가 있다.<ul><li><a href="https://www.toptal.com/developers/gitignore" target="_blank" rel="external nofollow noopener noreferrer">https://www.toptal.com/developers/gitignore</a></li></ul></li></ul><p>참조</p><blockquote><p><a href="https://victorydntmd.tistory.com/80" target="_blank" rel="external nofollow noopener noreferrer">https://victorydntmd.tistory.com/80</a><br><a href="https://dololak.tistory.com/306" target="_blank" rel="external nofollow noopener noreferrer">https://dololak.tistory.com/306</a><br><a href="https://velog.io/@conatuseus/.gitignore-사용하기-imk4708751" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@conatuseus/.gitignore-사용하기-imk4708751</a><br><a href="https://velog.io/@k7120792/Glob-패턴과-정규표현식" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@k7120792/Glob-패턴과-정규표현식</a><br><a href="https://git-scm.com/docs/gitignore](https://git-scm.com/docs/gitignore" target="_blank" rel="external nofollow noopener noreferrer">https://git-scm.com/docs/gitignore](https://git-scm.com/docs/gitignore</a><br><a href="https://mygumi.tistory.com/103" target="_blank" rel="external nofollow noopener noreferrer">https://mygumi.tistory.com/103</a><br><a href="https://gmlwjd9405.github.io/2017/10/06/make-gitignore-file.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2017/10/06/make-gitignore-file.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gitignore-파일&quot;&gt;&lt;a href=&quot;#gitignore-파일&quot; class=&quot;headerlink&quot; title=&quot;.gitignore 파일&quot;&gt;&lt;/a&gt;.gitignore 파일&lt;/h2&gt;&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 파일은 
      
    
    </summary>
    
    
      <category term="Git" scheme="https://kyu9341.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://kyu9341.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트(JavaScript) - Spread Syntax (전개 구문)</title>
    <link href="https://kyu9341.github.io/JavaScript/2020/08/16/JavaScript_spread_syntax/"/>
    <id>https://kyu9341.github.io/JavaScript/2020/08/16/JavaScript_spread_syntax/</id>
    <published>2020-08-16T12:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spread-Syntax-전개-구문"><a href="#Spread-Syntax-전개-구문" class="headerlink" title="Spread Syntax (전개 구문)"></a>Spread Syntax (전개 구문)</h1><ul><li>Spread  Syntax(전개 구문)는 es6에 추가된 문법으로 iterable 객체를 개별 요소로 분리시키는 문법이다.<ul><li>iterable - 배열, 문자열, set, map 등..</li></ul></li></ul><h2 id="Spread-문법의-사용방법"><a href="#Spread-문법의-사용방법" class="headerlink" title="Spread 문법의 사용방법"></a>Spread 문법의 사용방법</h2><h3 id="함수-호출"><a href="#함수-호출" class="headerlink" title="함수 호출"></a>함수 호출</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kwon = [<span class="string">'k'</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(...kwon));</span><br><span class="line"><span class="comment">// 출력 : kwon</span></span><br></pre></td></tr></table></figure><p>위와 같이 함수를 호출할 때 매개변수로 전개 연산자를 사용하여 배열을 넘겨 각각의 인자에 배열의 원소를 할당할 수 있다. 이 때, 물론 매개변수의 개수가 일치해야 한다.</p><h3 id="배열-리터럴과-문자열"><a href="#배열-리터럴과-문자열" class="headerlink" title="배열 리터럴과 문자열"></a>배열 리터럴과 문자열</h3><p>두 배열을 연결하는 경우 <code>Array.prototype.concat()</code> 을 사용하여 기존 배열에 새로운 배열의 요소를 추가하여 새로운 배열을 만들 수 있었다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'jo'</span>, <span class="string">'park'</span>, <span class="string">'lee'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="comment">// 출력 : [ 'kwon', 'kim', 'jung', 'jo', 'park', 'lee' ]</span></span><br></pre></td></tr></table></figure><p>위의 코드를 전개 구문을 사용하는 경우 간편하게 작성할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'jo'</span>, <span class="string">'park'</span>, <span class="string">'lee'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = [...arr1, ...arr2];</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="comment">// 출력 : [ 'kwon', 'kim', 'jung', 'jo', 'park', 'lee' ]</span></span><br></pre></td></tr></table></figure><p>또한 <code>push</code>, <code>splice</code> 등을 활용, 대신하여 다양한 방식으로 배열을 다룰 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'jo'</span>, <span class="string">'park'</span>, <span class="string">'lee'</span>];</span><br><span class="line"></span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// 출력 : [ 'kwon', 'kim', 'jung', 'jo', 'park', 'lee' ]</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'jo'</span>, <span class="string">'park'</span>, <span class="string">'lee'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = [...arr2, <span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="comment">// 출력 : [ 'jo', 'park', 'lee', 'kwon', 'kim', 'jung' ]</span></span><br><span class="line"><span class="keyword">const</span> arr4 = [<span class="string">'kwon'</span>, ...arr2, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br><span class="line"><span class="comment">// 출력 : [ 'kwon', 'jo', 'park', 'lee', 'kim', 'jung' ]</span></span><br></pre></td></tr></table></figure><p>문자열도 iterable 이기 때문에 전개구문을 사용 가능하다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'abcdefg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">''</span>)); <span class="comment">// 기존 방식</span></span><br><span class="line"><span class="comment">// 출력 : ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">// 전개 구문 적용</span></span><br><span class="line"><span class="comment">// 출력 : ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure><h3 id="배열-복사"><a href="#배열-복사" class="headerlink" title="배열 복사"></a>배열 복사</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br><span class="line"><span class="comment">// 출력 : [ 'kwon', 'kim', 'jung' ]</span></span><br><span class="line">arr2.push(<span class="string">'jo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// 출력 : [ 'kwon', 'kim', 'jung' ]</span></span><br></pre></td></tr></table></figure><p>전개 구문을 통해 배열을 복사하는 경우 깊은 복사를 할 수 있다. 깊은 복사는 복사를 통해 생성된 배열을 변경하여도 원본 배열에 영향이 없어야 한다. 하지만, 배열 안에 또 배열or객체가 있는 경우에는 깊은 복사가 제대로 이루어지지 않는다. 즉, (원시 타입으로 구성된) 1차원 배열에서만 전개 구문을 통해 깊은 복사를 할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [[<span class="string">'kwon'</span>, <span class="string">'kim'</span>], <span class="string">'jung'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line">arr2[<span class="number">0</span>].pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// 출력 : [ [ 'kwon' ], 'jung' ]</span></span><br></pre></td></tr></table></figure><p>위와 같이 배열 안에 있는 배열을 변경하는 경우에는 원본 배열에도 영향을 미치는 것을 볼 수 있다.</p><h3 id="객체-리터럴"><a href="#객체-리터럴" class="headerlink" title="객체 리터럴"></a>객체 리터럴</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">key1</span>: <span class="string">'val1'</span>, <span class="attr">key2</span>: <span class="string">'val2'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">key3</span>: <span class="string">'val3'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br><span class="line"><span class="comment">// 출력 : &#123; key1: 'val1', key2: 'val2', key3: 'val3' &#125;</span></span><br></pre></td></tr></table></figure><p>객체에서도 전개 구문을 사용하여 객체를 정의할 수 있다.<br>하지만, 객체 리터럴에서와 달리 함수 호출과 배열 리터럴에서의 전개 구문은 반드시 iterable 이어야 사용이 가능하다는 것이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">key1</span>: <span class="string">'val1'</span>, <span class="attr">key2</span>: <span class="string">'val2'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jung'</span>, ...obj1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// 에러 :  obj1 is not iterable</span></span><br></pre></td></tr></table></figure><hr><h2 id="Spread-Syntax-전개-구문-활용"><a href="#Spread-Syntax-전개-구문-활용" class="headerlink" title="Spread Syntax(전개 구문) 활용"></a>Spread Syntax(전개 구문) 활용</h2><h3 id="나머지-매개변수"><a href="#나머지-매개변수" class="headerlink" title="나머지 매개변수"></a>나머지 매개변수</h3><p>rest 파라미터는 함수의 마지막 파라미터 앞에 <code>...</code> 을 붙여 모드 나머지 인수를 유사 배열이 아닌, ‘표준’ 자바스크립트 배열로 대체한다. (arguments 객체(유사배열)와 차이점)</p><p>특정 인수의 갯수를 지정할 필요없이 들어온 인수를 배열로 전달받을 수 있어 유용하다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn1 = <span class="function">(<span class="params">a, b, ...rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1(<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jo'</span>, <span class="string">'jung'</span>, <span class="string">'lee'</span>);</span><br></pre></td></tr></table></figure><p>출력</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kwon</span></span><br><span class="line"><span class="selector-tag">kim</span></span><br><span class="line"><span class="selector-attr">[ <span class="string">'jo'</span>, <span class="string">'jung'</span>, <span class="string">'lee'</span> ]</span></span><br></pre></td></tr></table></figure><p>아래는 모든 인자를 누적하여 합을 리턴해주는 함수이다. ( <code>Array.prototype.reduce()</code> 사용)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sumAll = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sumAll(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sumAll(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(sumAll(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>매개변수를 몇 개로 받더라도 모두 배열로 넘겨받아 정상적으로 처리되는 것을 볼 수 있다.<br>나머지 매개변수를 사용할 때 주의할 점은 항상 가장 마지막 파라미터로 나머지 매개변수를 사용해야 한다는 점이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn1 = <span class="function">(<span class="params">arg1, ...rest, arg2</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 에러 : Rest parameter must be last formal parameter</span></span><br></pre></td></tr></table></figure><p>위와 같이 중간에 나머지 매개변수를 넣게 되면 에러가 발생한다.</p><h3 id="배열에서-중복-원소-제거"><a href="#배열에서-중복-원소-제거" class="headerlink" title="배열에서 중복 원소 제거"></a>배열에서 중복 원소 제거</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> newArr = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(newArr);</span><br><span class="line"><span class="comment">// 출력 : [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><p><code>Set</code>과 함께 사용하면 위와 같이 중복을 제거하는 것도 가능하다.</p><h3 id="구조-분해-할당"><a href="#구조-분해-할당" class="headerlink" title="구조 분해 할당"></a>구조 분해 할당</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ first, second, ...rest ] = [<span class="string">'kwon'</span>, <span class="string">'kim'</span>, <span class="string">'jo'</span>, <span class="string">'jung'</span>, <span class="string">'lee'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first, second); <span class="comment">// 출력 : kwon kim</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// 출력 : [ 'jo', 'jung', 'lee' ]</span></span><br></pre></td></tr></table></figure><p>구조 분해 할당에서도 활용이 가능한데, 배열에서 구조 분해 할당은 index 값이 기준이 된다. 또한 나머지 매개변수와 마찬가지로 마지막 요소로 위치시키지 않으면 다음과 같은 에러가 발생한다.</p><ul><li><code>SyntaxError: Rest element must be last element</code></li></ul><blockquote><p>참조<br><a href="https://chanspark.github.io/2017/11/28/ES6-%EA%BF%80%ED%8C%81.html" target="_blank" rel="external nofollow noopener noreferrer">https://chanspark.github.io/2017/11/28/ES6-%EA%BF%80%ED%8C%81.html</a><br><a href="https://jongbeom-dev.tistory.com/117" target="_blank" rel="external nofollow noopener noreferrer">https://jongbeom-dev.tistory.com/117</a><br><a href="https://mber.tistory.com/14" target="_blank" rel="external nofollow noopener noreferrer">https://mber.tistory.com/14</a><br><a href="https://ko.javascript.info/rest-parameters-spread" target="_blank" rel="external nofollow noopener noreferrer">https://ko.javascript.info/rest-parameters-spread</a><br><a href="https://velog.io/@kwonh/ES6-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%BB%AC%EB%A0%89%EC%85%98-Array2-%EB%B0%B0%EC%97%B4-%ED%8E%BC%EC%B9%A8%EC%97%B0%EC%82%B0%EC%9E%90%EC%A0%84%EA%B0%9C%EC%97%B0%EC%82%B0%EC%9E%90-Spread-Syntax-Spread-Operator-1y6chdfg" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@kwonh/ES6-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%BB%AC%EB%A0%89%EC%85%98-Array2-%EB%B0%B0%EC%97%B4-%ED%8E%BC%EC%B9%A8%EC%97%B0%EC%82%B0%EC%9E%90%EC%A0%84%EA%B0%9C%EC%97%B0%EC%82%B0%EC%9E%90-Spread-Syntax-Spread-Operator-1y6chdfg</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spread-Syntax-전개-구문&quot;&gt;&lt;a href=&quot;#Spread-Syntax-전개-구문&quot; class=&quot;headerlink&quot; title=&quot;Spread Syntax (전개 구문)&quot;&gt;&lt;/a&gt;Spread Syntax (전개 구문)&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트(JavaScript) - async / await</title>
    <link href="https://kyu9341.github.io/JavaScript/2020/08/03/JavaScript_async_await/"/>
    <id>https://kyu9341.github.io/JavaScript/2020/08/03/JavaScript_async_await/</id>
    <published>2020-08-02T15:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><p>async, await은 프로미스를 좀 더 깔끔하게 작성할 수 있게 해준다.</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><ul><li>함수 앞에 <code>async</code> 라는 키워드를 붙여주면 자동으로 함수 내의 코드 블럭이 <code>promise</code>로 변경된다.</li><li>즉, resolve를 하지 않고 그냥 return 하더라도 <code>Promise</code> 객체를 리턴하게 된다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do network request in 10 sec...</span></span><br><span class="line">        resolve(<span class="string">'kwon'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위의 Promise를 async를 사용하여 변경하면 아래와 같다.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do network request in 10 sec...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'kwon'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = fetchUser();</span><br><span class="line">user.then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><ul><li><code>async</code> 키워드가 붙은 함수 내에서만 사용이 가능하다.</li><li>비동기 처리를 수행하는 코드 앞에 <code>await</code>을 붙여 사용하면 된다.</li><li>이 때, 비동기 처리 메소드가 꼭 프로미스 객체를 반환해야 <code>await</code>이 의도한 대로 동작한다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getApple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delay(<span class="number">2000</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'apple'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 위의 getApple을 await을 사용하면 ****아래와 같이 사용할 수 있다.</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getApple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'apple'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>이제 다음의 코드를 보자. promise를 사용하여 <code>getApple</code> 과 <code>getBanana</code> 를 모두 가져오는 함수이다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickFruits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getApple().then(<span class="function"><span class="params">apple</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBanana().then(<span class="function"><span class="params">banana</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;apple&#125;</span> + <span class="subst">$&#123;banana&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pickFruits().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 출력</span></span><br><span class="line"><span class="comment">// apple + banana</span></span><br></pre></td></tr></table></figure><ul><li>마치 콜백 헬과 비슷한 느낌이 든다.</li><li>위의 코드에 <code>async / await</code> 을 적용하여 보자.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pickFruits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> apple = <span class="keyword">await</span> getApple();</span><br><span class="line">    <span class="keyword">const</span> banana = <span class="keyword">await</span> getBanana();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;apple&#125;</span> + <span class="subst">$&#123;banana&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>훨씬 깔끔해진 것을 볼 수 있다.</li><li><code>async / await</code> 에서 에러처리는 <code>try / catch</code> 문을 사용하면 된다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예외 처리 추가</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pickFruits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> apple;</span><br><span class="line">    <span class="keyword">let</span> banana;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        apple = <span class="keyword">await</span> getApple();</span><br><span class="line">        banana = <span class="keyword">await</span> getBanana();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;apple&#125;</span> + <span class="subst">$&#123;banana&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>여기서 문제가 있다. <code>getApple</code> 에서 2초가 소요되고, <code>getBanana</code> 에서 2초가 소요된다.</li><li>즉, 총 4초가 소요되는 것이다. <code>getApple</code> 와 <code>getBanana</code> 와 같이 서로 연관되어 있지 않아 기다릴 필요가 없는 로직이 순차적으로 수행된다면 비효율적이다.</li><li>이 부분을 개선해보자.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pickFruits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> applePromise = getApple();</span><br><span class="line">    <span class="keyword">const</span> bananaPromise = getBanana();</span><br><span class="line">    <span class="keyword">const</span> apple = <span class="keyword">await</span> applePromise;</span><br><span class="line">    <span class="keyword">const</span> banana = <span class="keyword">await</span> bananaPromise;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;apple&#125;</span> + <span class="subst">$&#123;banana&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>위와 같이 각각의 함수에 대한 promise를 생성하면, promise는 생성되는 순간 내부의 코드 블럭이 실행되기 때문에 <code>getApple</code> 과 <code>getBanana</code> 에 해당하는 promise가 실행되게 된다.</li><li>이후에 <code>await</code> 을 통해 동기화 해주게 되면 2초 만에 병렬적으로 실행되는 것을 볼 수 있다.</li><li>하지만 코드가 지저분해지는 것이 느껴진다..</li><li>이럴 때에 유용한 Promise API 가 있는데, 바로 <code>Promise.all()</code> 이다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickAllFruits</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all([getApple(), getBanana()])</span><br><span class="line">    .then(<span class="function"><span class="params">fruits</span> =&gt;</span> fruits.join(<span class="string">' + '</span>));</span><br><span class="line">&#125;</span><br><span class="line">pickAllFruits().then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><ul><li><p><code>Promise.all()</code> 프로미스 배열을 전달하게 되면 모든 프로미스들이 병렬적으로 다 받을 때까지 모아준다.</p></li><li><p>참고로 <code>Promise.race()</code> 라는 API가 있는데, <code>Promise.race()</code> 는 프로미스 배열에서 가장 먼저 값을 리턴하는 프로미스만 전달해준다.</p></li></ul><blockquote><p>참조<br>&lt;<a href="https://joshua1988.github.io/web-development/javascript/js-async-await/" target="_blank" rel="external nofollow noopener noreferrer">https://joshua1988.github.io/web-development/javascript/js-async-await/</a>&gt;<br>&lt;<a href="https://www.youtube.com/watch?v=aoQSOZfz3vQ" target="_blank" rel="external nofollow noopener noreferrer">https://www.youtube.com/watch?v=aoQSOZfz3vQ</a>&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;async-amp-await&quot;&gt;&lt;a href=&quot;#async-amp-await&quot; class=&quot;headerlink&quot; title=&quot;async &amp;amp; await&quot;&gt;&lt;/a&gt;async &amp;amp; await&lt;/h2&gt;&lt;p&gt;async, await은 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트(JavaScript) - Promise</title>
    <link href="https://kyu9341.github.io/JavaScript/2020/08/02/JavaScript_promise/"/>
    <id>https://kyu9341.github.io/JavaScript/2020/08/02/JavaScript_promise/</id>
    <published>2020-08-01T15:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise는 비동기 처리를 위한 자바스크립트 객체이다.</p><p><strong>프로미스의 상태</strong></p><ul><li><strong>pending</strong> : 프로미스가 만들어져 지정한 연산이 수행중일 때</li><li><strong>fulfilled</strong> : 연산을 성공적으로 마치고 프로미스가 결과 값을 반환해준 상태</li><li><strong>rejected</strong> : 비동기 처리가 실패하거나 오류가 발생한 상태</li></ul><hr><ul><li><strong>Promise 생성</strong><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// doing some heavy work (network, read files)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doing someting...'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'kwon'</span>);</span><br><span class="line">        <span class="comment">// reject(new Error('no network'));</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>promise에는 executor 라는 콜백 함수를 전달해 주어야 하는데, 이 콜백함수에는 또 두 가지 콜백 함수를 인자로 받는다.</p><ul><li><strong>resolve</strong> : 기능을 정상적으로 수행하여 마지막에 최종 데이터를 전달하는 콜백함수</li><li><strong>reject</strong> : 기능을 수행하다가 중간에 문제가 생기면 호출하게 되는 콜백함수 (보통 Error라는 오브젝트를 통해 값을 전달한다)</li><li><strong>새로운 promise가 만들어지는 순간 executor 라는 콜백함수가 자동적으로 실행되게 된다.</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'finally'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 출력</span></span><br><span class="line"><span class="comment">// kwon</span></span><br><span class="line"><span class="comment">// finally</span></span><br></pre></td></tr></table></figure><ul><li><strong>then</strong> : promise가 정상적으로 수행이 된 경우 resolve로부터 값을 받아와서 실행한다.<ul><li>then은 또 다시 promise를 리턴한다.</li></ul></li><li><strong>catch</strong> : 에러가 발생했을 때 처리할 콜백 함수를 정의</li><li><strong>finally</strong> : promise의 성공, 실패 여부와 관계없이 언제나 실행된다.</li></ul><hr><ul><li><p><strong>promise chaining</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchNumber = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">1</span>), <span class="number">1000</span>); <span class="comment">// 1초 후 1을 전달</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fetchNumber</span><br><span class="line">.then(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>)</span><br><span class="line">.then(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">3</span>)</span><br><span class="line">.then(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(num - <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">console</span>.log(num));</span><br><span class="line"><span class="comment">// 출력</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li><li><p>then에서는 값을 바로 전달해도 되고, 또 다른 비동기인 promise를 전달해도 된다.</p></li></ul><hr><ul><li><p><strong>Error Handling</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getOne = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'one'</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getTwo = <span class="function"><span class="params">one</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">`<span class="subst">$&#123;one&#125;</span> =&gt; two`</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getThree = <span class="function"><span class="params">two</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">`<span class="subst">$&#123;two&#125;</span> =&gt; three`</span>), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>위와 같이 각각의 함수에서 프로미스를 리턴하도록 해보자.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">getOne()</span><br><span class="line">.then(<span class="function"><span class="params">one</span> =&gt;</span> getTwo(one))</span><br><span class="line">.then(<span class="function"><span class="params">two</span> =&gt;</span> getThree(two))</span><br><span class="line">.then(<span class="function"><span class="params">three</span> =&gt;</span> <span class="built_in">console</span>.log(three))</span><br><span class="line">.catch(<span class="function"><span class="params">three</span> =&gt;</span> <span class="built_in">console</span>.log(three));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래와 같이 변경 가능</span></span><br><span class="line"></span><br><span class="line">getOne()</span><br><span class="line">.then(getTwo)</span><br><span class="line">.then(getThree)</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 출력</span></span><br><span class="line"><span class="comment">// one =&gt; two =&gt; three</span></span><br></pre></td></tr></table></figure></li><li><p>프로미스 체이닝을 통해 문자열을 누적하여 <code>one =&gt; two =&gt; three</code> 의 결과를 출력하게 된다.</p></li><li><p>이 때, 중간에 <code>getTwo</code> 함수에서 에러가 발생한다고 가정해보자.</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getTwo = <span class="function"><span class="params">one</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;one&#125;</span> =&gt; two`</span>)), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>에러가 발생하면 가장 아래의 catch로 이동하여 에러를 잡게 되며 <code>Error: one =&gt; two</code> 와 같은 에러 메시지가 출력될 것이다.</li><li>여기서, 아래와 같이 <code>.then(one =&gt; getTwo(one))</code> 아래에 catch를 넣어서 ‘zero’를 리턴해보자.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getOne()</span><br><span class="line">.then(<span class="function"><span class="params">one</span> =&gt;</span> getTwo(one))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="string">'zero'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">two</span> =&gt;</span> getThree(two))</span><br><span class="line">.then(<span class="function"><span class="params">three</span> =&gt;</span> <span class="built_in">console</span>.log(three))</span><br><span class="line">.catch(<span class="function"><span class="params">three</span> =&gt;</span> <span class="built_in">console</span>.log(three));</span><br><span class="line"><span class="comment">// 출력 zero =&gt; three</span></span><br></pre></td></tr></table></figure><ul><li>전달된 에러를 받아 처리해 ‘zero’라는 문자열을 리턴하게 되면 다음 then에서 ‘zero’를 받아 이어서 처리를 할 수 있게 된다.</li><li>이렇게 중간에 처리를 해주게 되면 전체적인 프로미스 체인에 문제가 발생하지 않도록 할 수 있다.</li></ul><blockquote><p>참조<br><a href="https://www.youtube.com/watch?v=JB_yU6Oe2eE&amp;list=WL&amp;index=13&amp;t=75s" target="_blank" rel="external nofollow noopener noreferrer">https://www.youtube.com/watch?v=JB_yU6Oe2eE&amp;list=WL&amp;index=13&amp;t=75s</a><br><a href="https://joshua1988.github.io/web-development/javascript/promise-for-beginners/" target="_blank" rel="external nofollow noopener noreferrer">https://joshua1988.github.io/web-development/javascript/promise-for-beginners/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h2&gt;&lt;p&gt;Promise는 비동기 처리를 위한 자바스크립트 객체이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트(JavaScript) - for ...in 과 for ...of</title>
    <link href="https://kyu9341.github.io/JavaScript/2020/07/31/JavaScript_for_in_for_of/"/>
    <id>https://kyu9341.github.io/JavaScript/2020/07/31/JavaScript_for_in_for_of/</id>
    <published>2020-07-30T15:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="for-…-in-과-for-…-of"><a href="#for-…-in-과-for-…-of" class="headerlink" title="for … in 과 for … of"></a>for … in 과 for … of</h2><p>ES6 부터 추가된 문법이다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ...in</span><br><span class="line"><span class="keyword">for</span> ...of</span><br></pre></td></tr></table></figure><p>두 가지 모두 반복문으로 사용되는데 조금 차이가 있다.</p><h3 id="for-…in-객체-순환"><a href="#for-…in-객체-순환" class="headerlink" title="for …in - 객체 순환"></a>for …in - 객체 순환</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">kwon: <span class="number">1</span>,</span><br><span class="line">kim: <span class="number">2</span>,</span><br><span class="line">jo: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(item + <span class="string">': '</span> + obj[item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>출력</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kwon: <span class="number">1</span></span><br><span class="line">kim: <span class="number">2</span></span><br><span class="line">jo: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>for ...of</code> 를 사용한다면 다음과 같은 에러가 발생한다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypeError</span>: obj is not iterable</span><br></pre></td></tr></table></figure><p>이터러블하지 않다고 한다. 즉 반복가능한 객체가 아니기 때문에 에러가 발생한 것이다.</p><p>이 결과를 보면 <code>for ...of</code> 가 어떻게 사용되어야 하는지 유추할 수 있다.</p><h3 id="for-…of-배열-순환"><a href="#for-…of-배열-순환" class="headerlink" title="for …of - 배열 순환"></a>for …of - 배열 순환</h3><p><code>for ...of</code> 문은 반복가능한 객체를 통해 반복하는 루프를 만든다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>출력</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>위의 코드에서 <code>for ...in</code> 을 사용한다면 다음과 같은 결과가 나온다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>자바스크립트에서는 배열 또한 객체이기 때문에 해당 객체의 키값이 출력되게 된다.</p><p>배열로 생각하면 index라고 보면 될 것이다.</p><blockquote><p>참조<br><a href="https://velog.io/@eomttt/for-...in-for-...of-%EC%B0%A8%EC%9D%B4" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@eomttt/for-...in-for-...of-%EC%B0%A8%EC%9D%B4</a><br><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_%EB%AC%B8" target="_blank" rel="external nofollow noopener noreferrer">https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_%EB%AC%B8</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;for-…-in-과-for-…-of&quot;&gt;&lt;a href=&quot;#for-…-in-과-for-…-of&quot; class=&quot;headerlink&quot; title=&quot;for … in 과 for … of&quot;&gt;&lt;/a&gt;for … in 과 for … of&lt;/h2&gt;&lt;p&gt;ES
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://kyu9341.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>스프링 - 계층 구조</title>
    <link href="https://kyu9341.github.io/java/2020/07/08/java_springBoot_Layer/"/>
    <id>https://kyu9341.github.io/java/2020/07/08/java_springBoot_Layer/</id>
    <published>2020-07-07T15:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="스프링-계층-구조"><a href="#스프링-계층-구조" class="headerlink" title="스프링 계층 구조"></a>스프링 계층 구조</h2><ul><li>진행중인 프로젝트에서 계층 구조를 고려하여 각 계층의 역할을 제대로 분담하도록 하기 위해 스프링의 계층 구조에 대해 조사해 정리한다.</li><li><code>스프링 부트와 AWS로 혼자 구현하는 웹 서비스</code>라는 책의 계층 구조에 관한 내용을 참고하였다.</li></ul><h4 id="용어-정리"><a href="#용어-정리" class="headerlink" title="용어 정리"></a>용어 정리</h4><h5 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h5><ul><li>각 계층간 데이터 교환을 위한 자바 객체를 의미.</li><li>데이터를 각 레이어 간에 전달하는 목적을가지며 객체의 속성과 getter, setter만 가지고 있다. (VO : value Object 라고도 함)</li></ul><h5 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h5><ul><li>DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체</li></ul><hr><ul><li>View Layer와 DB Layer의 역할 분리를 철저하게 하는 것이 좋다.</li><li>실제로 Controller에서 결괏값으로 여러 테이블을 조인해서 줘야 할 경우가 빈번하므로 Entity 클래스 만으로 표현하기가 어려운 경우가 많다.</li><li>Entity 클래스와 Controller에서 쓸 DTO는 분리해서 사용해야 한다.</li></ul><h3 id="스프링-웹-계층"><a href="#스프링-웹-계층" class="headerlink" title="스프링 웹 계층"></a>스프링 웹 계층</h3><ul><li>스프링 부트와 AWS로 혼자 구현하는 웹 서비스 참조<img src="https://kyu9341.github.io/img/springLayer.png" alt="vs_write" width height></li></ul><h3 id="Web-Layer"><a href="#Web-Layer" class="headerlink" title="Web Layer"></a>Web Layer</h3><ul><li>흔히 사용하는 컨트롤러와 뷰 템플릿 영역이다.</li><li>이외에도 필터, 인터셉터, 컨트롤러 어드바이스 등 <strong>외부 요청과 응답</strong> 에 대한 전반적인 영역을 의미한다.</li></ul><h3 id="Service-Layer"><a href="#Service-Layer" class="headerlink" title="Service Layer"></a>Service Layer</h3><ul><li><code>@Service</code> 에 사용되는 서비스 영역이다.</li><li>일반적으로 Controller와 Dao의 중간 영역에서 사용된다.</li><li><code>@Transactional</code> 이 사용되어야 하는 영역이기도 하다.</li><li>서비스에서는 트랜잭션과 도메인 간의 순서만 보장한다.</li></ul><h3 id="Repository-Layer"><a href="#Repository-Layer" class="headerlink" title="Repository Layer"></a>Repository Layer</h3><ul><li><strong>Database</strong> 와 같이 데이터 저장소에 접근하는 영역이다.</li><li>Dao(Data Access Object) 영역이라고 생각하면 된다.</li></ul><h3 id="DTOs"><a href="#DTOs" class="headerlink" title="DTOs"></a>DTOs</h3><ul><li>DTO(Data Transfer Object)는 <strong>계층 간에 데이터 교환을 위한 객체</strong> 를 의미, DTOs는 이들의 영역을 의미한다.</li><li>예를 들어, 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 결과로 넘겨준 객체 등이 이들을 말한다.</li></ul><h3 id="Domain-Model"><a href="#Domain-Model" class="headerlink" title="Domain Model"></a>Domain Model</h3><ul><li>도메인이라 불리는 개발 대상을 모든 사람들이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화시킨 것을 도메인 모델이라 한다.</li><li>비즈니스 로직을 처리하는 영역이다.</li><li>이를테면 택시 앱이라 하면 배차, 탑승, 요금 등이 모두 도메인이 될 수 있다.</li><li><code>@Entity</code> 가 사용된 영역 역시 도메인 모델이라고 이해하면 된다.</li><li>다만, 무조건 데이터베이스의 테이블과 관계가 있어야 하는 것은 아니다.</li><li>VO처럼 값 객체들도 이 영역에 해당한다.</li></ul><hr><h3 id="왜-비즈니스-로직을-도메인-계층에-작성하는가"><a href="#왜-비즈니스-로직을-도메인-계층에-작성하는가" class="headerlink" title="왜 비즈니스 로직을 도메인 계층에 작성하는가"></a>왜 비즈니스 로직을 도메인 계층에 작성하는가</h3><ul><li>Service Layer는 다양한 Model(Domain)을 읽어 제공한다. 복잡한 서비스는 더 많은 Model을 읽어 서비스를 제공하기 때문에 Service 로직의 복잡도가 매우 높아진다.</li><li>이런 로직의 복잡도를 낮추기 위해 최대한 비즈니스 로직을 Model(Domain)쪽으로 이동시킨다.</li><li>복잡도를 낮춤으로써 유지보수와 테스트하기 쉬운 코드가 생기고 결국엔 유연한 Software를 얻을 수 있다.</li></ul><hr><h3 id="Service-Layer-작성-시-주의사항"><a href="#Service-Layer-작성-시-주의사항" class="headerlink" title="Service Layer 작성 시 주의사항"></a>Service Layer 작성 시 주의사항</h3><ul><li>Service는 다른 Service를 조합하거나 DAO를 연결하는 역할을 수행.</li><li>Service는 가볍게, Service에 핵심 비즈니스 로직을 구현하기 보다는 로직의 상태값을 가지고 있는 모델이 담당해야 한다.</li><li>Service에서 Service를 참조 가능하나 계층 구조가 명확해야한다.<ul><li>(순환참조를 방지하기 위해서)</li></ul></li></ul><blockquote><p>참조<br>스프링 부트와 AWS로 혼자 구현하는 웹 서비스<br>&lt;<a href="https://nesoy.github.io/articles/2018-04/why-close-to-domain" target="_blank" rel="external nofollow noopener noreferrer">https://nesoy.github.io/articles/2018-04/why-close-to-domain</a>&gt;<br>&lt;<a href="https://happyer16.tistory.com/entry/Spring-layered-architecture%EC%99%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0" target="_blank" rel="external nofollow noopener noreferrer">https://happyer16.tistory.com/entry/Spring-layered-architecture와-객체지향적으로-개발하기</a>&gt;<br>&lt;<a href="https://umbum.tistory.com/1066" target="_blank" rel="external nofollow noopener noreferrer">https://umbum.tistory.com/1066</a>&gt;<br>&lt;<a href="https://velog.io/@sumusb/Spring-Service-Layer%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0" target="_blank" rel="external nofollow noopener noreferrer">https://velog.io/@sumusb/Spring-Service-Layer에-대한-고찰</a>&gt;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;스프링-계층-구조&quot;&gt;&lt;a href=&quot;#스프링-계층-구조&quot; class=&quot;headerlink&quot; title=&quot;스프링 계층 구조&quot;&gt;&lt;/a&gt;스프링 계층 구조&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;진행중인 프로젝트에서 계층 구조를 고려하여 각 계층의 역할을 제대
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
      <category term="Spring" scheme="https://kyu9341.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>백준 2812번 크게 만들기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/07/07/algorithm2812/"/>
    <id>https://kyu9341.github.io/algorithm/2020/07/07/algorithm2812/</id>
    <published>2020-07-07T10:51:12.000Z</published>
    <updated>2020-08-28T02:14:04.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2812"><a href="#Problem-2812" class="headerlink" title="Problem 2812"></a>Problem 2812</h1><h2 id="크게-만들기"><a href="#크게-만들기" class="headerlink" title="크게 만들기"></a>크게 만들기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N자리 숫자가 주어졌을 때, 여기서 숫자 K개를 지워서 얻을 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (1 ≤ K &lt; N ≤ 500,000)</p><p>둘째 줄에 N자리 숫자가 주어진다. 이 수는 0으로 시작하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>입력으로 주어진 숫자에서 K개를 지웠을 때 얻을 수 있는 가장 큰 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2812" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2812</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2<br>1924</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>94</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>프로그래머스에도 같은 문제가 있지만 시간 제한이 좀 널널했다.</li><li>하지만 같은 방식으로는 시간초과가 나기 때문에 deque를 이용하여 해결하였다. (스택을 사용해도 충분하지만 출력을 편하게 하기 위해)</li><li>덱이 비어있다면 원소를 넣고, 비어있지 않다면 덱의 가장 뒤의 원소와 현재 숫자를 비교한다.</li><li>현재 숫자가 더 작다면 그냥 맨 뒤에 원소를 추가하고, 현재 숫자가 더 크다면 덱의 맨 뒤의 원소를 계속해서 pop해준다. (cnt가 k보다 작을 때에 한에서)</li><li>전체를 모두 확인하고도 cnt가 k보다 작다면 그 차이 만큼 덱의 뒤에서 지워준다.</li><li>덱의 맨 앞에서부터 빼면서 ans에 누적하여 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">string</span> number;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; number;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> now = number[i] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span> (dq.empty()) &#123;</span><br><span class="line">dq.push_back(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 비어있지 않은 경우 덱의 가장 뒤의 원소가 현재 원소보다 작다면 pop한다.</span></span><br><span class="line"><span class="keyword">while</span> (!dq.empty() &amp;&amp; dq.back() &lt; now &amp;&amp; cnt &lt; k) &#123;</span><br><span class="line">dq.pop_back();</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">dq.push_back(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 아직 지우지 못한 만큼 뒤에서 지워준다.</span></span><br><span class="line"><span class="keyword">while</span> (cnt != k) &#123;</span><br><span class="line">dq.pop_back();</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 앞에서부터 빼면서 ans에 누적</span></span><br><span class="line"><span class="keyword">while</span> (!dq.empty()) &#123;</span><br><span class="line">ans += dq.front() + <span class="string">'0'</span>;</span><br><span class="line">dq.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2812&quot;&gt;&lt;a href=&quot;#Problem-2812&quot; class=&quot;headerlink&quot; title=&quot;Problem 2812&quot;&gt;&lt;/a&gt;Problem 2812&lt;/h1&gt;&lt;h2 id=&quot;크게-만들기&quot;&gt;&lt;a href=&quot;#크게-만들기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://kyu9341.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>백준 1062번 가르침</title>
    <link href="https://kyu9341.github.io/algorithm/2020/07/07/algorithm1062/"/>
    <id>https://kyu9341.github.io/algorithm/2020/07/07/algorithm1062/</id>
    <published>2020-07-07T06:51:12.000Z</published>
    <updated>2020-08-28T02:14:04.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1062"><a href="#Problem-1062" class="headerlink" title="Problem 1062"></a>Problem 1062</h1><h2 id="가르침"><a href="#가르침" class="headerlink" title="가르침"></a>가르침</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.</p><p>남극언어의 모든 단어는 “anta”로 시작되고, “tica”로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 모든 단어는 중복되지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1062" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1062</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 6<br>antarctica<br>antahellotica<br>antacartica</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>기본적으로 [‘a’, ‘n’, ‘t’, ‘i’, ‘c’] 의 5개의 문자를 알지 못하면 읽을 수 있는 단어의 개수는 0이된다.</li><li>각각의 단어에 위의 5가지 문자를 제외한 문자만 set의 벡터를 만들어 각각의 set에 추가한다.</li><li>k가 5 이상인 경우 5개 문자 외의 k - 5 개의 문자의 조합을 구하여 해당 조합의 문자로 읽을 수 있는 단어의 최댓값을 구하면 된다.</li><li>이 때, 기본 5개의 문자 외에 다른 문자가 없이 중복된 문자로 추가되는 경우를 체크하기 위해 벡터의 현재 set이 비어있는 경우에도 갯수를 증가시킨다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> start)</span> </span>&#123;</span><br><span class="line"><span class="comment">// k - 5 개를 뽑아서 해당 문자로 몇 개를 만들 수 있는지 확인</span></span><br><span class="line"><span class="keyword">if</span> (index == k - <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v[i].<span class="built_in">begin</span>(); it != v[i].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">find</span>(*it) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 포함되지 않은 다른 문자가 없는 경우</span></span><br><span class="line"><span class="keyword">if</span> (ok || v[i].empty()) cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; cnt) ans = cnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> i = start; i &lt;= <span class="string">'z'</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">find</span>(i) != s.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">s.insert(i);</span><br><span class="line">dfs(index + <span class="number">1</span>, i);</span><br><span class="line">s.erase(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 5개의 문자를 먼저 입력</span></span><br><span class="line">s.insert(<span class="string">'a'</span>);</span><br><span class="line">s.insert(<span class="string">'n'</span>);</span><br><span class="line">s.insert(<span class="string">'t'</span>);</span><br><span class="line">s.insert(<span class="string">'i'</span>);</span><br><span class="line">s.insert(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">v.resize(n);</span><br><span class="line"><span class="comment">// 각각 단어의 기본 5개의 문자를 외의 문자만 각각의 set에 추가</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> input;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">4</span>; j &lt; input.<span class="built_in">size</span>() - <span class="number">4</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">find</span>(input[j]) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">v[i].insert(input[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5개 미만의 수를 가르치면 읽을 수 있는 단어가 없음</span></span><br><span class="line"><span class="keyword">if</span>(k &gt;= <span class="number">5</span>) dfs(<span class="number">0</span>, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1062&quot;&gt;&lt;a href=&quot;#Problem-1062&quot; class=&quot;headerlink&quot; title=&quot;Problem 1062&quot;&gt;&lt;/a&gt;Problem 1062&lt;/h1&gt;&lt;h2 id=&quot;가르침&quot;&gt;&lt;a href=&quot;#가르침&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://kyu9341.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>백준 3055번 탈출</title>
    <link href="https://kyu9341.github.io/algorithm/2020/07/03/algorithm3055/"/>
    <id>https://kyu9341.github.io/algorithm/2020/07/03/algorithm3055/</id>
    <published>2020-07-03T06:21:12.000Z</published>
    <updated>2020-08-28T02:14:04.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-3055"><a href="#Problem-3055" class="headerlink" title="Problem 3055"></a>Problem 3055</h1><h2 id="탈출"><a href="#탈출" class="headerlink" title="탈출"></a>탈출</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>사악한 암흑의 군주 이민혁은 드디어 마법 구슬을 손에 넣었고, 그 능력을 실험해보기 위해 근처의 티떱숲에 홍수를 일으키려고 한다. 이 숲에는 고슴도치가 한 마리 살고 있다. 고슴도치는 제일 친한 친구인 비버의 굴로 가능한 빨리 도망가 홍수를 피하려고 한다.</p><p>티떱숲의 지도는 R행 C열로 이루어져 있다. 비어있는 곳은 ‘.’로 표시되어 있고, 물이 차있는 지역은 ‘*‘, 돌은 ‘X’로 표시되어 있다. 비버의 굴은 ‘D’로, 고슴도치의 위치는 ‘S’로 나타내어져 있다.</p><p>매 분마다 고슴도치는 현재 있는 칸과 인접한 네 칸 중 하나로 이동할 수 있다. (위, 아래, 오른쪽, 왼쪽) 물도 매 분마다 비어있는 칸으로 확장한다. 물이 있는 칸과 인접해있는 비어있는 칸(적어도 한 변을 공유)은 물이 차게 된다. 물과 고슴도치는 돌을 통과할 수 없다. 또, 고슴도치는 물로 차있는 구역으로 이동할 수 없고, 물도 비버의 소굴로 이동할 수 없다.</p><p>티떱숲의 지도가 주어졌을 때, 고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하는 프로그램을 작성하시오.</p><p>고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다. 즉, 다음 시간에 물이 찰 예정인 칸으로 고슴도치는 이동할 수 없다. 이동할 수 있으면 고슴도치가 물에 빠지기 때문이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 50보다 작거나 같은 자연수 R과 C가 주어진다.</p><p>다음 R개 줄에는 티떱숲의 지도가 주어지며, 문제에서 설명한 문자만 주어진다. ‘D’와 ‘S’는 하나씩만 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 고슴도치가 비버의 굴로 이동할 수 있는 가장 빠른 시간을 출력한다. 만약, 안전하게 비버의 굴로 이동할 수 없다면, “KAKTUS”를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/3055" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/3055</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>D.*<br>…<br>.S.</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>먼저, 각 위치에 물이 도달하는데 걸리는 시간을 waterFlow()함수에서 water에 기록한다.(BFS)</li><li>고슴도치의 시작 위치에서 bfs를 시작하여 비버의 굴 까지 도착하는데 걸리는 시간을 구한다.<ul><li>이 때, 물이 찰 예정인 지역으로 이동할 수 없기 때문에 water에 기록된 시간보다 작은 경우만 고슴도치가 이동할 수 있는 조건을 추가한다.</li><li>물이 이동 가능한 지역은 시간을 기록하고 나머지 지역에는 -1이 존재한다.</li></ul></li><li>비버의 굴에 도착했을 때의 시간을 기록한 후 종료한다.<ul><li>bfs가 종료된 이후 비버의 굴에 방문하지 못했다면 “KAKTUS” , 방문했다면 시간 출력</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">50</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="keyword">char</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> check[MAX][MAX];</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; wq; <span class="comment">// 물의 이동을 담을 큐</span></span><br><span class="line"><span class="keyword">int</span> water[MAX][MAX]; <span class="comment">// 물의 이동 시간</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">location</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">int</span> time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waterFlow</span><span class="params">()</span> </span>&#123; <span class="comment">// 물의 이동을 기록하는 함수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!wq.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = wq.front().first;</span><br><span class="line"><span class="keyword">int</span> y = wq.front().second;</span><br><span class="line">wq.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; r &amp;&amp; ny &lt; c) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="string">'.'</span> &amp;&amp; water[nx][ny] == <span class="number">-1</span>) &#123;</span><br><span class="line">water[nx][ny] = water[x][y] + <span class="number">1</span>;</span><br><span class="line">wq.push(make_pair(nx, ny));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">location start;</span><br><span class="line"><span class="built_in">memset</span>(water, <span class="number">-1</span>, <span class="keyword">sizeof</span>(water));</span><br><span class="line"><span class="keyword">int</span> ex, ey;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="string">'S'</span>) &#123; <span class="comment">// 처음 고슴도치의 위치</span></span><br><span class="line">start.x = i;</span><br><span class="line">start.y = j;</span><br><span class="line">start.time = <span class="number">0</span>;</span><br><span class="line">check[i][j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="string">'*'</span>) &#123; <span class="comment">// 물의 시작 위치</span></span><br><span class="line">wq.push(make_pair(i, j));</span><br><span class="line">water[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="string">'D'</span>) &#123; <span class="comment">// 목적지 위치</span></span><br><span class="line">ex = i;</span><br><span class="line">ey = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">waterFlow();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;location&gt; q;</span><br><span class="line">q.push(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front().x;</span><br><span class="line"><span class="keyword">int</span> y = q.front().y;</span><br><span class="line"><span class="keyword">int</span> time = q.front().time;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="string">'D'</span>) &#123; <span class="comment">// 비버의 굴에 도착했을 때</span></span><br><span class="line">ans = time; <span class="comment">// 시간 기록 후 종료</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">int</span> nt = time + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; r &amp;&amp; ny &lt; c) &#123;</span><br><span class="line"><span class="comment">// 방문하지 않았고, 빈 지역 또는 비버의 굴이며, 물이 다음에도 차오르지 않는 지역인 경우</span></span><br><span class="line"><span class="keyword">if</span> (!check[nx][ny] &amp;&amp; (a[nx][ny] == <span class="string">'.'</span> || a[nx][ny] == <span class="string">'D'</span>) &amp;&amp; (nt &lt; water[nx][ny] || water[nx][ny] == <span class="number">-1</span>)) &#123;</span><br><span class="line">q.push(location&#123; nx, ny, nt &#125;);</span><br><span class="line">check[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!check[ex][ey]) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"KAKTUS"</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-3055&quot;&gt;&lt;a href=&quot;#Problem-3055&quot; class=&quot;headerlink&quot; title=&quot;Problem 3055&quot;&gt;&lt;/a&gt;Problem 3055&lt;/h1&gt;&lt;h2 id=&quot;탈출&quot;&gt;&lt;a href=&quot;#탈출&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://kyu9341.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 - HandlerInterceptor</title>
    <link href="https://kyu9341.github.io/java/2020/06/19/java_springBootInceptor/"/>
    <id>https://kyu9341.github.io/java/2020/06/19/java_springBootInceptor/</id>
    <published>2020-06-19T06:12:28.000Z</published>
    <updated>2020-08-28T02:14:04.095Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스프링-부트-HandlerInterceptor"><a href="#스프링-부트-HandlerInterceptor" class="headerlink" title="스프링 부트 - HandlerInterceptor"></a>스프링 부트 - HandlerInterceptor</h3><ul><li><p>Interceptor는 말 그대로 가로채는 것을 의미한다. 예를 들어, 세션 검증이나 로그 처리 같은 기능을 수행하기 위해 특정 url에 요청이 들어오면 그 요청을 가로채 특정한 작업을 수행하는 기능이다.</p></li><li><p>현재 진행중인 프로젝트에 알림 기능이 있는데, 알림이 존재하는 경우에 알림이 있다는 표시를 해주기 위해 view에 <code>hasNotification</code>이라는 모델을 넘겨주고자 한다. 이 작업을 모든 요청에 적용하기 위해서 Interceptor를 적용할 것이다.</p></li><li><p>Interceptor는 <code>HandlerInterceptor</code>인터페이스를 구현하여 만들 수 있다.</p></li><li><p><code>HandlerInterceptor</code>의 메서드는 아래의 세 가지가 있다.</p><ul><li><strong>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</strong><ul><li><code>Controller</code>실행 직전에 동작을 하며, 반환 값에 따라 진행 여부를 결정한다.</li></ul></li><li><strong>void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</strong><ul><li><code>Conroller</code>진입 후 view가 렌더링 되기 전에 수행을 한다.</li><li><code>modelAndView</code>를 사용하여 <code>model</code>에 데이터를 추가하는 조작이 가능하다.</li></ul></li><li><strong>void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</strong><ul><li><code>Conroller</code>진입 후 view가 렌더링 된 이후에 마지막으로 실행이 되는 메서드이다.</li></ul></li></ul></li><li><p>나는 핸들러 처리 이후 뷰가 렌더링 되기 전에 알림 여부를 가지는 모델을 추가해주기 위해 <code>postHandle</code>메서드를 구현하였다.</p></li><li><p><code>NotificationInterceptor.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NotificationRepository notificationRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 뷰 렌더링 전, 핸들러 처리 이후</span></span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span> &amp;&amp; !isRedirectView(modelAndView) &amp;&amp; authentication != <span class="keyword">null</span> &amp;&amp; authentication.getPrincipal() <span class="keyword">instanceof</span> UserAccount) &#123;</span><br><span class="line">            Account account = ((UserAccount)authentication.getPrincipal()).getAccount();</span><br><span class="line">            <span class="keyword">long</span> count = notificationRepository.countByAccount(account);</span><br><span class="line">            modelAndView.addObject(<span class="string">"hasNotification"</span>, count &gt; <span class="number">0</span>); <span class="comment">// 알람이 있는 경우 true, 없으면 false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRedirectView</span><span class="params">(ModelAndView modelAndView)</span> </span>&#123; <span class="comment">// 리다이렉트 요청인지 확인하는 메서드</span></span><br><span class="line">      <span class="comment">// 뷰의 이름이 redirect: 로 시작하거나, RedirectView 타입인 경우</span></span><br><span class="line">        <span class="keyword">return</span> modelAndView.getViewName().startsWith(<span class="string">"redirect:"</span>) || modelAndView.getView() <span class="keyword">instanceof</span> RedirectView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>로그인된 사용자에게 적용하고 리다이렉트 요청에는 적용하지 않기 위해</p></li><li><p>인증 객체를 가져와 <code>modelAndView</code> 를 사용하고, <code>RedirectView</code> 가 아닌 경우, 인증 정보가 있고 <code>principal</code> 이 <code>UserAccount</code> 타입일 때 적용한다.</p></li><li><p><code>principal</code> 안에 들어있는 객체를 <code>UserAccount</code> 로 형변환하여 <code>account</code> 객체를 가져와 해당 사용자의 알림 개수를 구한다.</p></li><li><p>알림이 있는 경우 true, 없는 경우 false를 모델에 넣어준다.</p></li></ul><h4 id="HandlerInterceptor-적용하기"><a href="#HandlerInterceptor-적용하기" class="headerlink" title="HandlerInterceptor 적용하기"></a>HandlerInterceptor 적용하기</h4><ul><li><p>이제 작성한 <code>HandlerInterceptor</code>를 실제로 적용하기 위한 설정을 해주어야 한다.</p></li><li><p><code>WebMvcConfigurer</code>를 구현한 클래스를 작성하여 <code>addInterceptors</code>메서드에 해당 인터셉터를 등록하면 된다.</p></li><li><p><code>WebConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@EnableWebMvc : 이 설정을 주면 스프링 부트가 제공하는 웹mvc 자동설정을 사용하지 않는다는 뜻.</span></span><br><span class="line"><span class="comment">// 지금은 추가설정만 하는 것</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NotificationInterceptor notificationInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(notificationInterceptor)</span><br><span class="line">                .excludePathPatterns(<span class="string">'url패턴 추가'</span>); <span class="comment">// 인터셉터를 적용하지 않을 url 패턴</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>excludePathPatterns()</code>에 추가한 url패턴에는 인터셉터를 적용하지 않도록 설정할 수 있다.</p><ul><li>예를들어, <code>/css/**</code>, <code>/js/**</code>등과 같은 <code>static</code> 리소스들에 적용하고 싶지 않은 경우에 추가할 수 있다.</li><li>String 배열이나 리스트 타입으로 넣어줄 수 있다.</li></ul></li></ul><blockquote><p>참조<br><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-JPA-%EC%9B%B9%EC%95%B1/dashboard" target="_blank" rel="external nofollow noopener noreferrer">https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-JPA-%EC%9B%B9%EC%95%B1/dashboard</a><br><a href="https://elfinlas.github.io/2017/12/28/SpringBootInterceptor/" target="_blank" rel="external nofollow noopener noreferrer">https://elfinlas.github.io/2017/12/28/SpringBootInterceptor/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스프링-부트-HandlerInterceptor&quot;&gt;&lt;a href=&quot;#스프링-부트-HandlerInterceptor&quot; class=&quot;headerlink&quot; title=&quot;스프링 부트 - HandlerInterceptor&quot;&gt;&lt;/a&gt;스프링 부트 - 
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
      <category term="Spring" scheme="https://kyu9341.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>

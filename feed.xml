<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-03-03T10:04:49.226Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 1939번 중량제한</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm1939/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm1939/</id>
    <published>2020-03-03T09:51:12.000Z</published>
    <updated>2020-03-03T10:04:49.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1939"><a href="#Problem-1939" class="headerlink" title="Problem 1939"></a>Problem 1939</h1><h2 id="중량제한"><a href="#중량제한" class="headerlink" title="중량제한"></a>중량제한</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N(2≤N≤10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.</p><p>영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.</p><p>한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N, M(1≤M≤100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1≤A, B≤N), C(1≤C≤1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 도시 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 답을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1939" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1939</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 2 2<br>3 1 3<br>2 3 2<br>1 3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>제한되는 중량에 대해 이분 탐색을 수행하며 현재 중량을 만족하는 길이 있는지 확인한다.</li><li>dfs를 통해 만족하는 길이 있는지 탐색하여 만족하는 길이 있다면 중량을 증가시키고 없다면 감소시켜 재탐색한다.</li></ul><h2 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// 방문 여부</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> weight, <span class="keyword">int</span> target)</span> <span class="comment">// dfs를 통해 현재 중량 제한을 만족하는 길이 있는지 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line"><span class="keyword">if</span> (check[target]) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 목표 지점을 찾은 경우</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++) <span class="comment">// 연결된 섬 모두 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i].first;</span><br><span class="line"><span class="keyword">int</span> w = a[node][i].second;</span><br><span class="line"><span class="keyword">if</span> (!check[next] &amp;&amp; w &gt;= weight) <span class="comment">// 중량 제한을 만족하고 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(next, weight, target)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 목표 공장을 찾았다면 true리턴</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 모두 방문했지만 목표 공장을 찾지 못한 경우 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxWeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 섬과 다리 입력</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">a[u].push_back(make_pair(v, w));</span><br><span class="line">a[v].push_back(make_pair(u, w));</span><br><span class="line"><span class="keyword">if</span> (maxWeight &lt; w) <span class="comment">// 중량 제한의 최댓값 저장</span></span><br><span class="line">maxWeight = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start, <span class="built_in">end</span>; <span class="comment">// 출발 공장, 도착 공장</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start &gt;&gt; <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = maxWeight;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 이분 탐색</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check)); <span class="comment">// check배열 초기화</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 중량 제한</span></span><br><span class="line"><span class="keyword">if</span> (dfs(start, mid, <span class="built_in">end</span>)) <span class="comment">// 현재 중량 제한을 만족하는 길이 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; mid)</span><br><span class="line">ans = mid;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1939&quot;&gt;&lt;a href=&quot;#Problem-1939&quot; class=&quot;headerlink&quot; title=&quot;Problem 1939&quot;&gt;&lt;/a&gt;Problem 1939&lt;/h1&gt;&lt;h2 id=&quot;중량제한&quot;&gt;&lt;a href=&quot;#중량제한&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2805번 나무 자르기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm2805/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm2805/</id>
    <published>2020-03-03T08:51:12.000Z</published>
    <updated>2020-03-03T09:55:35.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2805"><a href="#Problem-2805" class="headerlink" title="Problem 2805"></a>Problem 2805</h1><h2 id="나무-자르기"><a href="#나무-자르기" class="headerlink" title="나무 자르기"></a>나무 자르기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기을 이용해서 나무를 구할것이다.</p><p>목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다)</p><p>상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)</p><p>둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M을 넘기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2805" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2805</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 7<br>20 15 10 17</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>15</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>절단기의 높이 h로 나무를 잘라서 m이상을 만들 수 있는지 확인하는 함수를 만들고</li><li>이분 탐색을 통해 현재 절단기의 높이로 나무의 길이 m을 만들 수 있는지 확인한다.<ul><li>가능하다면 현재 절단기 높이 저장하고 최댓값을 구해야하므로 더 높이 올릴 수 있는지 확인</li><li>불가능하다면 절단기의 높이를 낮춘다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; a, <span class="keyword">long</span> <span class="keyword">long</span> m, <span class="keyword">long</span> <span class="keyword">long</span> h)</span> <span class="comment">// 절단기의 높이 h로 나무를 잘라서 m이상을 만들 수 있는지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] - h &gt; <span class="number">0</span>) <span class="comment">// h 가 나무의 높이보다 높으면 잘리지 않음</span></span><br><span class="line">&#123;</span><br><span class="line">cnt += a[i] - h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= m; <span class="comment">// 자른 나무의 길이의 합이 m이상이면 참</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a(n);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (maxlen &lt; a[i])maxlen = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> right = maxlen; <span class="comment">// 나무 길이의 최댓값</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(a, m, mid)) <span class="comment">// 현재 높이로 나무의 길이 m을 만들 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; mid)</span><br><span class="line">ans = mid; <span class="comment">// 가능하다면 현재 절단기 높이 저장</span></span><br><span class="line">left = mid + <span class="number">1</span>; <span class="comment">// 최댓값을 구해야하므로 더 높이 올릴 수 있는지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>; <span class="comment">// 불가능하다면 절단기 높이를 낮춤</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2805&quot;&gt;&lt;a href=&quot;#Problem-2805&quot; class=&quot;headerlink&quot; title=&quot;Problem 2805&quot;&gt;&lt;/a&gt;Problem 2805&lt;/h1&gt;&lt;h2 id=&quot;나무-자르기&quot;&gt;&lt;a href=&quot;#나무-자르기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2110번 공유기 설치</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm2110/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm2110/</id>
    <published>2020-03-03T02:51:12.000Z</published>
    <updated>2020-03-03T09:49:56.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2110"><a href="#Problem-2110" class="headerlink" title="Problem 2110"></a>Problem 2110</h1><h2 id="공유기-설치"><a href="#공유기-설치" class="headerlink" title="공유기 설치"></a>공유기 설치</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.</p><p>도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.</p><p>C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (1 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2110" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2110</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 3<br>1<br>2<br>8<br>4<br>9</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>이분 탐색을 이용하여 인접한 두 공유기 사이의 거리를 탐색한다.</li><li>집의 좌표를 저장한 벡터에서 인접한 공유기 사이의 거리가 현재 간격(dist)이상인 경우가 c이상인지 판별한다.<ul><li>참이라면 현재 지정된 고유기의 간격을 ans에 저장하고 더 큰 값이 있는지 반복한다.</li><li>아니라면 간격을 줄여 다시 탐색한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> c, <span class="keyword">int</span> dist)</span> <span class="comment">// 인접한 공유기 사이의 거리가 현재 간격(dist)이상인 경우가 c이상인지 판별하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 가능한 간격 + 1개가 공유기의 개수</span></span><br><span class="line"><span class="keyword">int</span> last = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> house : a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (house - last &gt;= dist) <span class="comment">// 직전에 공유기를 배치했던 집과 거리 비교</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">last = house; <span class="comment">// 공유기를 배치한 이전 집을 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= c; <span class="comment">// 현재 인접한 공유기 사이의 거리가 dist이상인 경우가 c개 이상이면 참</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 오른차순 정렬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> right = a[n - <span class="number">1</span>] - a[<span class="number">0</span>]; <span class="comment">// 가장 멀리 떨어진 두 집의 차이</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 인접한 두 공유기의 거리</span></span><br><span class="line"><span class="keyword">if</span> (check(a, c, mid))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; mid)</span><br><span class="line">ans = mid;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2110&quot;&gt;&lt;a href=&quot;#Problem-2110&quot; class=&quot;headerlink&quot; title=&quot;Problem 2110&quot;&gt;&lt;/a&gt;Problem 2110&lt;/h1&gt;&lt;h2 id=&quot;공유기-설치&quot;&gt;&lt;a href=&quot;#공유기-설치&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1654번 랜선 자르기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm1654/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm1654/</id>
    <published>2020-03-03T01:51:12.000Z</published>
    <updated>2020-03-03T09:55:05.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1654"><a href="#Problem-1654" class="headerlink" title="Problem 1654"></a>Problem 1654</h1><h2 id="랜선-자르기"><a href="#랜선-자르기" class="headerlink" title="랜선 자르기"></a>랜선 자르기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.</p><p>이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm 은 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)</p><p>편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1654" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1654</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 11<br>802<br>743<br>457<br>539</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>200</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>길이 l인 랜선을 n개 만들 수 있는지 확인하는 함수를 만든다.</li><li>left = 1, right는 가지고 있는 랜선 길이의 최댓값으로 정한다.</li><li>이분 탐색을 수행하며 현재 길이로 n개의 랜선을 만들 수 있는지 확인 후,<ul><li>가능다면 현재 길이를 ans에 저장하고 더 큰 길이로 만들 수 있는지 확인하기 위해 left를 이동한다.<ul><li>가능하지 않다면 right를 mid - 1로 이동해 길이를 줄여서 확인한다.</li></ul></li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n, <span class="keyword">int</span> l)</span> <span class="comment">// 길이 l인 랜선을 n개 만들 수 있는지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt += a[i] / l; <span class="comment">// 가지고 있는 랜선을 길이 l로 자르면 몇 개를 만들 수 있는지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= n; <span class="comment">// 만들 수 있는 랜선의 개수가 n이상이면 참</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (right &lt; a[i])</span><br><span class="line">right = a[i]; <span class="comment">// 랜선 길이의 최댓값</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(a, n, mid)) <span class="comment">// 현재 길이로 n개의 랜선을 만들 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">ans = mid; <span class="comment">// 현재 길이를 저장하고</span></span><br><span class="line">left = mid + <span class="number">1</span>; <span class="comment">// 더 큰 길이로 만들 수 있는지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 현재 길이로 n개를 만들 수 없다면 길이를 줄여서 확인</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1654&quot;&gt;&lt;a href=&quot;#Problem-1654&quot; class=&quot;headerlink&quot; title=&quot;Problem 1654&quot;&gt;&lt;/a&gt;Problem 1654&lt;/h1&gt;&lt;h2 id=&quot;랜선-자르기&quot;&gt;&lt;a href=&quot;#랜선-자르기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1790번 수 이어 쓰기 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm1790/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm1790/</id>
    <published>2020-03-03T00:51:12.000Z</published>
    <updated>2020-03-03T09:51:28.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1790"><a href="#Problem-1790" class="headerlink" title="Problem 1790"></a>Problem 1790</h1><h2 id="수-이어-쓰기-2"><a href="#수-이어-쓰기-2" class="headerlink" title="수 이어 쓰기 2"></a>수 이어 쓰기 2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.</p><blockquote><p>1234567891011121314151617181920212223…</p></blockquote><p>이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1 ≤ N ≤ 100,000,000)과,  k(1 ≤ k ≤ 1,000,000,000)가 주어진다. N과 k 사이에는 공백이 하나 이상 있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 앞에서 k번째 자리 숫자를 출력한다. 수의 길이가 k보다 작아서 k번째 자리 숫자가 없는 경우는 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1790" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1790</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20 23</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>1부터 N까지의 수를 이어 써서 만든 수의 길이를 구하는 함수 calc를 만든다.</li><li>먼저 n까지 이어 쓴 수의 길이가 k보다 작으면 불가능하므로 예외처리를 한다.</li><li>이분 탐색을 통해 어떤 수까지를 이어 써야 k번째 수가 나오는지 확인한다.</li><li>그 수(ans)를 찾으면 k번째 수를 구하기 위해 ans의 길이를 구해 calc(ans) - k를 ans의 길이에서 빼고 인덱스를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// n까지의 수를 모두 이어 썼을 때, 그 수의 길이</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>, len = <span class="number">1</span>; start &lt;= n; start *= <span class="number">10</span>, len++)</span><br><span class="line">&#123; <span class="comment">// start : 자리수의 첫 수, len : 길이</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span> = start * <span class="number">10</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">end</span> &gt;= n)</span><br><span class="line">ans += (<span class="keyword">long</span>)((n - start + <span class="number">1</span>) * len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += (<span class="keyword">long</span>)((<span class="built_in">end</span> - start + <span class="number">1</span>) * len); <span class="comment">// 현재 자리수까지의 길이 누적</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (calc(n) &lt; k) <span class="comment">// n까지 이어 쓴 수의 길이가 k보다 작으면 불가능</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 이분 탐색</span></span><br><span class="line">&#123; <span class="comment">// 어떤 수까지를 이어 써야 k번째 수가 나오는지 확인</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> len = calc(mid);</span><br><span class="line"><span class="keyword">if</span> (k &gt; len)</span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = mid;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> s = to_string(ans);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l = calc(ans);</span><br><span class="line"><span class="comment">// l - k를 구해서 마지막 수의 길이에서 뺀다.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[s.<span class="built_in">size</span>() - (l - k) - <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1790&quot;&gt;&lt;a href=&quot;#Problem-1790&quot; class=&quot;headerlink&quot; title=&quot;Problem 1790&quot;&gt;&lt;/a&gt;Problem 1790&lt;/h1&gt;&lt;h2 id=&quot;수-이어-쓰기-2&quot;&gt;&lt;a href=&quot;#수-이어
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1074번 Z</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1074/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1074/</id>
    <published>2020-03-02T09:51:12.000Z</published>
    <updated>2020-03-04T15:53:09.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1074"><a href="#Problem-1074" class="headerlink" title="Problem 1074"></a>Problem 1074</h1><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>한수는 2차원 배열 (항상 2^N * 2^N 크기이다)을 Z모양으로 탐색하려고 한다. 예를 들어, 2*2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.</p><p>만약, 2차원 배열의 크기가 2^N * 2^N라서 왼쪽 위에 있는 칸이 하나가 아니라면, 배열을 4등분 한 후에 (크기가 같은 2^(N-1)로) 재귀적으로 순서대로 방문한다.</p><p>다음 예는 2^2 * 2^2 크기의 배열을 방문한 순서이다.</p><p>N이 주어졌을 때, (r, c)를 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.</p><p>다음 그림은 N=3일 때의 예이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N r c가 주어진다. N은 15보다 작거나 같은 자연수이고, r과 c는 0보다 크거나 같고, 2^N-1보다 작거나 같은 정수이다</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 정답을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1074" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1074</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2 3 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>11</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 7 7</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>63</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀함수로 분할정복을 통해 해결하였다.</li><li>n은 2^n으로 변경하여 인자로 넘겨준다.</li><li>크기가 n * n인 2차원 배열을 4분할하여 2행 2열이 되면 지그재그로 몇 번째 방문인지 카운트한다.</li><li>i가 r , j가 c가 되면 그 때의 ans를 출력하고 리턴한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zigzag</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 지그재그로 방문하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="comment">// 2행 2열이 된 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == r &amp;&amp; j == c) <span class="comment">// r, c에 도착하면 출력 후 리턴</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans++; <span class="comment">// 1씩 증가</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">zigzag(x + m * i, y + m * j, m); <span class="comment">// n / 2씩 건너뛰며 재귀</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r &gt;&gt; c;</span><br><span class="line">n = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">zigzag(<span class="number">0</span>, <span class="number">0</span>, n); <span class="comment">// 0, 0 부터 탐색 n은 2^n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1074&quot;&gt;&lt;a href=&quot;#Problem-1074&quot; class=&quot;headerlink&quot; title=&quot;Problem 1074&quot;&gt;&lt;/a&gt;Problem 1074&lt;/h1&gt;&lt;h2 id=&quot;Z&quot;&gt;&lt;a href=&quot;#Z&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1939번 쿼드트리</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1992/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1992/</id>
    <published>2020-03-02T06:51:12.000Z</published>
    <updated>2020-03-03T09:53:21.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1992"><a href="#Problem-1992" class="headerlink" title="Problem 1992"></a>Problem 1992</h1><h2 id="쿼드트리"><a href="#쿼드트리" class="headerlink" title="쿼드트리"></a>쿼드트리</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.</p><p>주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 “0”이 되고, 모두 1로만 되어 있으면 압축 결과는 “1”이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다</p><p>위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 “(0(0011)(0(0111)01)1)”로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1≤N ≤64의 범위를 가진다. 두 번째 줄부터는 길이 N 의 문자열이 N 개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>영상을 압축한 결과를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1992" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1992</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8<br>11110000<br>11110000<br>00011100<br>00011100<br>11110000<br>11110000<br>11110011<br>11110011</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>((110(0101))(0010)1(0001))</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀함수로 분할정복을 통해 해결하였다.</li><li>현재 크기의 영상이 모두 0또는 1로만 이루어져있다면 결과 문자열에 누적하고 리턴한다.</li><li>아니라면 4분할하여 재귀를 수행한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 크기가 n * n인 영상을 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] != a[i][j])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check(x, y, n)) <span class="comment">// 현재 크기의 영상 확인</span></span><br><span class="line">&#123;</span><br><span class="line">ans += a[x][y]; <span class="comment">// 모두 0또는 1로만 이루어져있다면 결과 문자열에 누적</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="string">'('</span>; <span class="comment">// 단계에서 괄호 시작</span></span><br><span class="line"><span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">go(x + m * i, y + m * j, m); <span class="comment">// 4분할 하여 재귀</span></span><br><span class="line">&#125;</span><br><span class="line">ans += <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.<span class="built_in">size</span>(); j++)</span><br><span class="line">a[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1992&quot;&gt;&lt;a href=&quot;#Problem-1992&quot; class=&quot;headerlink&quot; title=&quot;Problem 1992&quot;&gt;&lt;/a&gt;Problem 1992&lt;/h1&gt;&lt;h2 id=&quot;쿼드트리&quot;&gt;&lt;a href=&quot;#쿼드트리&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1774번 수 묶기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1774/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1774/</id>
    <published>2020-03-02T00:51:12.000Z</published>
    <updated>2020-03-02T00:51:30.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1774"><a href="#Problem-1774" class="headerlink" title="Problem 1774"></a>Problem 1774</h1><h2 id="수-묶기"><a href="#수-묶기" class="headerlink" title="수 묶기"></a>수 묶기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.</p><p>예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2<em>3)+(4</em>5) = 27이 되어 최대가 된다.</p><p>수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.</p><p>수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작다. 둘째 줄부터 N개의 줄에, 수열의 각 수가 주어진다. 수열의 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>수를 적절히 묶어 그 합이 최댓값을 출력한다. 정답은 항상 2^31보다 작다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1774" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1774</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>-1<br>2<br>1<br>3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그리디로 우선순위 큐를 사용하여 해결하였다.</li><li>두 수를 곱하여 묶을 수 있으므로 가장 큰 수끼리 먼저 묶는 것이 항상 최댓값이 된다.</li><li>음수와 양수를 담을 우선순위 큐를 각각 사용하여 양수는 최대 힙으로, 음수는 최소 힙으로 구현한다.<ul><li>절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있으므로 음수는 최소 힙으로 구현하였고</li><li>음수 중 절댓값이 가장 작은 수가 남은 경우 0과 곱하면 더 크게 만들 수 있으므로 0도 음수 큐에 포함시킨다.</li></ul></li><li>각각 큐에서 두 개씩 뽑아 곱한 값이 더한 값보다 크다면 곱한 값을 누적하고 아니라면 더한 값을 누적하여 답을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">// 양수를 담을 우선순위 큐</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; mq; <span class="comment">// 음수를 담을 우선순위 큐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 양수와 음수를 구분하여 우선순위 큐에 담음 0은 음수에 포함</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">if</span> (m &gt; <span class="number">0</span>)</span><br><span class="line">pq.push(m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mq.push(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="comment">// 양수 큐에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"><span class="keyword">int</span> y = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x * y &gt;= x + y) <span class="comment">// 큰 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면</span></span><br><span class="line">ans += x * y; <span class="comment">// 곱한 값 누적</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pq.empty()) <span class="comment">// 양수 큐의 수가 홀수 개라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = pq.top(); <span class="comment">// 남은 수 처리</span></span><br><span class="line">pq.pop();</span><br><span class="line">ans += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="comment">// 음수 큐에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = mq.top();</span><br><span class="line">mq.pop();</span><br><span class="line"><span class="keyword">int</span> y = mq.top();</span><br><span class="line">mq.pop();</span><br><span class="line"> <span class="comment">// 절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있음</span></span><br><span class="line"><span class="keyword">if</span> (x * y &gt;= x + y) <span class="comment">// 작은 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면</span></span><br><span class="line">ans += x * y; <span class="comment">// 곱한 값 누적</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mq.empty()) <span class="comment">// 음수 큐의 원소가 홀수 개라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = mq.top(); <span class="comment">// 남은 수 처리</span></span><br><span class="line">mq.pop();</span><br><span class="line">ans += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1774&quot;&gt;&lt;a href=&quot;#Problem-1774&quot; class=&quot;headerlink&quot; title=&quot;Problem 1774&quot;&gt;&lt;/a&gt;Problem 1774&lt;/h1&gt;&lt;h2 id=&quot;수-묶기&quot;&gt;&lt;a href=&quot;#수-묶기&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1780번 종이의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/01/algorithm1780/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/01/algorithm1780/</id>
    <published>2020-03-01T11:39:25.000Z</published>
    <updated>2020-03-01T11:39:39.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1780"><a href="#Problem-1780" class="headerlink" title="Problem 1780"></a>Problem 1780</h1><h2 id="종이의-개수"><a href="#종이의-개수" class="headerlink" title="종이의 개수"></a>종이의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다. 우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다.</p><p>만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.<br>(1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.<br>이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1≤N≤3^7, N은 3^k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1780" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1780</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>9<br>0 0 0 1 1 1 -1 -1 -1<br>0 0 0 1 1 1 -1 -1 -1<br>0 0 0 1 1 1 -1 -1 -1<br>1 1 1 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0<br>0 1 -1 0 1 -1 0 1 -1<br>0 -1 1 0 1 -1 0 1 -1<br>0 1 -1 1 0 -1 0 1 -1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>10<br>12<br>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>분할 정복으로 재귀 함수를 통해 해결하였다.</li><li>종이의 전체를 확인하고 모두 같지 않다면 9개로 분할하여 다시 확인하는 것을 반복한다.</li><li>(x, y) : 종이의 시작점(가장왼쪽 가장위), n : 종이의 크기 를 인자로 가지는 함수로<ul><li>모든 칸이 같은 수라면 해당 수의 개수를 +1하고 리턴,</li><li>같지 않다면 (x, y)를 (x + n, y + n)까지 n / 3 만큼씩 증가시키며 재귀를 수행한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2187</span>][<span class="number">2187</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 현재 종이의 모든 칸이 같은지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] != a[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// (x, y) : 종이의 시작점(가장왼쪽 가장위), n : 종이의 크기</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (same(x, y, n)) <span class="comment">// 모든 칸이 같은 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>)</span><br><span class="line">cnt[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x][y] == <span class="number">1</span>)</span><br><span class="line">cnt[<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cnt[<span class="number">2</span>]++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 모든 같이 같지 않으면 다시 분할하여 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + n; i += n / <span class="number">3</span>) <span class="comment">// 전체를 9분할하여 모두 확인</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j += n / <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">div(i, j, n / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">div(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1780&quot;&gt;&lt;a href=&quot;#Problem-1780&quot; class=&quot;headerlink&quot; title=&quot;Problem 1780&quot;&gt;&lt;/a&gt;Problem 1780&lt;/h1&gt;&lt;h2 id=&quot;종이의-개수&quot;&gt;&lt;a href=&quot;#종이의-개수&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16928번 뱀과 사다리 게임</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/01/algorithm16928/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/01/algorithm16928/</id>
    <published>2020-03-01T09:51:12.000Z</published>
    <updated>2020-03-03T09:58:27.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16928"><a href="#Problem-16928" class="headerlink" title="Problem 16928"></a>Problem 16928</h1><h2 id="뱀과-사다리-게임"><a href="#뱀과-사다리-게임" class="headerlink" title="뱀과 사다리 게임"></a>뱀과 사다리 게임</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>뱀과 사다리 게임을 즐겨 하는 큐브러버는 어느 날 궁금한 점이 생겼다.</p><blockquote><p>주사위를 조작해 내가 원하는 수가 나오게 만들 수 있다면, 최소 몇 번만에 도착점에 도착할 수 있을까?</p></blockquote><p>게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다. 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다.</p><p>플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다. 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다. 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다. 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다. 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다. 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다.</p><p>게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다.</p><p>게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판에 있는 사다리의 수 N(1 ≤ N ≤ 15)과 뱀의 수 M(1 ≤ M ≤ 15)이 주어진다.</p><p>둘째 줄부터 N개의 줄에는 사다리의 정보를 의미하는 x, y (x &lt; y)가 주어진다. x번 칸에 도착하면, y번 칸으로 이동한다는 의미이다.</p><p>다음 M개의 줄에는 뱀의 정보를 의미하는 u, v (u &gt; v)가 주어진다. u번 칸에 도착하면, v번 칸으로 이동한다는 의미이다.</p><p>1번 칸과 100번 칸은 뱀과 사다리의 시작 또는 끝이 아니다. 모든 칸은 최대 하나의 사다리 또는 뱀을 가지고 있으며, 동시에 두 가지를 모두 가지고 있는 경우는 없다. 항상 100번 칸에 도착할 수 있는 입력만 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>100번 칸에 도착하기 위해 주사위를 최소 몇 번 굴려야 하는지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16928" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16928</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 7<br>32 62<br>42 68<br>12 98<br>95 13<br>97 25<br>93 37<br>79 27<br>75 19<br>49 47<br>67 17</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4 9<br>8 52<br>6 80<br>26 42<br>2 72<br>51 19<br>39 11<br>37 29<br>81 3<br>59 5<br>79 23<br>53 7<br>43 33<br>77 21</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>5</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>bfs를 이용하여 굴려야 하는 주사위의 최소 횟수를 구한다.</li><li>1부터 시작하여 가능한 주사위의 눈이 1~6 이므로 모든 경우를 큐에 넣는다.<ul><li>이 때, 다음 노드가 뱀 또는 사다리에 연결되어 있다면 반드시 이동해야 하므로</li><li>즉시 연결된 노드로 이동한다.</li></ul></li><li>범위 내에서 아직 방문하지 않은 경우 주사위 횟수를 추가하고 다음 노드를 큐에 넣는다.</li><li>100 일때 횟수를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">// 주사위 횟수를 모두 -1로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">a[u] =  v; <span class="comment">// 사다리</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">a[u] = v; <span class="comment">// 뱀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>); <span class="comment">// 1부터 시작</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dist[<span class="number">100</span>] != <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 100을 방문했다면 break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) <span class="comment">// 가능한 주사위 눈 (1~6)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = node + i; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (a[next] != <span class="number">0</span>) next = a[next]; <span class="comment">// 다음 노드가 뱀 또는 사다리에 연결되어 있다면 즉시 이동(반드시 이동해야함)</span></span><br><span class="line"><span class="keyword">if</span> (dist[next] == <span class="number">-1</span> &amp;&amp; node + i &lt;= <span class="number">100</span>) <span class="comment">// 범위 내에서 아직 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(next);</span><br><span class="line">dist[next] = dist[node] + <span class="number">1</span>; <span class="comment">// 주사위 횟수 추가</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dist[<span class="number">100</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16928&quot;&gt;&lt;a href=&quot;#Problem-16928&quot; class=&quot;headerlink&quot; title=&quot;Problem 16928&quot;&gt;&lt;/a&gt;Problem 16928&lt;/h1&gt;&lt;h2 id=&quot;뱀과-사다리-게임&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1991번 트리 순회</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/01/algorithm1991/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/01/algorithm1991/</id>
    <published>2020-03-01T09:51:12.000Z</published>
    <updated>2020-03-04T16:20:23.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1991"><a href="#Problem-1991" class="headerlink" title="Problem 1991"></a>Problem 1991</h1><h2 id="트리-순회"><a href="#트리-순회" class="headerlink" title="트리 순회"></a>트리 순회</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.</p><p>예를 들어 위와 같은 이진 트리가 입력되면,</p><ul><li>전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식)</li><li>중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식)</li><li>후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 이진 트리의 노드의 개수 N(1≤N≤26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 영문자 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현된다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.<br>1991</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1991" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1991</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7<br>A B C<br>B D .<br>C E F<br>E . .<br>F . G<br>D . .<br>G . .</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>ABDCEFG<br>DBAECFG<br>DBEGFCA</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>트리의 순회 : dfs 3가지 출력 순서</li><li>프리오더 (전위 순회)<ul><li>노드 방문</li><li>왼쪽 자식 노드를 루트로 하는 서브 트리 프리오더</li><li>오른쪽 자식 노드를 루트로 하는 서브 트리 프리오더</li></ul></li><li>인오더 (중위 순회)<ul><li>왼쪽 자식 노드를 루트로 하는 서브 트리 인오더</li><li>노드 방문</li><li>오른쪽 자식 노드를 루트로 하는 서브 트리 인오더</li></ul></li><li>포스트오더 (후위 순회) : ** 자식에 대한 정보를 이용해 현재 노드의 값을 계산할 때 주로 사용(dp)<ul><li>왼쪽 자식 노드를 루트로 하는 서브 트리 포스트오더</li><li>오른쪽 자식 노드를 루트로 하는 서브 트리 포스트오더</li><li>노드 방문</li></ul></li><li>트리를 구조체를 이용하여 각 노드의 좌측 자식 노드와 우측 자식 노드를 저장한다.<ul><li>노드가 문자로 입력되므로 루트 노드를 0으로 하여 정수로 바꿔 저장한다.</li><li>‘.’이 입력되는 경우 자식 노드가 없다는 뜻이므로 -1을 저장한다.</li></ul></li><li>각 순회 방식을 dfs를 이용하여 구현한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> // 구조체로 트리 구현</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> left;</span><br><span class="line"><span class="keyword">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 프리오더(전위 순회)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">char</span>(x + <span class="string">'A'</span>); <span class="comment">// 현재 노드 출력</span></span><br><span class="line">preorder(a[x].left);</span><br><span class="line">preorder(a[x].right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 인오더(중위 순회)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="comment">// 자식 노드가 없으면 리턴</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">inorder(a[x].left);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">char</span>(x + <span class="string">'A'</span>);</span><br><span class="line">inorder(a[x].right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 포스트오더(후위 순회)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">postorder(a[x].left);</span><br><span class="line">postorder(a[x].right);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">char</span>(x + <span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 이진 트리의 노드의 개수</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> x, y, z;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">x = x - <span class="string">'A'</span>; <span class="comment">// 부모 노드 (0부터 시작)</span></span><br><span class="line"><span class="keyword">if</span> (y == <span class="string">'.'</span>)</span><br><span class="line">a[x].left = <span class="number">-1</span>; <span class="comment">// 자식 노드가 없는 경우</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a[x].left = y - <span class="string">'A'</span>; <span class="comment">// 왼쪽 자식 노드 저장(정수형으로)</span></span><br><span class="line"><span class="keyword">if</span> (z == <span class="string">'.'</span>)</span><br><span class="line">a[x].right = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">a[x].right = z - <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preorder(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">inorder(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">postorder(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1991&quot;&gt;&lt;a href=&quot;#Problem-1991&quot; class=&quot;headerlink&quot; title=&quot;Problem 1991&quot;&gt;&lt;/a&gt;Problem 1991&lt;/h1&gt;&lt;h2 id=&quot;트리-순회&quot;&gt;&lt;a href=&quot;#트리-순회&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1697번 숨바꼭질</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/28/algorithm1697/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/28/algorithm1697/</id>
    <published>2020-02-28T09:51:12.000Z</published>
    <updated>2020-03-04T16:29:50.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1697"><a href="#Problem-1697" class="headerlink" title="Problem 1697"></a>Problem 1697</h1><h2 id="숨바꼭질"><a href="#숨바꼭질" class="headerlink" title="숨바꼭질"></a>숨바꼭질</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.</p><p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1697" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1697</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 17</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>1초 단위로만 이동이 가능하기 때문에 간선의 가중치는 모두 1이고, 최소 비용 문제이기 때문에 bfs를 이용하여 구할 수 있다.</li><li>처음 수빈이의 위치를 시작 노드로 하여 큐에 넣어준다.</li><li>수빈이가 이동 가능한 경우는 x + 1, x - 1, x * 2 이므로 각각의 경우를 모두 큐에 넣고<ul><li>n부터 현재 위치까지 몇 초가 걸리는지 저장할 sec배열의 다음 위치에 현재 위치 +1의 값을 넣어준다.</li><li>이때, sec[n] = 0으로 초기화 한다. ()수빈이의 시작 위치)</li></ul></li><li>수빈이의 위치 n에서부터 이동 가능한 모든 위치의 시간을 구한 뒤 sec[k]를 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ul><li><p>잘못된 코드</p><ul><li>원래 이동 가능한 경우는 x + 1, x - 1, x * 2 뿐인데,</li><li>아래와 같이 짠다면 x / 2로도 이동이 가능하다.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sec[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt;= MAX)</span><br><span class="line">&#123;</span><br><span class="line">a[i] .push_back(i + <span class="number">1</span>);</span><br><span class="line">a[i + <span class="number">1</span>].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i * <span class="number">2</span> &lt;= MAX)</span><br><span class="line">&#123;</span><br><span class="line">a[i].push_back(i * <span class="number">2</span>);</span><br><span class="line">a[<span class="number">2</span> * i].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(sec, <span class="number">-1</span>, <span class="keyword">sizeof</span>(sec));</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(n);</span><br><span class="line">check[n] = <span class="literal">true</span>;</span><br><span class="line">sec[n] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(next);</span><br><span class="line">check[next] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(sec[next] == <span class="number">-1</span> || sec[next] &gt; sec[node] + <span class="number">1</span>)</span><br><span class="line">sec[next] = sec[node] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check[k])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sec[k] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>정답 코드</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// 방문 여부 판단</span></span><br><span class="line"><span class="keyword">int</span> sec[MAX + <span class="number">1</span>]; <span class="comment">// n번째 노드까지의 시간</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(n);</span><br><span class="line">check[n] = <span class="literal">true</span>;</span><br><span class="line">sec[n] = <span class="number">0</span>; <span class="comment">// 수빈이의 위치에서 시작</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (node - <span class="number">1</span> &gt;= <span class="number">0</span>) <span class="comment">// x - 1의 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[node - <span class="number">1</span>] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(node - <span class="number">1</span>);</span><br><span class="line">check[node - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">sec[node - <span class="number">1</span>] = sec[node] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node + <span class="number">1</span> &lt;= MAX) <span class="comment">//  x + 1의 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[node + <span class="number">1</span>] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(node + <span class="number">1</span>);</span><br><span class="line">check[node + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">sec[node + <span class="number">1</span>] = sec[node] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node * <span class="number">2</span> &lt;= MAX) <span class="comment">// x * 2의 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[node * <span class="number">2</span>] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(node * <span class="number">2</span>);</span><br><span class="line">check[node * <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">sec[node * <span class="number">2</span>] = sec[node] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sec[k] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1697&quot;&gt;&lt;a href=&quot;#Problem-1697&quot; class=&quot;headerlink&quot; title=&quot;Problem 1697&quot;&gt;&lt;/a&gt;Problem 1697&lt;/h1&gt;&lt;h2 id=&quot;숨바꼭질&quot;&gt;&lt;a href=&quot;#숨바꼭질&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2839번 설탕 배달</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/28/algorithm2839/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/28/algorithm2839/</id>
    <published>2020-02-28T09:51:12.000Z</published>
    <updated>2020-03-05T07:33:11.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2839"><a href="#Problem-2839" class="headerlink" title="Problem 2839"></a>Problem 2839</h1><h2 id="설탕-배달"><a href="#설탕-배달" class="headerlink" title="설탕 배달"></a>설탕 배달</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.</p><p>상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.</p><p>상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2839" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2839</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>18</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>2</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>9</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>항상 설탕 5kg 짜리 봉지가 많은 것이 더 적은 봉지로 배달할 수 있기 때문에 그리디로 접근할 수 있다.</li><li>하지만 다이나믹 프로그래밍(dp)으로도 해결할 수 있기 때문에 나는 dp로 풀었다.</li><li>점화식 d[n] = 설탕을 n kg 배달할 때, 봉지의 최소 개수</li><li>설탕 n kg을 배달하는 경우, 가능한 경우는<ul><li>n - 3 kg 에서 3kg짜리 한 봉지를 추가하는 경우와</li><li>n - 5 kg 에서 5kg짜리 한 봉지를 추가하는 경우 뿐이다.</li></ul></li><li>최솟값을 구하므로 d[n] = min(d[n - 3] + 1, d[n - 5] + 1) 라고 할 수 있다.</li><li>모두 -1로 초기화 하여 d[3] = 1, d[5] = 1 을 초기값으로 잡고 buttom-up방식으로 풀었다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ul><li>dp<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAX + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d)); <span class="comment">// -1로 초기화</span></span><br><span class="line"></span><br><span class="line">d[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 점화식 d[n] = max(d[n - 3] + 1, d[n - 5] + 1)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i - <span class="number">3</span>] != <span class="number">-1</span>)</span><br><span class="line">d[i] = d[i - <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[i - <span class="number">5</span>] != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(d[i] == <span class="number">-1</span> || d[i] &gt; d[i - <span class="number">5</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i - <span class="number">5</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2839&quot;&gt;&lt;a href=&quot;#Problem-2839&quot; class=&quot;headerlink&quot; title=&quot;Problem 2839&quot;&gt;&lt;/a&gt;Problem 2839&lt;/h1&gt;&lt;h2 id=&quot;설탕-배달&quot;&gt;&lt;a href=&quot;#설탕-배달&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 7562번 나이트의 이동</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/27/algorithm7562/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/27/algorithm7562/</id>
    <published>2020-02-27T09:51:12.000Z</published>
    <updated>2020-03-04T16:27:46.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-7562"><a href="#Problem-7562" class="headerlink" title="Problem 7562"></a>Problem 7562</h1><h2 id="나이트의-이동"><a href="#나이트의-이동" class="headerlink" title="나이트의 이동"></a>나이트의 이동</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.</p><p>각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, …, l-1} × {0, …, l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스마다 나이트가 몇 번만에 이동할 수 있는지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/7562" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/7562</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>8<br>0 0<br>7 0<br>100<br>0 0<br>30 50<br>10<br>1 1<br>1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>5<br>28<br>0</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>나이트가 목표 지점까지 이동하는 최소 이동횟수를 구하는 문제이므로 bfs를 사용한다.</li><li>나이트가 이동할 수 있는 방향은 8개, 이동 가능한 위치의 상대 위치를 저장하여 탐색한다.</li><li>d라는 배열에 각 위치까지의 이동 횟수를 기록한다.<ul><li>목표 위치의 d에 저장된 값을 출력한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span> &#125;; <span class="comment">// x, y의 상대적 위치</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span> ,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">301</span>][<span class="number">301</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">301</span>][<span class="number">301</span>]; <span class="comment">// 이동 횟수</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 한 변의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInside</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 체스판 내부인지 판별</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)); <span class="comment">// d, check 배열 초기화</span></span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(x, y));</span><br><span class="line">d[x][y] = <span class="number">0</span>;</span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x = q.front().first;</span><br><span class="line">y = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 8방향 모두 탐색</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isInside(nx, ny)) <span class="comment">// 체스판 내부인지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny));</span><br><span class="line">check[nx][ny] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line">d[nx][ny] = d[x][y] + <span class="number">1</span>; <span class="comment">// 이동 횟수 추가</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t; <span class="comment">// test case</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> sx, sy, ex, ey;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy; <span class="comment">// 시작 위치</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ex &gt;&gt; ey; <span class="comment">// 마지막 위치</span></span><br><span class="line"></span><br><span class="line">bfs(sx, sy);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[ex][ey] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-7562&quot;&gt;&lt;a href=&quot;#Problem-7562&quot; class=&quot;headerlink&quot; title=&quot;Problem 7562&quot;&gt;&lt;/a&gt;Problem 7562&lt;/h1&gt;&lt;h2 id=&quot;나이트의-이동&quot;&gt;&lt;a href=&quot;#나이트의-이
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16948번 데스 나이트</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/25/algorithm16948/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/25/algorithm16948/</id>
    <published>2020-02-25T09:51:12.000Z</published>
    <updated>2020-03-03T09:58:09.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16948"><a href="#Problem-16948" class="headerlink" title="Problem 16948"></a>Problem 16948</h1><h2 id="데스-나이트"><a href="#데스-나이트" class="headerlink" title="데스 나이트"></a>데스 나이트</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>게임을 좋아하는 큐브러버는 체스에서 사용할 새로운 말 “데스 나이트”를 만들었다. 데스 나이트가 있는 곳이 (r, c)라면, (r-2, c-1), (r-2, c+1), (r, c-2), (r, c+2), (r+2, c-1), (r+2, c+1)로 이동할 수 있다.</p><p>크기가 N×N인 체스판과 두 칸 (r1, c1), (r2, c2)가 주어진다. 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 구해보자. 체스판의 행과 열은 0번부터 시작한다.</p><p>데스 나이트는 체스판 밖으로 벗어날 수 없다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 체스판의 크기 N(5 ≤ N ≤ 200)이 주어진다. 둘째 줄에 r1, c1, r2, c2가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 출력한다. 이동할 수 없는 경우에는 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16948" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16948</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7<br>6 6 0 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6<br>5 1 0 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>7<br>0 3 4 3</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>bfs를 이용하여 최소 이동 횟수를 구한다.</li><li>시작 좌표를 큐에 넣고 이동 가능한 모든 경우를 확인한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span> &#125;; <span class="comment">// (x, y)로 이동 가능한 상대 좌표</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sr, sc, er, ec; <span class="comment">// 시작점, 도착점</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sr &gt;&gt; sc &gt;&gt; er &gt;&gt; ec;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">// 거리를 모두 -1로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(sr, sc)); <span class="comment">// 시작 좌표 push</span></span><br><span class="line">check[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">dist[sr][sc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front().first;</span><br><span class="line"><span class="keyword">int</span> y = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="comment">// 이동 가능한 모든 경우 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) <span class="comment">// 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span>) <span class="comment">// 아직 확인하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny));</span><br><span class="line">check[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">dist[nx][ny] = dist[x][y] + <span class="number">1</span>; <span class="comment">// 다음 좌표 push 후 거리 추가</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dist[er][ec] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16948&quot;&gt;&lt;a href=&quot;#Problem-16948&quot; class=&quot;headerlink&quot; title=&quot;Problem 16948&quot;&gt;&lt;/a&gt;Problem 16948&lt;/h1&gt;&lt;h2 id=&quot;데스-나이트&quot;&gt;&lt;a href=&quot;#데스-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2178번 미로 탐색</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/23/algorithm2178/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/23/algorithm2178/</id>
    <published>2020-02-23T10:51:12.000Z</published>
    <updated>2020-03-04T16:25:49.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2178"><a href="#Problem-2178" class="headerlink" title="Problem 2178"></a>Problem 2178</h1><h2 id="미로-탐색"><a href="#미로-탐색" class="headerlink" title="미로 탐색"></a>미로 탐색</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×M크기의 배열로 표현되는 미로가 있다.</p><p>1    0    1    1    1    1</p><p>1    0    1    0    1    0</p><p>1    0    1    0    1    1</p><p>1    1    1    0    1    1</p><p>미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.</p><p>위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2178" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2178</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 6<br>101111<br>101010<br>101011<br>111011</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>15</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4 6<br>110110<br>110110<br>111111<br>111101</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>9</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>2 25<br>1011101110111011101110111<br>1110111011101110111011101</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>38</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>7 7<br>1011111<br>1110001<br>1000001<br>1000001<br>1000001<br>1000001<br>1111111</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>13</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>최단 거리를 구하는 문제라고 볼 수 있으므로 bfs를 이용한다.</li><li>dist배열에 이동가능한 각 칸의 (0,0)에서의 거리를 저장한다.<ul><li>dist[0][0] = 1을 두고 다음 좌표에 1씩 더해 저장</li></ul></li><li>이동 가능한 방향(상하좌우)를 dx, dy에 저장하여 탐색</li><li>bfs로 탐색 후 dist[n - 1][m - 1]을 구하면 된다.<ul><li>(1,1)이 아닌 (0,0)부터 시작했으므로</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">// (0, 0)에서부터의 거리</span></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 미로의 행(세로), 열(가로)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(x, y));</span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line">dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x = q.front().first; <span class="comment">// 현재 좌표</span></span><br><span class="line">y = q.front().second;</span><br><span class="line">q.pop(); <span class="comment">// 좌표 저장 후 pop (bfs)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i]; <span class="comment">// 다음 좌표</span></span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m) <span class="comment">// 미로의 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span> &amp;&amp; a[nx][ny] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny)); <span class="comment">// 방문할 때 push</span></span><br><span class="line">check[nx][ny] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line">dist[nx][ny] = dist[x][y] + <span class="number">1</span>; <span class="comment">// (0, 0)을 1로 시작하여 거리 계산</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.length(); j++)</span><br><span class="line">a[i][j] = <span class="keyword">int</span>(str[j] - <span class="string">'0'</span>); <span class="comment">// 정수로 변환</span></span><br><span class="line">&#125;</span><br><span class="line">bfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dist[n - <span class="number">1</span>][m - <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2178&quot;&gt;&lt;a href=&quot;#Problem-2178&quot; class=&quot;headerlink&quot; title=&quot;Problem 2178&quot;&gt;&lt;/a&gt;Problem 2178&lt;/h1&gt;&lt;h2 id=&quot;미로-탐색&quot;&gt;&lt;a href=&quot;#미로-탐색&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 4963번 섬의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/23/algorithm4963/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/23/algorithm4963/</id>
    <published>2020-02-23T09:51:12.000Z</published>
    <updated>2020-03-04T16:24:25.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-4963"><a href="#Problem-4963" class="headerlink" title="Problem 4963"></a>Problem 4963</h1><h2 id="섬의-개수"><a href="#섬의-개수" class="headerlink" title="섬의 개수"></a>섬의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.</p><p>한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다.</p><p>두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러쌓여 있으며, 지도 밖으로 나갈 수 없다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 지도의 너비 w와 높이 h가 주어진다. w와 h는 50보다 작거나 같은 양의 정수이다.</p><p>둘째 줄부터 h개 줄에는 지도가 주어진다. 1은 땅, 0은 바다이다.</p><p>입력의 마지막 줄에는 0이 두 개 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스에 대해서, 섬의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/4963" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/4963</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>1 1<br>0<br>2 2<br>0 1<br>1 0<br>3 2<br>1 1 1<br>1 1 1<br>5 4<br>1 0 1 0 0<br>1 0 0 0 0<br>1 0 1 0 1<br>1 0 0 1 0<br>5 4<br>1 1 1 0 1<br>1 0 1 0 1<br>1 0 1 0 1<br>1 0 1 1 1<br>5 5<br>1 0 1 0 1<br>0 0 0 0 0<br>1 0 1 0 1<br>0 0 0 0 0<br>1 0 1 0 1<br>0 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0<br>1<br>1<br>3<br>1<br>9</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>단지번호 붙이기 문제와 유사하다. dfs 또는 bfs로 구현할 수 있다.<ul><li>결국 연결 요소의 개수를 구하는 문제이다.</li></ul></li><li>dfs로 구현</li><li>이때, 따로 인접 리스트를 만들지 않고 x, y 좌표를 통해 상하좌우로 다음 좌표를 정해 탐색을 수행한다.<ul><li>dx, dy라는 배열에 상하좌우, 대각선으로 이동할 좌표를 기록해 두어 반복문을 통해 다음 좌표를 탐색한다.</li></ul></li><li>현재 위치에서 8방을 탐색하며 다음 좌표가 육지이고 아직 방문하지 않은 경우에 재귀를 수행한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;; <span class="comment">// 상하좌우 대각선</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h; <span class="comment">// 너비, 높이</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[x][y] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 상하좌우, 대각선 탐색 (8방)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i]; <span class="comment">// 다음 x좌표</span></span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i]; <span class="comment">// 다음 y좌표</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; h &amp;&amp; ny &lt; w) <span class="comment">// 지도의 범위 내부</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span> &amp;&amp; check[nx][ny] == <span class="literal">false</span>) <span class="comment">// 다음 좌표가 육지이고 방문하지 않았다면</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; w &gt;&gt; h;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="number">0</span> &amp;&amp; h == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check)); <span class="comment">// check 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 연결요소의 개수</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; h; x++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; w; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">1</span> &amp;&amp; check[x][y] == <span class="literal">false</span>) <span class="comment">// 현재 좌표가 육지이고 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">count++; <span class="comment">// 연결 요소 카운트</span></span><br><span class="line">dfs(x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-4963&quot;&gt;&lt;a href=&quot;#Problem-4963&quot; class=&quot;headerlink&quot; title=&quot;Problem 4963&quot;&gt;&lt;/a&gt;Problem 4963&lt;/h1&gt;&lt;h2 id=&quot;섬의-개수&quot;&gt;&lt;a href=&quot;#섬의-개수&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11047번 동전</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/22/algorithm11047/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/22/algorithm11047/</id>
    <published>2020-02-22T09:51:12.000Z</published>
    <updated>2020-03-04T15:55:53.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11047"><a href="#Problem-11047" class="headerlink" title="Problem 11047"></a>Problem 11047</h1><h2 id="동전"><a href="#동전" class="headerlink" title="동전"></a>동전</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.</p><p>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)</p><p>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11047" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11047</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10 4200<br>1<br>5<br>10<br>50<br>100<br>500<br>1000<br>5000<br>10000<br>50000</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>동전 A(i)가 A(i+1)의 배수이므로 그리디 알고리즘으로 해결이 가능하다.</li><li>가장 큰 가치의 동전으로 나눈 몫만큼 개수를 증가시키고, 목표 금액을 가장 큰 가치의 동전으로 나눈 나머지로 변경하며 반복한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k / a[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt += k / a[i]; <span class="comment">// 가장 큰 가치의 동전으로 나눈 몫만큼 증가</span></span><br><span class="line">k %= a[i];  <span class="comment">// 나눈 나머지를 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11047&quot;&gt;&lt;a href=&quot;#Problem-11047&quot; class=&quot;headerlink&quot; title=&quot;Problem 11047&quot;&gt;&lt;/a&gt;Problem 11047&lt;/h1&gt;&lt;h2 id=&quot;동전&quot;&gt;&lt;a href=&quot;#동전&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2667번 단지번호 붙이기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/21/algorithm2667/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/21/algorithm2667/</id>
    <published>2020-02-21T06:51:12.000Z</published>
    <updated>2020-03-04T16:24:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2667"><a href="#Problem-2667" class="headerlink" title="Problem 2667"></a>Problem 2667</h1><h2 id="단지번호-붙이기"><a href="#단지번호-붙이기" class="headerlink" title="단지번호 붙이기"></a>단지번호 붙이기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2667" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2667</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7<br>0110100<br>0110101<br>1110101<br>0000111<br>0100000<br>0111110<br>0111000</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>7<br>8<br>9</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>인접한 집들을 찾아 단지를 정의하고 개수를 파악하면 된다. dfs 또는 bfs를 통해 구현하면 될 것이다.</li><li>dfs로 구현</li><li>이때, 따로 인접 리스트를 만들지 않고 x, y 좌표를 통해 상하좌우로 다음 좌표를 정해 탐색을 수행한다.<ul><li>dx, dy라는 배열에 상하좌우로 이동할 좌표를 기록해 두어 반복문을 통해 다음 좌표를 탐색한다.</li></ul></li><li>인접한 집들 별로 단지번호를 붙여준다.(이미 탐색을 수행했는지도 파악)</li><li>모든 좌표를 확인하여 단지 번호를 붙이고 새로운 배열에 같은 단지 번호를 가지는 주택의 수를 파악하여 저장한다.<ul><li>이후 count(단지번호 수)만큼 정렬을 수행하여 오름차순으로 출력한다.</li></ul></li><li>bfs로 구현<ul><li>x, y 좌표를 pair로 묶어 queue에 push</li><li>dfs와 같은 방식으로 구현</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">25</span>][<span class="number">25</span>]; <span class="comment">// 단지 번호를 기록할 배열</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">25</span>][<span class="number">25</span>]; <span class="comment">// 집의 유무를 기록할 배열</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;; <span class="comment">// 상하좌우 이동 좌표</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 지도의 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[x][y] = count; <span class="comment">// 현재 좌표의 단지 번호를 붙임</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">// 상하좌우 탐색</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) <span class="comment">// 지도의 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span> &amp;&amp; d[nx][ny] == <span class="number">0</span>) <span class="comment">// 다음번 좌표에 집이 있고, 아직 탐색하지 않은 경우(단지 번호가 안붙어있는 경우)</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(x, y));</span><br><span class="line">d[x][y] = count; <span class="comment">// 현재 좌표에 단지번호 붙이기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">x = q.front().first;</span><br><span class="line">y = q.front().second;</span><br><span class="line">q.pop(); <span class="comment">// 맨 앞 좌표 저장후 pop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span> &amp;&amp; d[nx][ny] == <span class="number">0</span>) <span class="comment">// 다음 좌표가 육지이고 아직 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny)); <span class="comment">// 다음 좌표 push</span></span><br><span class="line">d[nx][ny] = count; <span class="comment">// 방문처리 and 단지번호 붙이기</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">scanf_s(<span class="string">"%1d"</span>, &amp;a[i][j]); <span class="comment">// 한자리씩 입력</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 단지 번호(연결 요소의 개수)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">1</span> &amp;&amp; d[i][j] == <span class="number">0</span>) <span class="comment">// 현재 좌표에 집이 있고 탐색되지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">bfs(i, j, count + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// dfs(i, j, count + 1);</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">25</span> * <span class="number">25</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">ans[d[i][j]]++; <span class="comment">// 단지번호 별 주택의 개수 파악</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(ans + <span class="number">1</span>, ans + count + <span class="number">1</span>); <span class="comment">// 단지 번호를 1부터 붙였으므로</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2667&quot;&gt;&lt;a href=&quot;#Problem-2667&quot; class=&quot;headerlink&quot; title=&quot;Problem 2667&quot;&gt;&lt;/a&gt;Problem 2667&lt;/h1&gt;&lt;h2 id=&quot;단지번호-붙이기&quot;&gt;&lt;a href=&quot;#단지번호-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 7576번 토마토</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/19/algorithm7576/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/19/algorithm7576/</id>
    <published>2020-02-19T09:51:12.000Z</published>
    <updated>2020-03-04T16:26:58.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-7576"><a href="#Problem-7576" class="headerlink" title="Problem 7576"></a>Problem 7576</h1><h2 id="토마토"><a href="#토마토" class="headerlink" title="토마토"></a>토마토</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.</p><p>창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.</p><p>토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/7576" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/7576</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6 4<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>8</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 4<br>0 -1 0 0 0 0<br>-1 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 4<br>1 -1 0 0 0 0<br>0 -1 0 0 0 0<br>0 0 0 0 -1 0<br>0 0 0 0 -1 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>6</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>5 5<br>-1 1 0 0 0<br>0 -1 -1 -1 0<br>0 -1 -1 -1 0<br>0 -1 -1 -1 0<br>0 0 0 0 0</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>14</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>2 2<br>1 -1<br>-1 1</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>0</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>토마토가 모두 익을때 까지의 최소 날짜를 구하는 것이므로 bfs를 이용한다.</p><ul><li><p>방문 확인 및 익을 때까지의 날짜를 기록할 배열 d[][] 생성</p><ul><li>d[i][j]를 모두 -1로 초기화 하고, 초기에 익어있는 토마토의 위치에는 0을 넣는다.</li><li>-1로 초기화하는 이유는 모든 토마토가 익을 수 없는 상황을 판별하고 방문 여부를 판단하기 위해서이다.</li><li>익은 토마토에 0을 넣는 이유는 그 위치를 기준으로 다음 토마토가 익을 때 걸리는 시간을 구하기 위해서이다.</li></ul></li><li><p>초기에 익어있는 토마토가 여러 개일 수 있으므로 초기값이 1인 경우 위치를 모두 큐에 push해둔다.</p></li><li><p>처음 익어있는 토마토에서 동시에 탐색을 수행해 위치별로 익는데 걸리는 날짜를 저장한다.(d[x][y])</p></li><li><p>이후 d에 저장된 날짜의 최댓값을 구한다.(모든 토마토가 익는 날짜)</p></li><li><p>a[i][j]가 0이고 d[i][j]가 -1 인 경우가 있다면 모든 토마토가 익을 수 없는 경우이므로 -1 출력</p></li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>][<span class="number">1001</span>]; <span class="comment">// 익은 토마토에서의 거리(날짜)</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">d[i][j] = <span class="number">-1</span>; <span class="comment">// 토마토가 익지 못하는 상황을 찾기 위해 -1로 초기화(0은 익은 토마토의 초기 위치)</span></span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(i, j)); <span class="comment">// 익은 토마토를 큐에 넣어 bfs의 시작점으로 정한다.</span></span><br><span class="line">d[i][j] = <span class="number">0</span>; <span class="comment">// 익은 토마토 초기 위치</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front().first;</span><br><span class="line"><span class="keyword">int</span> y = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m) <span class="comment">// 상자 내부</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span> &amp;&amp; d[nx][ny] == <span class="number">-1</span>) <span class="comment">// 안익은 토마토이고 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny));</span><br><span class="line">d[nx][ny] = d[x][y] + <span class="number">1</span>; <span class="comment">// 토마토의 초기 위치는 0, 다음 위치는 +1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 모두 익는 일수</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; d[i][j]) <span class="comment">// 최댓값을 구함(모두 익는 날짜)</span></span><br><span class="line">ans = d[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">0</span> &amp;&amp; d[i][j] == <span class="number">-1</span>) <span class="comment">// 모든 토마토가 익을 수 없는 경우</span></span><br><span class="line">ans = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-7576&quot;&gt;&lt;a href=&quot;#Problem-7576&quot; class=&quot;headerlink&quot; title=&quot;Problem 7576&quot;&gt;&lt;/a&gt;Problem 7576&lt;/h1&gt;&lt;h2 id=&quot;토마토&quot;&gt;&lt;a href=&quot;#토마토&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

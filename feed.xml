<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-03-02T00:51:30.185Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 1774번 수 묶기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1774/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1774/</id>
    <published>2020-03-02T00:51:12.000Z</published>
    <updated>2020-03-02T00:51:30.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1774"><a href="#Problem-1774" class="headerlink" title="Problem 1774"></a>Problem 1774</h1><h2 id="수-묶기"><a href="#수-묶기" class="headerlink" title="수 묶기"></a>수 묶기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.</p><p>예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2<em>3)+(4</em>5) = 27이 되어 최대가 된다.</p><p>수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.</p><p>수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작다. 둘째 줄부터 N개의 줄에, 수열의 각 수가 주어진다. 수열의 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>수를 적절히 묶어 그 합이 최댓값을 출력한다. 정답은 항상 2^31보다 작다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1774" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1774</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>-1<br>2<br>1<br>3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그리디로 우선순위 큐를 사용하여 해결하였다.</li><li>두 수를 곱하여 묶을 수 있으므로 가장 큰 수끼리 먼저 묶는 것이 항상 최댓값이 된다.</li><li>음수와 양수를 담을 우선순위 큐를 각각 사용하여 양수는 최대 힙으로, 음수는 최소 힙으로 구현한다.<ul><li>절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있으므로 음수는 최소 힙으로 구현하였고</li><li>음수 중 절댓값이 가장 작은 수가 남은 경우 0과 곱하면 더 크게 만들 수 있으므로 0도 음수 큐에 포함시킨다.</li></ul></li><li>각각 큐에서 두 개씩 뽑아 곱한 값이 더한 값보다 크다면 곱한 값을 누적하고 아니라면 더한 값을 누적하여 답을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">// 양수를 담을 우선순위 큐</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; mq; <span class="comment">// 음수를 담을 우선순위 큐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 양수와 음수를 구분하여 우선순위 큐에 담음 0은 음수에 포함</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">if</span> (m &gt; <span class="number">0</span>)</span><br><span class="line">pq.push(m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mq.push(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="comment">// 양수 큐에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"><span class="keyword">int</span> y = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x * y &gt;= x + y) <span class="comment">// 큰 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면</span></span><br><span class="line">ans += x * y; <span class="comment">// 곱한 값 누적</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pq.empty()) <span class="comment">// 양수 큐의 수가 홀수 개라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = pq.top(); <span class="comment">// 남은 수 처리</span></span><br><span class="line">pq.pop();</span><br><span class="line">ans += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="comment">// 음수 큐에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = mq.top();</span><br><span class="line">mq.pop();</span><br><span class="line"><span class="keyword">int</span> y = mq.top();</span><br><span class="line">mq.pop();</span><br><span class="line"> <span class="comment">// 절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있음</span></span><br><span class="line"><span class="keyword">if</span> (x * y &gt;= x + y) <span class="comment">// 작은 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면</span></span><br><span class="line">ans += x * y; <span class="comment">// 곱한 값 누적</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mq.empty()) <span class="comment">// 음수 큐의 원소가 홀수 개라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = mq.top(); <span class="comment">// 남은 수 처리</span></span><br><span class="line">mq.pop();</span><br><span class="line">ans += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1774&quot;&gt;&lt;a href=&quot;#Problem-1774&quot; class=&quot;headerlink&quot; title=&quot;Problem 1774&quot;&gt;&lt;/a&gt;Problem 1774&lt;/h1&gt;&lt;h2 id=&quot;수-묶기&quot;&gt;&lt;a href=&quot;#수-묶기&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1780번 종이의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/01/algorithm1780/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/01/algorithm1780/</id>
    <published>2020-03-01T11:39:25.000Z</published>
    <updated>2020-03-01T11:39:39.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1780"><a href="#Problem-1780" class="headerlink" title="Problem 1780"></a>Problem 1780</h1><h2 id="종이의-개수"><a href="#종이의-개수" class="headerlink" title="종이의 개수"></a>종이의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다. 우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다.</p><p>만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.<br>(1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.<br>이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1≤N≤3^7, N은 3^k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1780" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1780</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>9<br>0 0 0 1 1 1 -1 -1 -1<br>0 0 0 1 1 1 -1 -1 -1<br>0 0 0 1 1 1 -1 -1 -1<br>1 1 1 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0<br>0 1 -1 0 1 -1 0 1 -1<br>0 -1 1 0 1 -1 0 1 -1<br>0 1 -1 1 0 -1 0 1 -1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>10<br>12<br>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>분할 정복으로 재귀 함수를 통해 해결하였다.</li><li>종이의 전체를 확인하고 모두 같지 않다면 9개로 분할하여 다시 확인하는 것을 반복한다.</li><li>(x, y) : 종이의 시작점(가장왼쪽 가장위), n : 종이의 크기 를 인자로 가지는 함수로<ul><li>모든 칸이 같은 수라면 해당 수의 개수를 +1하고 리턴,</li><li>같지 않다면 (x, y)를 (x + n, y + n)까지 n / 3 만큼씩 증가시키며 재귀를 수행한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2187</span>][<span class="number">2187</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 현재 종이의 모든 칸이 같은지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] != a[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// (x, y) : 종이의 시작점(가장왼쪽 가장위), n : 종이의 크기</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (same(x, y, n)) <span class="comment">// 모든 칸이 같은 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>)</span><br><span class="line">cnt[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x][y] == <span class="number">1</span>)</span><br><span class="line">cnt[<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cnt[<span class="number">2</span>]++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 모든 같이 같지 않으면 다시 분할하여 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + n; i += n / <span class="number">3</span>) <span class="comment">// 전체를 9분할하여 모두 확인</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j += n / <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">div(i, j, n / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">div(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1780&quot;&gt;&lt;a href=&quot;#Problem-1780&quot; class=&quot;headerlink&quot; title=&quot;Problem 1780&quot;&gt;&lt;/a&gt;Problem 1780&lt;/h1&gt;&lt;h2 id=&quot;종이의-개수&quot;&gt;&lt;a href=&quot;#종이의-개수&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16929번 Two Dots</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/</id>
    <published>2020-02-17T03:24:28.000Z</published>
    <updated>2020-02-17T03:25:57.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16929"><a href="#Problem-16929" class="headerlink" title="Problem 16929"></a>Problem 16929</h1><h2 id="Two-Dots"><a href="#Two-Dots" class="headerlink" title="Two Dots"></a>Two Dots</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>Two Dots는 Playdots, Inc.에서 만든 게임이다. 게임의 기초 단계는 크기가 N×M인 게임판 위에서 진행된다.</p><p>각각의 칸은 색이 칠해진 공이 하나씩 있다. 이 게임의 핵심은 같은 색으로 이루어진 사이클을 찾는 것이다.</p><p>다음은 위의 게임판에서 만들 수 있는 사이클의 예시이다.</p><p>점 k개 d1, d2, …, dk로 이루어진 사이클의 정의는 아래와 같다.</p><ul><li>모든 k개의 점은 서로 다르다.</li><li>k는 4보다 크거나 같다.</li><li>모든 점의 색은 같다.</li><li>모든 1 ≤ i ≤ k-1에 대해서, di와 di+1은 인접하다. 또, dk와 d1도 인접해야 한다. 두 점이 인접하다는 것은 각각의 점이 들어있-는 칸이 변을 공유한다는 의미이다.</li></ul><p>게임판의 상태가 주어졌을 때, 사이클이 존재하는지 아닌지 구해보자.</p><p>2 ≤ N, M ≤ 50</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판의 크기 N, M이 주어진다. 둘째 줄부터 N개의 줄에 게임판의 상태가 주어진다. 게임판은 모두 점으로 가득차 있고, 게임판의 상태는 점의 색을 의미한다. 점의 색은 알파벳 대문자 한 글자이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>사이클이 존재하는 경우에는 “Yes”, 없는 경우에는 “No”를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 4<br>AAAA<br>ABCA<br>AAAA</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>Yes</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 4<br>AAAA<br>ABCA<br>AADA</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>No</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>Yes</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>Yes</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>No</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>문제에서 주어진 조건에 맞는 사이클이 형성되는지 찾는 문제이다. dfs를 통해 해결할 수 있다.</p></li><li><p>방문 여부를 체크할 배열과 탐색을 시작한 점부터 이동한 거리를 나타낼 배열을 선언한다.</p></li><li><p>인접한 같은 색깔의 점인 경우 dfs를 수행한다.</p><ul><li>이때, 사이클을 이루는지 여부를 확인하는 방법은 다음과 같다.<ul><li>cnt변수를 탐색을 진행할 때마다 1씩 증가시킨다.</li><li>처음 방문하게 되는 점의 dist배열에 현재 cnt를 저장한다.</li><li>재귀를 수행할 때 이미 방문했던 노드이며, cnt - dist[x][y] &gt;= 4 인 경우 사이클이 형성된다.</li></ul></li></ul></li><li><p>사이클이 형성되지 않는 경우</p></li></ul><p><img src="https://kyu9341.github.io/img/cycle2.png" alt="cycle"></p><ul><li>사이클이 형성되는 경우</li></ul><p><img src="https://kyu9341.github.io/img/cycle1.png" alt="cycle"></p><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> color[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">// 시작점부터 이동한 거리</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 게임판의 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check[x][y]) <span class="comment">// 이미 방문했던 노드인데</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt - dist[x][y] &gt;= <span class="number">4</span>) <span class="comment">// 이동 횟수에서 현재 위치에 저장된 시작점과의 거리 차가 4 이상 = 싸이클</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line">dist[x][y] = cnt; <span class="comment">// 현재 x,y가 시작점에서 몇번 이동했는지 저장, 시작점은 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (color[nx][ny] == color[x][y]) <span class="comment">// 같은 색깔의 점인 경우(방문여부는 관계x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(nx, ny, cnt + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">color[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"No"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>))</span><br><span class="line">ans = <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16929&quot;&gt;&lt;a href=&quot;#Problem-16929&quot; class=&quot;headerlink&quot; title=&quot;Problem 16929&quot;&gt;&lt;/a&gt;Problem 16929&lt;/h1&gt;&lt;h2 id=&quot;Two-Dots&quot;&gt;&lt;a href=&quot;#T
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1707번 이분 그래프</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/</id>
    <published>2020-02-15T11:05:15.000Z</published>
    <updated>2020-02-16T04:44:13.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1707"><a href="#Problem-1707" class="headerlink" title="Problem 1707"></a>Problem 1707</h1><h2 id="이분-그래프"><a href="#이분-그래프" class="headerlink" title="이분 그래프"></a>이분 그래프</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.</p><p>그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V(1≤V≤20,000)와 간선의 개수 E(1≤E≤200,000)가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호가 빈 칸을 사이에 두고 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1707" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1707</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2<br>3 2<br>1 3<br>2 3<br>4 4<br>1 2<br>2 3<br>3 4<br>4 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>YES<br>NO</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그래프를 다음과 같이 A와 B로 나눌 수 있으면 <strong>이분 그래프</strong> 라고 한다.</li></ul><p><img src="https://kyu9341.github.io/img/bipartite_graph.png" alt="bipartite_graph"></p><ul><li>A에 포함된 정점끼리 연결된 간선이 없음</li><li>B에 포함된 정점끼리 연결된 간선이 없음</li><li>모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에</li></ul><hr><ul><li><p>check배열을 bool타입 대신 int형으로 선언하여 방문하지 않은 노드는 0, 방문한 노드인데 1번 그룹이라면 1, 2번 그룹이라면 2로 저장한다.</p><ul><li>(dfs or bfs)를 통해 탐색을 수행하며 다음 노드로 넘어가면 그룹을 바꿔서 지정해준다. 이때 다음에 방문한 노드가 같은 그룹에 속한 노드라면 이분 그래프가 아니다.</li></ul></li><li><p>(dfs or bfs)에서 다음 노드가 방문하지 않은 노드라면 다음 노드로 재귀 호출하며 현재 1번 그룹이라면 다음은 2번을 넘겨주고 현재 2번이라면 1번을 넘겨준다.</p></li><li><p>다음 노드가 방문을 했던 노드인데 현재 노드와 같은 그룹이라면 이분 그래프가 아니다.</p></li><li><p>각 테스트케이스를 시작할 때마다 인접 노드와 방문 내역을 초기화 해야한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">20001</span>];</span><br><span class="line"><span class="keyword">int</span> check[<span class="number">20001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 0 : 방문 x, 1 : 1번 그룹에 포함, 2 : 2번 그룹에 포함</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c)</span> <span class="comment">// c : 다음 방문할 노드의 그룹 ( 1 or 2 ) , 이분그래프이면 true, 아니면 false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = c; <span class="comment">// c 그룹 방문 처리</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i]; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (!check[next]) <span class="comment">// 다음 정점을 방문 안했으면 동작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dfs(next, <span class="number">3</span> - c)) <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// false를 리턴받았으면 false리턴</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[next] == check[node]) <span class="comment">// 다음 정점이 이미 방문했던 정점인데 현재 정점과 같은 그룹이면 이분그래프가 아님</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">check[start] = c; <span class="comment">// 그룹 지정</span></span><br><span class="line">q.push(start); <span class="comment">// 첫 노드 push</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">3</span> - check[node];</span><br><span class="line">check[next] = c; <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1로 방문 처리</span></span><br><span class="line">q.push(next); <span class="comment">// 방문처리하며 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[node] == check[next])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].<span class="built_in">clear</span>(); <span class="comment">// 인접 노드 초기화</span></span><br><span class="line">check[i] = <span class="number">0</span>; <span class="comment">// 방문 내역 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">a[n].push_back(m);</span><br><span class="line">a[m].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) <span class="comment">// 모든 정점을 확인하여 이분 그래프가 아닌 경우가 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="number">0</span>) <span class="comment">// 아직 방문 안한 노드에 대해서 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bfs(i, <span class="number">1</span>) == <span class="literal">false</span>) <span class="comment">// dfs(i, 1) 도 가능</span></span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1707&quot;&gt;&lt;a href=&quot;#Problem-1707&quot; class=&quot;headerlink&quot; title=&quot;Problem 1707&quot;&gt;&lt;/a&gt;Problem 1707&lt;/h1&gt;&lt;h2 id=&quot;이분-그래프&quot;&gt;&lt;a href=&quot;#이분-그래프&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2309번 일곱 난쟁이</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm2309/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm2309/</id>
    <published>2020-02-15T10:30:51.000Z</published>
    <updated>2020-02-29T15:07:16.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2309"><a href="#Problem-2309" class="headerlink" title="Problem 2309"></a>Problem 2309</h1><h2 id="일곱-난쟁이"><a href="#일곱-난쟁이" class="headerlink" title="일곱 난쟁이"></a>일곱 난쟁이</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.</p><p>아홉 명의 난쟁이는 모두 자신이 “백설 공주와 일곱 난쟁이”의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.</p><p>아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2309" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2309</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20<br>7<br>23<br>19<br>10<br>15<br>25<br>8<br>13</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>7<br>8<br>10<br>13<br>19<br>20<br>23</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>9명의 난쟁이 중 7명의 키의 합이 100인 경우를 구하는 문제이다.</li><li>9명 중 7명을 선택하는 경우의 수는 9C7 = 9C2 = (9<em>8)/(2</em>1) = 36이다.</li><li>브루트 포스 알고리즘을 이용하여 풀이한다.</li><li>이때, 출력을 오름차순으로 하라고 했으므로 미리 입력받은 배열을 오름차순으로 정렬한다.</li><li>먼저 난쟁이의 모든 키를 더해 sum에 저장한 후,<ul><li>두 난쟁이를 선택하여 두 난쟁이의 키를 sum에서 빼 100이 나오는지 판별한다.<ul><li>100이 나온 경우 현재 선택된 두 난쟁이를 제외한 나머지 난쟁이들의 키를 모두 출력한다.</li></ul></li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>[i];</span><br><span class="line">sum += <span class="built_in">height</span>[i]; <span class="comment">// 먼저 모든 난쟁이의 키를 더한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(<span class="built_in">height</span>, <span class="built_in">height</span> + <span class="number">9</span>); <span class="comment">// 오름차순으로 출력하기 때문에 먼저 정렬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum - <span class="built_in">height</span>[i] - <span class="built_in">height</span>[j] == <span class="number">100</span>) <span class="comment">// 9가지중 2가지를 골라 위에서 sum에서 빼서 100이 나오는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k == i || k == j) <span class="keyword">continue</span>; <span class="comment">// 뺀 난쟁이는 출력안함</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">height</span>[k] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 출력 후 프로그램 종료</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2309&quot;&gt;&lt;a href=&quot;#Problem-2309&quot; class=&quot;headerlink&quot; title=&quot;Problem 2309&quot;&gt;&lt;/a&gt;Problem 2309&lt;/h1&gt;&lt;h2 id=&quot;일곱-난쟁이&quot;&gt;&lt;a href=&quot;#일곱-난쟁이&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2225번 합분해</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm2225/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm2225/</id>
    <published>2020-02-14T13:30:51.000Z</published>
    <updated>2020-02-29T15:04:58.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2225"><a href="#Problem-2225" class="headerlink" title="Problem 2225"></a>Problem 2225</h1><h2 id="합분해"><a href="#합분해" class="headerlink" title="합분해"></a>합분해</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.</p><p>덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2225" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2225</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>21</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[k][N] = 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수</li><li>o + o + o + … + <strong>L</strong> = N  –&gt; <strong>L</strong> 의 자리에 올 수 있는 수 : 0 ~ N<ul><li>[ N - L ] + <strong>L</strong> = N</li><li>[ k - 1개 ] + 1개 = k<pre><code>- 따라서, d[k - 1][n - L]의 모든 경우에 L을 더해주면 d[k][n]을 구할 수 있다.  - 즉, d[k - 1][n - L]의 모든 경우를 합친 수가 d[k][n]의 경우의 수가 되는 것이다.</code></pre></li></ul></li><li>d[k][n] = sum(d[k - 1][n - L])<ul><li>0 &lt;= L &lt;= N</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k; <span class="comment">// n이하의 정수 k개를 더해 n을 만드는 경우의 수</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="comment">// 1개의 정수로 n을 만드는 경우는 모두 1</span></span><br><span class="line">d[<span class="number">1</span>][i] = <span class="number">1</span>; <span class="comment">// 초기값 설정</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= j; l++)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j - l]; <span class="comment">// d[k][n] = sum(d[k - 1][n - L])</span></span><br><span class="line">d[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[k][n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2225&quot;&gt;&lt;a href=&quot;#Problem-2225&quot; class=&quot;headerlink&quot; title=&quot;Problem 2225&quot;&gt;&lt;/a&gt;Problem 2225&lt;/h1&gt;&lt;h2 id=&quot;합분해&quot;&gt;&lt;a href=&quot;#합분해&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1912번 연속합</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm1912/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm1912/</id>
    <published>2020-02-14T10:30:51.000Z</published>
    <updated>2020-02-29T15:02:59.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1912"><a href="#Problem-1912" class="headerlink" title="Problem 1912"></a>Problem 1912</h1><h2 id="연속합"><a href="#연속합" class="headerlink" title="연속합"></a>연속합</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p><p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 답을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1912" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1912</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10<br>10 -4 3 1 5 6 -35 12 21 -1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>33</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = i번째 수로 끝나는 가장 큰 연속합</li><li>d[1] 부터 이전 수까지의 최대 연속합(d[i - 1] + a[i])과 현재 수열의 원소(a[i])와 비교하여 더 큰 값을 d[i]에 저장한다.<ul><li>d[i] = max(d[i-1]+a[i], a[i]) 의 과정을 n까지 반복한다.</li></ul></li><li>d[i]의 최댓값을 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">100001</span>]; <span class="comment">// d[i] = i번째 수로 끝나는 가장 큰 연속합</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">d[<span class="number">1</span>] = a[<span class="number">1</span>]; <span class="comment">// 초기값 지정</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; d[i - <span class="number">1</span>] + a[i]) <span class="comment">// 현재 수열의 값과 이어지는 연속합과의 합과 비교</span></span><br><span class="line">d[i] = a[i];<span class="comment">// 더 큰 값을 d[i]에 저장</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="built_in">max</span>)<span class="comment">// d[i] 의 최댓값이 정답</span></span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1912&quot;&gt;&lt;a href=&quot;#Problem-1912&quot; class=&quot;headerlink&quot; title=&quot;Problem 1912&quot;&gt;&lt;/a&gt;Problem 1912&lt;/h1&gt;&lt;h2 id=&quot;연속합&quot;&gt;&lt;a href=&quot;#연속합&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1699번 제곱수의 합</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm1699/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm1699/</id>
    <published>2020-02-14T10:30:51.000Z</published>
    <updated>2020-02-29T15:12:00.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1699"><a href="#Problem-1699" class="headerlink" title="Problem 1699"></a>Problem 1699</h1><h2 id="제곱수의-합"><a href="#제곱수의-합" class="headerlink" title="제곱수의 합"></a>제곱수의 합</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=3^2+1^2+1^2(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=2^2+2^2+1^2+1^2+1^2(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.</p><p>주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1699" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1699</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = 자연수 i를 제곱수들의 합으로 표현하는 최소 항의 개수<ul><li>o + o + o + … + o = n</li><li>[ n - i^2 ] + i^2 = n<ul><li>d[n] =  n - i^2의 최소 개수 + 1</li></ul></li></ul></li><li>d[n] = min(d[n - i * i]) + 1 // (1 &lt;= i * i &lt;= n) –&gt; (1 &lt;= i &lt;= 루트n)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// int d[100001];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// (n - i^2) + i^2 = n -&gt; d[n] =  n - i^2의 최소 개수 + 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = i; <span class="comment">// 모두 1^2으로 표현하는 경우가 최대</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; j++) <span class="comment">// d[n] = min(d[n - i*i]) + 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; d[i - j * j] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i - j * j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1699&quot;&gt;&lt;a href=&quot;#Problem-1699&quot; class=&quot;headerlink&quot; title=&quot;Problem 1699&quot;&gt;&lt;/a&gt;Problem 1699&lt;/h1&gt;&lt;h2 id=&quot;제곱수의-합&quot;&gt;&lt;a href=&quot;#제곱수의-합&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14002번 가장 긴 증가하는 부분 수열 4 (LIS)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/</id>
    <published>2020-02-14T01:32:18.000Z</published>
    <updated>2020-02-24T13:16:07.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14002"><a href="#Problem-14002" class="headerlink" title="Problem 14002"></a>Problem 14002</h1><h2 id="가장-긴-증가하는-부분-수열-4-LIS"><a href="#가장-긴-증가하는-부분-수열-4-LIS" class="headerlink" title="가장 긴 증가하는 부분 수열 4 (LIS)"></a>가장 긴 증가하는 부분 수열 4 (LIS)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p><p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p><p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p><p>둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14002" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14002</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6<br>10 20 10 30 20 50</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = a[1], … a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</li><li>i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i] = d[j] + 1</li></ul><table><thead><tr><th align="center"><strong><center>i</center></strong></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th></tr></thead><tbody><tr><td align="center"><strong>a[i]</strong></td><td align="center">10</td><td align="center">20</td><td align="center">10</td><td align="center">30</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center"><strong>d[i]</strong></td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">2</td><td align="center">4</td></tr><tr><td align="center"><strong>v[i]</strong></td><td align="center">-1</td><td align="center">1</td><td align="center">-1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table><ul><li>모든 d[i] 중 최댓값을 구한다.</li><li>이 문제에서는 LIS의 길이 뿐 아니라 LIS의 원소까지 출력을 해야한다.</li><li>이전 LIS문제와 같은 방식으로 푸는데, 역추적을 위한 배열을 만들어 LIS에 연결되는 인덱스를 저장한다.<ul><li>즉, d의 값이 어느 인덱스에 의해 변하는지를 저장한 후 역추적을 통해 출력하는 방식이다.</li><li>또한 p라는 변수에 LIS의 마지막 인덱스를 넣는다. 즉, 최댓값을 가지는 인덱스에서 역추적을 시작한다.</li><li>역추적을 재귀함수를 통해 구현하였지만 스택을 사용하거나 그냥 v에 저장된 인덱스로 a[v[i]]와 같은 배열을 만들어 오름차순 정렬하여 출력해도 무방하다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// LIS 문제</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1001</span>]; <span class="comment">// 역추적을 위한 배열</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>]; <span class="comment">// d[i] = a[1], ... a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 수열의 크기</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 수열 입력</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>; <span class="comment">// 역추적을 시작할 인덱스</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = <span class="number">1</span>; <span class="comment">// 모든 d[i]의 초기값은 1</span></span><br><span class="line">v[i] = <span class="number">-1</span>; <span class="comment">// 초기값은 -1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;<span class="comment">// 수열의 마지막 항이 더 크면서</span></span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; d[j] + <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) <span class="comment">// i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i]</span></span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">v[i] = j; <span class="comment">// 연결되는 인덱스를 저장 / 즉, d의 값이 어느 인덱스에 의해 변하는지 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; d[i]) <span class="comment">// 모든 d[i] 중 최댓값이 정답</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">p = i; <span class="comment">// 최댓값을 가지는 인덱스에서 역추적 시작</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">go(p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// 역추적 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">go(v[p]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[p] &lt;&lt; <span class="string">' '</span>; <span class="comment">// 역순으로 a값 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14002&quot;&gt;&lt;a href=&quot;#Problem-14002&quot; class=&quot;headerlink&quot; title=&quot;Problem 14002&quot;&gt;&lt;/a&gt;Problem 14002&lt;/h1&gt;&lt;h2 id=&quot;가장-긴-증가하는-부분-수열-4-LIS
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11053번 가장 긴 증가하는 부분 수열(LIS)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/13/algorithm11053/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/13/algorithm11053/</id>
    <published>2020-02-13T01:32:18.000Z</published>
    <updated>2020-02-24T13:16:00.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11053"><a href="#Problem-11053" class="headerlink" title="Problem 11053"></a>Problem 11053</h1><h2 id="가장-긴-증가하는-부분-수열-LIS"><a href="#가장-긴-증가하는-부분-수열-LIS" class="headerlink" title="가장 긴 증가하는 부분 수열(LIS)"></a>가장 긴 증가하는 부분 수열(LIS)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p><p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p><p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11053" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11053</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6<br>10 20 10 30 20 50</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = a[1], … a[i] 까지 있을 때, a[i]를 가장 마지막 수로 하는 LIS의 길이</li><li>i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i] = d[j] + 1</li></ul><table><thead><tr><th align="center"><strong><center>i</center></strong></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th></tr></thead><tbody><tr><td align="center"><strong>a[i]</strong></td><td align="center">10</td><td align="center">20</td><td align="center">10</td><td align="center">30</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center"><strong>d[i]</strong></td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">2</td><td align="center">4</td></tr></tbody></table><ul><li>모든 d[i] 중 최댓값을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// LIS 문제</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>]; <span class="comment">// d[i] = a[1], ... a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 수열의 크기</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 수열 입력</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 초기값 지정 수열의 크기가 1이면 LIS는 1</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = <span class="number">1</span>; <span class="comment">// 모든 d[i]의 초기값은 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;<span class="comment">// 수열의 마지막 항이 더 크면서</span></span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; d[j] + <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) <span class="comment">// i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i]</span></span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; d[i]) <span class="comment">// 모든 d[i] 중 최댓값이 정답</span></span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11053&quot;&gt;&lt;a href=&quot;#Problem-11053&quot; class=&quot;headerlink&quot; title=&quot;Problem 11053&quot;&gt;&lt;/a&gt;Problem 11053&lt;/h1&gt;&lt;h2 id=&quot;가장-긴-증가하는-부분-수열-LIS&quot;&gt;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2193번 이친수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/11/algorithm2193/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/11/algorithm2193/</id>
    <published>2020-02-11T11:32:18.000Z</published>
    <updated>2020-02-24T12:58:03.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2193"><a href="#Problem-2193" class="headerlink" title="Problem 2193"></a>Problem 2193</h1><h2 id="이친수"><a href="#이친수" class="headerlink" title="이친수"></a>이친수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.</p><ol><li>이친수는 0으로 시작하지 않는다.</li><li>이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.</li></ol><p>예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.</p><p>N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 N자리 이친수의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2193" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2193</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[i][j] = 이전 수가 j인 i자리 이친수의 개수</li><li>d[i-1][0]의 뒤에 올 수 있는 수는 0, 1 /  d[i-1][1]뒤에 올 수 있는 수는 0뿐<ul><li>d[i][0] = d[i - 1][0] + d[i - 1][1]</li><li>d[i][1] = d[i - 1][0]</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">91</span>][<span class="number">2</span>]; <span class="comment">// d[i][j] = 이전 수가 j인 i자리 이친수의 개수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 0으로 시작하는 수는 이친수가 아님</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">0</span>] = d[i - <span class="number">1</span>][<span class="number">0</span>] + d[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">d[i][<span class="number">1</span>] = d[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n][<span class="number">0</span>] + d[n][<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2193&quot;&gt;&lt;a href=&quot;#Problem-2193&quot; class=&quot;headerlink&quot; title=&quot;Problem 2193&quot;&gt;&lt;/a&gt;Problem 2193&lt;/h1&gt;&lt;h2 id=&quot;이친수&quot;&gt;&lt;a href=&quot;#이친수&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 10844번 쉬운 계단 수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/11/algorithm10844/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/11/algorithm10844/</id>
    <published>2020-02-11T01:32:18.000Z</published>
    <updated>2020-02-28T02:40:07.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-10844"><a href="#Problem-10844" class="headerlink" title="Problem 10844"></a>Problem 10844</h1><h2 id="쉬운-계단-수"><a href="#쉬운-계단-수" class="headerlink" title="쉬운 계단 수"></a>쉬운 계단 수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>45656이란 수를 보자.</p><p>이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.</p><p>세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.</p><p>N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/10844" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/10844</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>9</p><h3 id="solve-first"><a href="#solve-first" class="headerlink" title="solve first"></a>solve first</h3><ul><li><p>점화식 d[i][j] = 길이가 i인 계단 수의 총 개수, 이전 수의 맨 마지막 수 = j</p></li><li><p>(i != 1) =&gt; (0 &lt;= j &lt;= 9)  -&gt; i = 1일때 예외처리</p></li><li><p>j = 0 or j = 9 이면 다음에 올 수 있는 수는 1, 8 뿐</p></li><li><p>1 ~ 8은 j + 1, j - 1이 올 수 있음</p><ul><li>ex) d[2][1] = sum(d[2 - 1][j])</li><li>ex) d[2][2] = sum(d[2 - 1][j]) * 2</li></ul></li><li><p>첫 번째 코드</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000000</span>;</span><br><span class="line"><span class="comment">// 점화식 d[i][j] = 길이가 i인 계단 수의 총 개수, 이전 수의 맨 마지막 수 = j</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">101</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">d[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || j == <span class="number">9</span>) <span class="comment">// 0 또는 9인 경우에는 다음에 올 수 있는 수는 1, 8뿐이므로 한번만 더해줌</span></span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 1 ~ 8의 수 다음에는 j - 1, j + 1이 올 수 있으므로 두 배로 더해줌</span></span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> d[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">result += d[n][j];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solve-second"><a href="#solve-second" class="headerlink" title="solve second"></a>solve second</h3></li><li><p>위와 같이 하니 예제 입출력의 테스트케이스는 맞지만 틀렸다고 나옴.</p></li><li><p>생각해보니 단순히 j가 0이나 9일 때에 한 번만 더하고 두 번만 더하는 것이 잘못되었음</p><ul><li>정확히 0일때는 이전 수가 1인 경우 즉, d[i-1][j+1]인 경우를 더해줘야 하고</li><li>9일때는 이전 수가 8 인 경우 즉, d[i-1][j-1]인 경우를 더해주어야 한다.</li><li>또한 j가 1 ~ 8 인 경우에는 d[i-1][j-1]과 d[i-1][j+1] 모두를 더해주어야 한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000000</span>;</span><br><span class="line"><span class="comment">// 점화식 d[i][j] = 길이가 i인 계단 수의 총 개수, 이전 수의 맨 마지막 수 = j</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">101</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">d[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// d[i][j] = 0;</span></span><br><span class="line"><span class="keyword">if</span> (j &lt;= <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> d[i][j] %= mod; <span class="comment">// 미리 나머지로 바꿔주어야 정수 범위내에서 연산 가능</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) <span class="comment">// n의 모든 경우를 누적</span></span><br><span class="line">result += d[n][j];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; result % mod &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-10844&quot;&gt;&lt;a href=&quot;#Problem-10844&quot; class=&quot;headerlink&quot; title=&quot;Problem 10844&quot;&gt;&lt;/a&gt;Problem 10844&lt;/h1&gt;&lt;h2 id=&quot;쉬운-계단-수&quot;&gt;&lt;a href=&quot;#쉬운
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 15990번 1, 2, 3 더하기 5</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/10/algorithm15990/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/10/algorithm15990/</id>
    <published>2020-02-10T01:32:18.000Z</published>
    <updated>2020-02-24T12:56:42.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-15990"><a href="#Problem-15990" class="headerlink" title="Problem 15990"></a>Problem 15990</h1><h2 id="1-2-3-더하기-5"><a href="#1-2-3-더하기-5" class="headerlink" title="1, 2, 3 더하기 5"></a>1, 2, 3 더하기 5</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.</p><ul><li>1+2+1</li><li>1+3</li><li>3+1<br>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/15990" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/15990</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>4<br>7<br>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>9<br>27</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>같은 수를 두 번 이상 연속해서 사용하면 안된다.<ul><li>(연속, 증가, 감소) 등의 조건이 나오면 두 개씩 나누어 풀이한다.</li></ul></li><li>d[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j<ul><li>d[i][1] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 1<ul><li>바로 전에 사용할 수 있는 수는 2, 3 =&gt; d[i - 1][2] + d[i - 1][3]</li></ul></li><li>d[i][2] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 2<ul><li>바로 전에 사용할 수 있는 수는 2, 3 =&gt; d[i - 2][1] + d[i - 2][3]</li></ul></li><li>d[i][3] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 3<ul><li>바로 전에 사용할 수 있는 수는 2, 3 =&gt; d[i - 3][1] + d[i - 3][2]</li></ul></li></ul></li><li>d[0] = 1 처럼 d[0][1], d[0][2], d[0][3]을 1로 초기화하면 중복이 발생<ul><li>d[1][1] = d[0][2] + d[0][3] = 2 (1로 끝나는데 1을 만드는 경우는 1뿐)</li><li>예외 처리를 해주어야 함.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">100001</span>][<span class="number">4</span>]; <span class="comment">// d[i][j] = i를 1, 2, 3의 합으로 나타내는 방법의 수, 마지막에 사용한 수는 j</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000009</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum123_bottom_up(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">1</span>] = d[i - <span class="number">1</span>][<span class="number">2</span>] + d[i - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">d[i][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 1로 끝나는데 1을 만드는 경우는 1뿐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">2</span>] = d[i - <span class="number">2</span>][<span class="number">1</span>] + d[i - <span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">d[i][<span class="number">2</span>] = <span class="number">1</span>;  <span class="comment">// 2로 끝나는데 2을 만드는 경우는 2뿐</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">3</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d[i][<span class="number">3</span>] = d[i - <span class="number">3</span>][<span class="number">1</span>] + d[i - <span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">3</span>)</span><br><span class="line">d[i][<span class="number">3</span>] = <span class="number">1</span>; <span class="comment">// 3으로 끝나는데 3을 만드는 경우는 3뿐</span></span><br><span class="line">&#125;</span><br><span class="line">d[i][<span class="number">1</span>] %= mod; <span class="comment">// 정수 범위를 초과하기</span></span><br><span class="line">d[i][<span class="number">2</span>] %= mod;</span><br><span class="line">d[i][<span class="number">3</span>] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (d[n][<span class="number">1</span>] + d[n][<span class="number">2</span>] + d[n][<span class="number">3</span>]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-15990&quot;&gt;&lt;a href=&quot;#Problem-15990&quot; class=&quot;headerlink&quot; title=&quot;Problem 15990&quot;&gt;&lt;/a&gt;Problem 15990&lt;/h1&gt;&lt;h2 id=&quot;1-2-3-더하기-5&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11052번 카드 구매하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/09/algorithm11052/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/09/algorithm11052/</id>
    <published>2020-02-09T10:32:18.000Z</published>
    <updated>2020-02-24T12:49:15.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11052"><a href="#Problem-11052" class="headerlink" title="Problem 11052"></a>Problem 11052</h1><h2 id="카드-구매하기"><a href="#카드-구매하기" class="headerlink" title="카드 구매하기"></a>카드 구매하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.</p><p>PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 아이디와 얼굴이 적혀있는 카드이다. 각각의 카드에는 등급을 나타내는 색이 칠해져 있고, 다음과 같이 8가지가 있다.</p><ul><li>전설카드</li><li>레드카드</li><li>오렌지카드</li><li>퍼플카드</li><li>블루카드</li><li>청록카드</li><li>그린카드</li><li>그레이카드</li></ul><p>카드는 카드팩의 형태로만 구매할 수 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, … 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재한다.</p><p>민규는 카드의 개수가 적은 팩이더라도 가격이 비싸면 높은 등급의 카드가 많이 들어있을 것이라는 미신을 믿고 있다. 따라서, 민규는 돈을 최대한 많이 지불해서 카드 N개 구매하려고 한다. 카드가 i개 포함된 카드팩의 가격은 Pi원이다.</p><p>예를 들어, 카드팩이 총 4가지 종류가 있고, P1 = 1, P2 = 5, P3 = 6, P4 = 7인 경우에 민규가 카드 4개를 갖기 위해 지불해야 하는 금액의 최댓값은 10원이다. 2개 들어있는 카드팩을 2번 사면 된다.</p><p>P1 = 5, P2 = 2, P3 = 8, P4 = 10인 경우에는 카드가 1개 들어있는 카드팩을 4번 사면 20원이고, 이 경우가 민규가 지불해야 하는 금액의 최댓값이다.</p><p>마지막으로, P1 = 3, P2 = 5, P3 = 15, P4 = 16인 경우에는 3개 들어있는 카드팩과 1개 들어있는 카드팩을 구매해 18원을 지불하는 것이 최댓값이다.</p><p>카드 팩의 가격이 주어졌을 때, N개의 카드를 구매하기 위해 민규가 지불해야 하는 금액의 최댓값을 구하는 프로그램을 작성하시오. N개보다 많은 개수의 카드를 산 다음, 나머지 카드를 버려서 N개를 만드는 것은 불가능하다. 즉, 구매한 카드팩에 포함되어 있는 카드 개수의 합은 N과 같아야 한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)</p><p>둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11052" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11052</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>1 5 6 7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>10</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>5<br>10 9 8 7 6</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>50</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>10<br>1 1 2 3 5 8 13 21 34 55</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>55</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>10<br>5 10 11 12 13 30 35 40 45 47</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>50</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[n] = 카드 n개를 갖기 위해 지불하는 금액의 최댓값</li><li>카드팩 + 카드팩 + 카드팩 + … + <strong>카드팩</strong> = n  –&gt; <strong>카드팩</strong> 은 카드가 몇개? 알수없음 (i개)<ul><li>카드팩 + 카드팩 + 카드팩 + … + -&gt; n - i 개</li><li>d[n - i] + p[i]</li></ul></li><li>즉, d[n] = max(d[n - i] + p[i]) (1 &lt;= i &lt;= n)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p[i]; <span class="comment">// Pi 입력</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// d[n] = max(d[n - i] + p[i]) (1 &lt;= i &lt;= n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = d[i - j] + p[j];</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; temp)</span><br><span class="line">d[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11052&quot;&gt;&lt;a href=&quot;#Problem-11052&quot; class=&quot;headerlink&quot; title=&quot;Problem 11052&quot;&gt;&lt;/a&gt;Problem 11052&lt;/h1&gt;&lt;h2 id=&quot;카드-구매하기&quot;&gt;&lt;a href=&quot;#카드
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 9095번 1, 2, 3 더하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/09/algorithm9095/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/09/algorithm9095/</id>
    <published>2020-02-09T06:32:18.000Z</published>
    <updated>2020-02-24T12:53:44.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-9095"><a href="#Problem-9095" class="headerlink" title="Problem 9095"></a>Problem 9095</h1><h2 id="1-2-3-더하기"><a href="#1-2-3-더하기" class="headerlink" title="1, 2, 3 더하기"></a>1, 2, 3 더하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.</p><ul><li>1+1+1+1</li><li>1+1+2</li><li>1+2+1</li><li>2+1+1</li><li>2+2</li><li>1+3</li><li>3+1</li></ul><p>정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/9095" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/9095</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>4<br>7<br>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>7<br>44<br>274</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[n] = n을 1, 2, 3의 합으로 나타내는 방법의 수</li><li>o + o + o + … + <strong>o</strong> = n  –&gt; <strong>o</strong> 의 자리에 올 수 있는 수 : 1, 2, 3<ul><li>[  합 : n - 1    ] + 1 = n;</li><li>[  합 : n - 2    ] + 2 = n;</li><li>[  합 : n - 3    ] + 3 = n;</li></ul></li><li>d[n] = d[n - 1] + d[n - 2] + d[n - 3]<ul><li>d[0] = 1 // 공집합, 모든 숫자를 0개씩 사용하는 경우 1</li><li>d[1] = 1 // 1</li><li>d[2] = 2 // 1+1, 2</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><ul><li><p>동적 계획법</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">11</span>]; <span class="comment">// n &lt; 11, d[n] = n을 1, 2, 3의 합으로 나타내는 방법의 수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t; <span class="comment">// testcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum123_top_down(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="comment">// d[0] = 1(공집합, 모든 숫자를 0개씩 사용), d[1] = 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="comment">// 1 + 1, 2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 메모되어있으면 리턴</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// d[n] = d[n - 1] + d[n - 2] + d[n - 3]</span></span><br><span class="line">d[n] = sum123_top_down(n - <span class="number">1</span>) + sum123_top_down(n - <span class="number">2</span>) + sum123_top_down(n - <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum123_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] + d[i - <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>부르트 포스(재귀)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; goal) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 1, 2, 3으로 원하는 수를 만들 수 없는 경우</span></span><br><span class="line"><span class="keyword">if</span> (sum == goal) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 만든 경우</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">count += go(sum + i, goal);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(<span class="number">0</span>, n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-9095&quot;&gt;&lt;a href=&quot;#Problem-9095&quot; class=&quot;headerlink&quot; title=&quot;Problem 9095&quot;&gt;&lt;/a&gt;Problem 9095&lt;/h1&gt;&lt;h2 id=&quot;1-2-3-더하기&quot;&gt;&lt;a href=&quot;#1-2-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11727번 2xn 타일링 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11727/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11727/</id>
    <published>2020-02-08T11:32:18.000Z</published>
    <updated>2020-02-24T12:49:29.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11727"><a href="#Problem-11727" class="headerlink" title="Problem 11727"></a>Problem 11727</h1><h2 id="2xn타일링2"><a href="#2xn타일링2" class="headerlink" title="2xn타일링2"></a>2xn타일링2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 직사각형을 1x2와 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11727" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11727</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>8</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>171</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>12</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>2731</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>2xn타일링 문제와 동일하게 진행되지만 2x2타일이 따로 존재한다는 점에서 다음과 같이 진행한다.</li><li>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수<ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li><li><ol start="3"><li>2x2 타일을 하나 붙인다.</li></ol></li></ul></li><li>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수 * 2</li><li>d[n] = d[n - 1] + d[n - 2] * 2</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 2×n 직사각형을 1x2와 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling_top_down(n) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2xn 타일링 문제에서 d[n - 2]인 경우가 두배가 된 것.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_bottom_up</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>] * <span class="number">2</span>; <span class="comment">// d[n] = d[n - 1] + d[n - 2]\*2</span></span><br><span class="line">d[i] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling_top_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling_top_down(n - <span class="number">1</span>) + tiling_top_down(n - <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">d[n] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11727&quot;&gt;&lt;a href=&quot;#Problem-11727&quot; class=&quot;headerlink&quot; title=&quot;Problem 11727&quot;&gt;&lt;/a&gt;Problem 11727&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링2&quot;&gt;&lt;a href=&quot;#2x
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11726번 2xn타일링</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm11726/</id>
    <published>2020-02-08T06:45:13.000Z</published>
    <updated>2020-02-17T15:35:03.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11726"><a href="#Problem-11726" class="headerlink" title="Problem 11726"></a>Problem 11726</h1><h2 id="2xn타일링"><a href="#2xn타일링" class="headerlink" title="2xn타일링"></a>2xn타일링</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.</p><p>아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11726" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11726</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>9</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>55</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>먼저 메모이제이션 할 배열 d[]를 선언한다.</p></li><li><p>점화식 d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</p><ul><li>2xn 크기의 직사각형에 타일을 추가로 붙이는 경우</li><li><ol><li>2x1 타일을 하나 붙인다.</li></ol></li><li><ol start="2"><li>1x2 타일을 두 개 붙인다.</li></ol></li></ul></li><li><p>즉, 2xn 크기의 직사각형을 채우는 방법의 수는</p></li><li><p>2x(n-1)의 직사각형에 2x1타일을 하나 붙이는 경우의 수 + 2x(n-2)의 직사각형에 1x2타일을 두 개 붙이는 경우의 수</p></li><li><p>d[n] = d[n - 1] + d[n - 2]</p></li><li><p>피보나치 수열과 같은 형태로 점화식이 만들어진다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// d[n] = 2xn 크기의 직사각형을 채우는 방법의 수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="comment">// n이 d[1] = 1, d[2] = 2이므로</span></span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 구한 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = tiling(n - <span class="number">1</span>) + tiling(n - <span class="number">2</span>); <span class="comment">// d[n] = d[n - 1] + d[n - 2]</span></span><br><span class="line">d[n] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tiling1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + d[i - <span class="number">2</span>];</span><br><span class="line">d[i] %= <span class="number">10007</span>; <span class="comment">// 10007로 나눈 나머지 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tiling(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11726&quot;&gt;&lt;a href=&quot;#Problem-11726&quot; class=&quot;headerlink&quot; title=&quot;Problem 11726&quot;&gt;&lt;/a&gt;Problem 11726&lt;/h1&gt;&lt;h2 id=&quot;2xn타일링&quot;&gt;&lt;a href=&quot;#2xn
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1676번 팩토리얼 0의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1676/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1676/</id>
    <published>2020-02-08T06:32:18.000Z</published>
    <updated>2020-02-24T12:38:32.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1676"><a href="#Problem-1676" class="headerlink" title="Problem 1676"></a>Problem 1676</h1><h2 id="팩토리얼-0의-개수"><a href="#팩토리얼-0의-개수" class="headerlink" title="팩토리얼 0의 개수"></a>팩토리얼 0의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 구한 0의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1676" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1676</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.<ul><li>(뒤에서부터 연속으로 등장하는 0의 개수이므로)</li></ul></li><li>n!에서는 2의 개수가 항상 5의 개수보다 많으므로 5의 개수만 세어준다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.</span></span><br><span class="line"><span class="comment">// n!에서는 2의 개수가 항상 5의 개수보다 많으므로 5의 개수만 세어준다.</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = i;</span><br><span class="line"><span class="keyword">while</span> (tmp % <span class="number">5</span> == <span class="number">0</span>) <span class="comment">// 5의 개수 count</span></span><br><span class="line">&#123;</span><br><span class="line">tmp /= <span class="number">5</span>; <span class="comment">// 5를 하나 이상 인자로 가지는 수 처리</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1676&quot;&gt;&lt;a href=&quot;#Problem-1676&quot; class=&quot;headerlink&quot; title=&quot;Problem 1676&quot;&gt;&lt;/a&gt;Problem 1676&lt;/h1&gt;&lt;h2 id=&quot;팩토리얼-0의-개수&quot;&gt;&lt;a href=&quot;#팩토리
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1463번 1로 만들기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm1463/</id>
    <published>2020-02-08T05:30:51.000Z</published>
    <updated>2020-02-17T15:24:45.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1463"><a href="#Problem-1463" class="headerlink" title="Problem 1463"></a>Problem 1463</h1><h2 id="1로-만들기"><a href="#1로-만들기" class="headerlink" title="1로 만들기"></a>1로 만들기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p><ol><li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li><li>X가 2로 나누어 떨어지면, 2로 나눈다.</li><li>1을 뺀다.</li></ol><p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1463" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1463</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>10</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>먼저 메모이제이션 할 배열 d[]를 선언한다.</li><li>점화식 d[n] = n을 1로 만드는 최소 연산 횟수 를 정의한다.<ul><li>[n을 n / 3으로 만드는 연산 횟수 : 1번], [n/3을 1로 만드는 연산 횟수 : d[n / 3]번]  //  1번 + d[n / 3]번</li><li>n -&gt; [n / 2] -&gt; 1  //  1번 + d[n / 2]번</li><li>n -&gt; [n - 1] -&gt; 1  //  1번 + d[n - 1]번</li><li>=&gt; d[n] = min(d[n / 3], d[n / 2], d[n - 1]) + 1</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1000001</span>]; <span class="comment">// d[n] : n을 1로 만드는 최소 연산 횟수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// top-down 방식 구현</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 1을 만든 경우 d[1] = 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="comment">// 이미 수행했던 연산인 경우</span></span><br><span class="line"><span class="keyword">return</span> d[n]; <span class="comment">// 메모이제이션</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d[n] = go(n - <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 최솟값을 더 편하게 구하기 위해 먼저 처리</span></span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 2로 나누어 떨어지는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp; <span class="comment">// 새로운 방식이 더 적은 연산을 필요로 하면 바꿔줌</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = go(n / <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (d[n] &gt; temp) d[n] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go1</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// bottom-up 방식</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 초기값 지정</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">2</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; d[i] &gt; d[i / <span class="number">3</span>] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i / <span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; go(x) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1463&quot;&gt;&lt;a href=&quot;#Problem-1463&quot; class=&quot;headerlink&quot; title=&quot;Problem 1463&quot;&gt;&lt;/a&gt;Problem 1463&lt;/h1&gt;&lt;h2 id=&quot;1로-만들기&quot;&gt;&lt;a href=&quot;#1로-만들기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2004번 조합 0의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/08/algorithm2004/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/08/algorithm2004/</id>
    <published>2020-02-08T01:32:18.000Z</published>
    <updated>2020-02-24T12:39:35.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2004"><a href="#Problem-2004" class="headerlink" title="Problem 2004"></a>Problem 2004</h1><h2 id="조합-0의-개수"><a href="#조합-0의-개수" class="headerlink" title="조합 0의 개수"></a>조합 0의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>nCm의 끝자리 0의 개수를 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정수 n, m(0≤m≤n≤2,000,000,000, n!=0)이 들어온다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 0의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2004" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2004</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>25 12</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>팩토리얼의 0의 개수는 n!을 소인수분해하여 나온 2와 5의 개수로 얻을 수 있다.<ul><li>(뒤에서부터 연속으로 등장하는 0의 개수이므로)</li></ul></li><li>nCm = n! / (n-m)!*m!</li><li>조합의 0의 개수는 n!의 0의 개수에서 (n-m)!의 0의 개수와 m!의 0의 개수를 빼주면 된다.</li><li>조합의 0의 개수는 항상 5의 개수가 더 많지 않을 수 있으므로 2와 5의 개수 중 더 작은 값을 구하면 된다.</li><li>범위가 매우 크기 때문에 int형이 아닌 long long 형을 사용한다. (int형 사용시 런타임에러)</li><li>이때 2와 5의 개수를 구하는 방법은 팩토리얼의 0의 개수를 구할 때와는 다르게 구한다.<ul><li>최대 2,000,000,000의 수가 들어오기 때문에 시간 초과가 발생할 수 있음</li><li>n!의 i의 개수를 구한다고 한다면</li><li>먼저 count에 n / i를 더한다.</li><li>n을 i로 나누어도 i^2의 배수들은 i가 남아있기 때문에 count에 n / i^2 을 더한다.</li><li>i^3의 배수같은 경우는 i^2으로 나누어도 i가 남아있기 때문에 count에 n / i^3을 더한다.</li><li>위의 과정을 반복한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; zeros(<span class="keyword">long</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> five = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">5</span>; i &lt;= n; i *= <span class="number">5</span>) <span class="comment">// 5의 개수 카운트</span></span><br><span class="line">five += n / i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n; i *= <span class="number">2</span>) <span class="comment">// 2의 개수 카운트</span></span><br><span class="line">two += n / i;</span><br><span class="line"><span class="keyword">return</span> &#123;two, five&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">long</span> <span class="keyword">long</span>&gt; resM, resN, resNM;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> two = <span class="number">0</span>, five = <span class="number">0</span>;</span><br><span class="line">resM = zeros(m);</span><br><span class="line">resN = zeros(n);</span><br><span class="line">resNM = zeros(n - m);</span><br><span class="line"></span><br><span class="line">two = resN.first - resM.first - resNM.first; <span class="comment">// n의 2의 개수에서 m과 (n-m)의 2의 개수를 빼줌</span></span><br><span class="line">five = resN.second - resM.second - resNM.second;  <span class="comment">// n의 5의 개수에서 m과 (n-m)의 5의 개수를 빼줌</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(two, five) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2004&quot;&gt;&lt;a href=&quot;#Problem-2004&quot; class=&quot;headerlink&quot; title=&quot;Problem 2004&quot;&gt;&lt;/a&gt;Problem 2004&lt;/h1&gt;&lt;h2 id=&quot;조합-0의-개수&quot;&gt;&lt;a href=&quot;#조합-0의
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-03-03T10:04:49.226Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 1939번 중량제한</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm1939/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm1939/</id>
    <published>2020-03-03T09:51:12.000Z</published>
    <updated>2020-03-03T10:04:49.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1939"><a href="#Problem-1939" class="headerlink" title="Problem 1939"></a>Problem 1939</h1><h2 id="중량제한"><a href="#중량제한" class="headerlink" title="중량제한"></a>중량제한</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N(2≤N≤10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.</p><p>영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.</p><p>한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N, M(1≤M≤100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1≤A, B≤N), C(1≤C≤1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 도시 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 답을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1939" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1939</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 2 2<br>3 1 3<br>2 3 2<br>1 3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>제한되는 중량에 대해 이분 탐색을 수행하며 현재 중량을 만족하는 길이 있는지 확인한다.</li><li>dfs를 통해 만족하는 길이 있는지 탐색하여 만족하는 길이 있다면 중량을 증가시키고 없다면 감소시켜 재탐색한다.</li></ul><h2 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>]; <span class="comment">// 방문 여부</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> weight, <span class="keyword">int</span> target)</span> <span class="comment">// dfs를 통해 현재 중량 제한을 만족하는 길이 있는지 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line"><span class="keyword">if</span> (check[target]) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 목표 지점을 찾은 경우</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++) <span class="comment">// 연결된 섬 모두 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i].first;</span><br><span class="line"><span class="keyword">int</span> w = a[node][i].second;</span><br><span class="line"><span class="keyword">if</span> (!check[next] &amp;&amp; w &gt;= weight) <span class="comment">// 중량 제한을 만족하고 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(next, weight, target)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 목표 공장을 찾았다면 true리턴</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 모두 방문했지만 목표 공장을 찾지 못한 경우 false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxWeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 섬과 다리 입력</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">a[u].push_back(make_pair(v, w));</span><br><span class="line">a[v].push_back(make_pair(u, w));</span><br><span class="line"><span class="keyword">if</span> (maxWeight &lt; w) <span class="comment">// 중량 제한의 최댓값 저장</span></span><br><span class="line">maxWeight = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start, <span class="built_in">end</span>; <span class="comment">// 출발 공장, 도착 공장</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; start &gt;&gt; <span class="built_in">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = maxWeight;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 이분 탐색</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(check, <span class="literal">false</span>, <span class="keyword">sizeof</span>(check)); <span class="comment">// check배열 초기화</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 중량 제한</span></span><br><span class="line"><span class="keyword">if</span> (dfs(start, mid, <span class="built_in">end</span>)) <span class="comment">// 현재 중량 제한을 만족하는 길이 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; mid)</span><br><span class="line">ans = mid;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1939&quot;&gt;&lt;a href=&quot;#Problem-1939&quot; class=&quot;headerlink&quot; title=&quot;Problem 1939&quot;&gt;&lt;/a&gt;Problem 1939&lt;/h1&gt;&lt;h2 id=&quot;중량제한&quot;&gt;&lt;a href=&quot;#중량제한&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2805번 나무 자르기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm2805/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm2805/</id>
    <published>2020-03-03T08:51:12.000Z</published>
    <updated>2020-03-03T09:55:35.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2805"><a href="#Problem-2805" class="headerlink" title="Problem 2805"></a>Problem 2805</h1><h2 id="나무-자르기"><a href="#나무-자르기" class="headerlink" title="나무 자르기"></a>나무 자르기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기을 이용해서 나무를 구할것이다.</p><p>목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다)</p><p>상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)</p><p>둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M을 넘기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2805" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2805</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 7<br>20 15 10 17</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>15</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>절단기의 높이 h로 나무를 잘라서 m이상을 만들 수 있는지 확인하는 함수를 만들고</li><li>이분 탐색을 통해 현재 절단기의 높이로 나무의 길이 m을 만들 수 있는지 확인한다.<ul><li>가능하다면 현재 절단기 높이 저장하고 최댓값을 구해야하므로 더 높이 올릴 수 있는지 확인</li><li>불가능하다면 절단기의 높이를 낮춘다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; a, <span class="keyword">long</span> <span class="keyword">long</span> m, <span class="keyword">long</span> <span class="keyword">long</span> h)</span> <span class="comment">// 절단기의 높이 h로 나무를 잘라서 m이상을 만들 수 있는지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] - h &gt; <span class="number">0</span>) <span class="comment">// h 가 나무의 높이보다 높으면 잘리지 않음</span></span><br><span class="line">&#123;</span><br><span class="line">cnt += a[i] - h;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= m; <span class="comment">// 자른 나무의 길이의 합이 m이상이면 참</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a(n);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (maxlen &lt; a[i])maxlen = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> right = maxlen; <span class="comment">// 나무 길이의 최댓값</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(a, m, mid)) <span class="comment">// 현재 높이로 나무의 길이 m을 만들 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; mid)</span><br><span class="line">ans = mid; <span class="comment">// 가능하다면 현재 절단기 높이 저장</span></span><br><span class="line">left = mid + <span class="number">1</span>; <span class="comment">// 최댓값을 구해야하므로 더 높이 올릴 수 있는지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>; <span class="comment">// 불가능하다면 절단기 높이를 낮춤</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2805&quot;&gt;&lt;a href=&quot;#Problem-2805&quot; class=&quot;headerlink&quot; title=&quot;Problem 2805&quot;&gt;&lt;/a&gt;Problem 2805&lt;/h1&gt;&lt;h2 id=&quot;나무-자르기&quot;&gt;&lt;a href=&quot;#나무-자르기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2110번 공유기 설치</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm2110/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm2110/</id>
    <published>2020-03-03T02:51:12.000Z</published>
    <updated>2020-03-03T09:49:56.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2110"><a href="#Problem-2110" class="headerlink" title="Problem 2110"></a>Problem 2110</h1><h2 id="공유기-설치"><a href="#공유기-설치" class="headerlink" title="공유기 설치"></a>공유기 설치</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.</p><p>도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.</p><p>C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (1 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2110" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2110</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 3<br>1<br>2<br>8<br>4<br>9</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>이분 탐색을 이용하여 인접한 두 공유기 사이의 거리를 탐색한다.</li><li>집의 좌표를 저장한 벡터에서 인접한 공유기 사이의 거리가 현재 간격(dist)이상인 경우가 c이상인지 판별한다.<ul><li>참이라면 현재 지정된 고유기의 간격을 ans에 저장하고 더 큰 값이 있는지 반복한다.</li><li>아니라면 간격을 줄여 다시 탐색한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> c, <span class="keyword">int</span> dist)</span> <span class="comment">// 인접한 공유기 사이의 거리가 현재 간격(dist)이상인 경우가 c이상인지 판별하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 가능한 간격 + 1개가 공유기의 개수</span></span><br><span class="line"><span class="keyword">int</span> last = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> house : a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (house - last &gt;= dist) <span class="comment">// 직전에 공유기를 배치했던 집과 거리 비교</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">last = house; <span class="comment">// 공유기를 배치한 이전 집을 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= c; <span class="comment">// 현재 인접한 공유기 사이의 거리가 dist이상인 경우가 c개 이상이면 참</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">sort(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 오른차순 정렬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> right = a[n - <span class="number">1</span>] - a[<span class="number">0</span>]; <span class="comment">// 가장 멀리 떨어진 두 집의 차이</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">// 인접한 두 공유기의 거리</span></span><br><span class="line"><span class="keyword">if</span> (check(a, c, mid))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; mid)</span><br><span class="line">ans = mid;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2110&quot;&gt;&lt;a href=&quot;#Problem-2110&quot; class=&quot;headerlink&quot; title=&quot;Problem 2110&quot;&gt;&lt;/a&gt;Problem 2110&lt;/h1&gt;&lt;h2 id=&quot;공유기-설치&quot;&gt;&lt;a href=&quot;#공유기-설치&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1654번 랜선 자르기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm1654/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm1654/</id>
    <published>2020-03-03T01:51:12.000Z</published>
    <updated>2020-03-03T09:55:05.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1654"><a href="#Problem-1654" class="headerlink" title="Problem 1654"></a>Problem 1654</h1><h2 id="랜선-자르기"><a href="#랜선-자르기" class="headerlink" title="랜선 자르기"></a>랜선 자르기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.</p><p>이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm 은 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)</p><p>편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1654" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1654</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 11<br>802<br>743<br>457<br>539</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>200</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>길이 l인 랜선을 n개 만들 수 있는지 확인하는 함수를 만든다.</li><li>left = 1, right는 가지고 있는 랜선 길이의 최댓값으로 정한다.</li><li>이분 탐색을 수행하며 현재 길이로 n개의 랜선을 만들 수 있는지 확인 후,<ul><li>가능다면 현재 길이를 ans에 저장하고 더 큰 길이로 만들 수 있는지 확인하기 위해 left를 이동한다.<ul><li>가능하지 않다면 right를 mid - 1로 이동해 길이를 줄여서 확인한다.</li></ul></li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n, <span class="keyword">int</span> l)</span> <span class="comment">// 길이 l인 랜선을 n개 만들 수 있는지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt += a[i] / l; <span class="comment">// 가지고 있는 랜선을 길이 l로 자르면 몇 개를 만들 수 있는지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &gt;= n; <span class="comment">// 만들 수 있는 랜선의 개수가 n이상이면 참</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k, n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span> (right &lt; a[i])</span><br><span class="line">right = a[i]; <span class="comment">// 랜선 길이의 최댓값</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (check(a, n, mid)) <span class="comment">// 현재 길이로 n개의 랜선을 만들 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">ans = mid; <span class="comment">// 현재 길이를 저장하고</span></span><br><span class="line">left = mid + <span class="number">1</span>; <span class="comment">// 더 큰 길이로 만들 수 있는지 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 현재 길이로 n개를 만들 수 없다면 길이를 줄여서 확인</span></span><br><span class="line">&#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1654&quot;&gt;&lt;a href=&quot;#Problem-1654&quot; class=&quot;headerlink&quot; title=&quot;Problem 1654&quot;&gt;&lt;/a&gt;Problem 1654&lt;/h1&gt;&lt;h2 id=&quot;랜선-자르기&quot;&gt;&lt;a href=&quot;#랜선-자르기&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1790번 수 이어 쓰기 2</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/03/algorithm1790/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/03/algorithm1790/</id>
    <published>2020-03-03T00:51:12.000Z</published>
    <updated>2020-03-03T09:51:28.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1790"><a href="#Problem-1790" class="headerlink" title="Problem 1790"></a>Problem 1790</h1><h2 id="수-이어-쓰기-2"><a href="#수-이어-쓰기-2" class="headerlink" title="수 이어 쓰기 2"></a>수 이어 쓰기 2</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.</p><blockquote><p>1234567891011121314151617181920212223…</p></blockquote><p>이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1 ≤ N ≤ 100,000,000)과,  k(1 ≤ k ≤ 1,000,000,000)가 주어진다. N과 k 사이에는 공백이 하나 이상 있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 앞에서 k번째 자리 숫자를 출력한다. 수의 길이가 k보다 작아서 k번째 자리 숫자가 없는 경우는 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1790" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1790</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20 23</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>1부터 N까지의 수를 이어 써서 만든 수의 길이를 구하는 함수 calc를 만든다.</li><li>먼저 n까지 이어 쓴 수의 길이가 k보다 작으면 불가능하므로 예외처리를 한다.</li><li>이분 탐색을 통해 어떤 수까지를 이어 써야 k번째 수가 나오는지 확인한다.</li><li>그 수(ans)를 찾으면 k번째 수를 구하기 위해 ans의 길이를 구해 calc(ans) - k를 ans의 길이에서 빼고 인덱스를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// n까지의 수를 모두 이어 썼을 때, 그 수의 길이</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>, len = <span class="number">1</span>; start &lt;= n; start *= <span class="number">10</span>, len++)</span><br><span class="line">&#123; <span class="comment">// start : 자리수의 첫 수, len : 길이</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span> = start * <span class="number">10</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">end</span> &gt;= n)</span><br><span class="line">ans += (<span class="keyword">long</span>)((n - start + <span class="number">1</span>) * len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += (<span class="keyword">long</span>)((<span class="built_in">end</span> - start + <span class="number">1</span>) * len); <span class="comment">// 현재 자리수까지의 길이 누적</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (calc(n) &lt; k) <span class="comment">// n까지 이어 쓴 수의 길이가 k보다 작으면 불가능</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 이분 탐색</span></span><br><span class="line">&#123; <span class="comment">// 어떤 수까지를 이어 써야 k번째 수가 나오는지 확인</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> len = calc(mid);</span><br><span class="line"><span class="keyword">if</span> (k &gt; len)</span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans = mid;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> s = to_string(ans);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l = calc(ans);</span><br><span class="line"><span class="comment">// l - k를 구해서 마지막 수의 길이에서 뺀다.</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s[s.<span class="built_in">size</span>() - (l - k) - <span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1790&quot;&gt;&lt;a href=&quot;#Problem-1790&quot; class=&quot;headerlink&quot; title=&quot;Problem 1790&quot;&gt;&lt;/a&gt;Problem 1790&lt;/h1&gt;&lt;h2 id=&quot;수-이어-쓰기-2&quot;&gt;&lt;a href=&quot;#수-이어
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1074번 Z</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1074/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1074/</id>
    <published>2020-03-02T09:51:12.000Z</published>
    <updated>2020-03-04T15:53:09.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1074"><a href="#Problem-1074" class="headerlink" title="Problem 1074"></a>Problem 1074</h1><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>한수는 2차원 배열 (항상 2^N * 2^N 크기이다)을 Z모양으로 탐색하려고 한다. 예를 들어, 2*2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.</p><p>만약, 2차원 배열의 크기가 2^N * 2^N라서 왼쪽 위에 있는 칸이 하나가 아니라면, 배열을 4등분 한 후에 (크기가 같은 2^(N-1)로) 재귀적으로 순서대로 방문한다.</p><p>다음 예는 2^2 * 2^2 크기의 배열을 방문한 순서이다.</p><p>N이 주어졌을 때, (r, c)를 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.</p><p>다음 그림은 N=3일 때의 예이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N r c가 주어진다. N은 15보다 작거나 같은 자연수이고, r과 c는 0보다 크거나 같고, 2^N-1보다 작거나 같은 정수이다</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 정답을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1074" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1074</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2 3 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>11</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 7 7</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>63</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀함수로 분할정복을 통해 해결하였다.</li><li>n은 2^n으로 변경하여 인자로 넘겨준다.</li><li>크기가 n * n인 2차원 배열을 4분할하여 2행 2열이 되면 지그재그로 몇 번째 방문인지 카운트한다.</li><li>i가 r , j가 c가 되면 그 때의 ans를 출력하고 리턴한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zigzag</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 지그재그로 방문하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span>) <span class="comment">// 2행 2열이 된 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == r &amp;&amp; j == c) <span class="comment">// r, c에 도착하면 출력 후 리턴</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans++; <span class="comment">// 1씩 증가</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">zigzag(x + m * i, y + m * j, m); <span class="comment">// n / 2씩 건너뛰며 재귀</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r &gt;&gt; c;</span><br><span class="line">n = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">zigzag(<span class="number">0</span>, <span class="number">0</span>, n); <span class="comment">// 0, 0 부터 탐색 n은 2^n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1074&quot;&gt;&lt;a href=&quot;#Problem-1074&quot; class=&quot;headerlink&quot; title=&quot;Problem 1074&quot;&gt;&lt;/a&gt;Problem 1074&lt;/h1&gt;&lt;h2 id=&quot;Z&quot;&gt;&lt;a href=&quot;#Z&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1939번 쿼드트리</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1992/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1992/</id>
    <published>2020-03-02T06:51:12.000Z</published>
    <updated>2020-03-03T09:53:21.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1992"><a href="#Problem-1992" class="headerlink" title="Problem 1992"></a>Problem 1992</h1><h2 id="쿼드트리"><a href="#쿼드트리" class="headerlink" title="쿼드트리"></a>쿼드트리</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.</p><p>주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 “0”이 되고, 모두 1로만 되어 있으면 압축 결과는 “1”이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다</p><p>위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 “(0(0011)(0(0111)01)1)”로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1≤N ≤64의 범위를 가진다. 두 번째 줄부터는 길이 N 의 문자열이 N 개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>영상을 압축한 결과를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1992" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1992</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8<br>11110000<br>11110000<br>00011100<br>00011100<br>11110000<br>11110000<br>11110011<br>11110011</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>((110(0101))(0010)1(0001))</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀함수로 분할정복을 통해 해결하였다.</li><li>현재 크기의 영상이 모두 0또는 1로만 이루어져있다면 결과 문자열에 누적하고 리턴한다.</li><li>아니라면 4분할하여 재귀를 수행한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 크기가 n * n인 영상을 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] != a[i][j])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check(x, y, n)) <span class="comment">// 현재 크기의 영상 확인</span></span><br><span class="line">&#123;</span><br><span class="line">ans += a[x][y]; <span class="comment">// 모두 0또는 1로만 이루어져있다면 결과 문자열에 누적</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="string">'('</span>; <span class="comment">// 단계에서 괄호 시작</span></span><br><span class="line"><span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">go(x + m * i, y + m * j, m); <span class="comment">// 4분할 하여 재귀</span></span><br><span class="line">&#125;</span><br><span class="line">ans += <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.<span class="built_in">size</span>(); j++)</span><br><span class="line">a[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1992&quot;&gt;&lt;a href=&quot;#Problem-1992&quot; class=&quot;headerlink&quot; title=&quot;Problem 1992&quot;&gt;&lt;/a&gt;Problem 1992&lt;/h1&gt;&lt;h2 id=&quot;쿼드트리&quot;&gt;&lt;a href=&quot;#쿼드트리&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1774번 수 묶기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/02/algorithm1774/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/02/algorithm1774/</id>
    <published>2020-03-02T00:51:12.000Z</published>
    <updated>2020-03-02T00:51:30.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1774"><a href="#Problem-1774" class="headerlink" title="Problem 1774"></a>Problem 1774</h1><h2 id="수-묶기"><a href="#수-묶기" class="headerlink" title="수 묶기"></a>수 묶기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열이 주어졌을 때, 그 수열의 합을 구하려고 한다. 하지만, 그냥 그 수열의 합을 모두 더해서 구하는 것이 아니라, 수열의 두 수를 묶으려고 한다. 어떤 수를 묶으려고 할 때, 위치에 상관없이 묶을 수 있다. 하지만, 같은 위치에 있는 수(자기 자신)를 묶는 것은 불가능하다. 그리고 어떤 수를 묶게 되면, 수열의 합을 구할 때 묶은 수는 서로 곱한 후에 더한다.</p><p>예를 들면, 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2<em>3)+(4</em>5) = 27이 되어 최대가 된다.</p><p>수열의 모든 수는 단 한번만 묶거나, 아니면 묶지 않아야한다.</p><p>수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N이 주어진다. N은 10,000보다 작다. 둘째 줄부터 N개의 줄에, 수열의 각 수가 주어진다. 수열의 수는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>수를 적절히 묶어 그 합이 최댓값을 출력한다. 정답은 항상 2^31보다 작다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1774" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1774</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4<br>-1<br>2<br>1<br>3</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그리디로 우선순위 큐를 사용하여 해결하였다.</li><li>두 수를 곱하여 묶을 수 있으므로 가장 큰 수끼리 먼저 묶는 것이 항상 최댓값이 된다.</li><li>음수와 양수를 담을 우선순위 큐를 각각 사용하여 양수는 최대 힙으로, 음수는 최소 힙으로 구현한다.<ul><li>절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있으므로 음수는 최소 힙으로 구현하였고</li><li>음수 중 절댓값이 가장 작은 수가 남은 경우 0과 곱하면 더 크게 만들 수 있으므로 0도 음수 큐에 포함시킨다.</li></ul></li><li>각각 큐에서 두 개씩 뽑아 곱한 값이 더한 값보다 크다면 곱한 값을 누적하고 아니라면 더한 값을 누적하여 답을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">// 양수를 담을 우선순위 큐</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; mq; <span class="comment">// 음수를 담을 우선순위 큐</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 양수와 음수를 구분하여 우선순위 큐에 담음 0은 음수에 포함</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">if</span> (m &gt; <span class="number">0</span>)</span><br><span class="line">pq.push(m);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">mq.push(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="comment">// 양수 큐에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"><span class="keyword">int</span> y = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x * y &gt;= x + y) <span class="comment">// 큰 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면</span></span><br><span class="line">ans += x * y; <span class="comment">// 곱한 값 누적</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pq.empty()) <span class="comment">// 양수 큐의 수가 홀수 개라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = pq.top(); <span class="comment">// 남은 수 처리</span></span><br><span class="line">pq.pop();</span><br><span class="line">ans += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="comment">// 음수 큐에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = mq.top();</span><br><span class="line">mq.pop();</span><br><span class="line"><span class="keyword">int</span> y = mq.top();</span><br><span class="line">mq.pop();</span><br><span class="line"> <span class="comment">// 절댓값이 큰 음수끼리의 곱을 누적해야 최댓값을 구할 수 있음</span></span><br><span class="line"><span class="keyword">if</span> (x * y &gt;= x + y) <span class="comment">// 작은 수부터 두 개씩 뽑아 곱한 값이 더한 값보다 크다면</span></span><br><span class="line">ans += x * y; <span class="comment">// 곱한 값 누적</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ans += x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mq.empty()) <span class="comment">// 음수 큐의 원소가 홀수 개라면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r = mq.top(); <span class="comment">// 남은 수 처리</span></span><br><span class="line">mq.pop();</span><br><span class="line">ans += r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1774&quot;&gt;&lt;a href=&quot;#Problem-1774&quot; class=&quot;headerlink&quot; title=&quot;Problem 1774&quot;&gt;&lt;/a&gt;Problem 1774&lt;/h1&gt;&lt;h2 id=&quot;수-묶기&quot;&gt;&lt;a href=&quot;#수-묶기&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1780번 종이의 개수</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/01/algorithm1780/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/01/algorithm1780/</id>
    <published>2020-03-01T11:39:25.000Z</published>
    <updated>2020-03-01T11:39:39.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1780"><a href="#Problem-1780" class="headerlink" title="Problem 1780"></a>Problem 1780</h1><h2 id="종이의-개수"><a href="#종이의-개수" class="headerlink" title="종이의 개수"></a>종이의 개수</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1의 세 값 중 하나가 저장되어 있다. 우리는 이 행렬을 적절한 크기로 자르려고 하는데, 이때 다음의 규칙에 따라 자르려고 한다.</p><p>만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.<br>(1)이 아닌 경우에는 종이를 같은 크기의 9개의 종이로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.<br>이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N(1≤N≤3^7, N은 3^k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1780" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1780</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>9<br>0 0 0 1 1 1 -1 -1 -1<br>0 0 0 1 1 1 -1 -1 -1<br>0 0 0 1 1 1 -1 -1 -1<br>1 1 1 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0<br>0 1 -1 0 1 -1 0 1 -1<br>0 -1 1 0 1 -1 0 1 -1<br>0 1 -1 1 0 -1 0 1 -1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>10<br>12<br>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>분할 정복으로 재귀 함수를 통해 해결하였다.</li><li>종이의 전체를 확인하고 모두 같지 않다면 9개로 분할하여 다시 확인하는 것을 반복한다.</li><li>(x, y) : 종이의 시작점(가장왼쪽 가장위), n : 종이의 크기 를 인자로 가지는 함수로<ul><li>모든 칸이 같은 수라면 해당 수의 개수를 +1하고 리턴,</li><li>같지 않다면 (x, y)를 (x + n, y + n)까지 n / 3 만큼씩 증가시키며 재귀를 수행한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2187</span>][<span class="number">2187</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// 현재 종이의 모든 칸이 같은지 확인하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] != a[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> <span class="comment">// (x, y) : 종이의 시작점(가장왼쪽 가장위), n : 종이의 크기</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (same(x, y, n)) <span class="comment">// 모든 칸이 같은 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>)</span><br><span class="line">cnt[<span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[x][y] == <span class="number">1</span>)</span><br><span class="line">cnt[<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cnt[<span class="number">2</span>]++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 모든 같이 같지 않으면 다시 분할하여 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; x + n; i += n / <span class="number">3</span>) <span class="comment">// 전체를 9분할하여 모두 확인</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt; y + n; j += n / <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">div(i, j, n / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">div(<span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">2</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt[<span class="number">1</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1780&quot;&gt;&lt;a href=&quot;#Problem-1780&quot; class=&quot;headerlink&quot; title=&quot;Problem 1780&quot;&gt;&lt;/a&gt;Problem 1780&lt;/h1&gt;&lt;h2 id=&quot;종이의-개수&quot;&gt;&lt;a href=&quot;#종이의-개수&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16928번 뱀과 사다리 게임</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/01/algorithm16928/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/01/algorithm16928/</id>
    <published>2020-03-01T09:51:12.000Z</published>
    <updated>2020-03-03T09:58:27.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16928"><a href="#Problem-16928" class="headerlink" title="Problem 16928"></a>Problem 16928</h1><h2 id="뱀과-사다리-게임"><a href="#뱀과-사다리-게임" class="headerlink" title="뱀과 사다리 게임"></a>뱀과 사다리 게임</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>뱀과 사다리 게임을 즐겨 하는 큐브러버는 어느 날 궁금한 점이 생겼다.</p><blockquote><p>주사위를 조작해 내가 원하는 수가 나오게 만들 수 있다면, 최소 몇 번만에 도착점에 도착할 수 있을까?</p></blockquote><p>게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다. 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다.</p><p>플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다. 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다. 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다. 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다. 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다. 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다.</p><p>게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다.</p><p>게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판에 있는 사다리의 수 N(1 ≤ N ≤ 15)과 뱀의 수 M(1 ≤ M ≤ 15)이 주어진다.</p><p>둘째 줄부터 N개의 줄에는 사다리의 정보를 의미하는 x, y (x &lt; y)가 주어진다. x번 칸에 도착하면, y번 칸으로 이동한다는 의미이다.</p><p>다음 M개의 줄에는 뱀의 정보를 의미하는 u, v (u &gt; v)가 주어진다. u번 칸에 도착하면, v번 칸으로 이동한다는 의미이다.</p><p>1번 칸과 100번 칸은 뱀과 사다리의 시작 또는 끝이 아니다. 모든 칸은 최대 하나의 사다리 또는 뱀을 가지고 있으며, 동시에 두 가지를 모두 가지고 있는 경우는 없다. 항상 100번 칸에 도착할 수 있는 입력만 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>100번 칸에 도착하기 위해 주사위를 최소 몇 번 굴려야 하는지 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16928" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16928</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 7<br>32 62<br>42 68<br>12 98<br>95 13<br>97 25<br>93 37<br>79 27<br>75 19<br>49 47<br>67 17</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4 9<br>8 52<br>6 80<br>26 42<br>2 72<br>51 19<br>39 11<br>37 29<br>81 3<br>59 5<br>79 23<br>53 7<br>43 33<br>77 21</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>5</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>bfs를 이용하여 굴려야 하는 주사위의 최소 횟수를 구한다.</li><li>1부터 시작하여 가능한 주사위의 눈이 1~6 이므로 모든 경우를 큐에 넣는다.<ul><li>이 때, 다음 노드가 뱀 또는 사다리에 연결되어 있다면 반드시 이동해야 하므로</li><li>즉시 연결된 노드로 이동한다.</li></ul></li><li>범위 내에서 아직 방문하지 않은 경우 주사위 횟수를 추가하고 다음 노드를 큐에 넣는다.</li><li>100 일때 횟수를 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">// 주사위 횟수를 모두 -1로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">a[u] =  v; <span class="comment">// 사다리</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">a[u] = v; <span class="comment">// 뱀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>); <span class="comment">// 1부터 시작</span></span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dist[<span class="number">100</span>] != <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 100을 방문했다면 break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) <span class="comment">// 가능한 주사위 눈 (1~6)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = node + i; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (a[next] != <span class="number">0</span>) next = a[next]; <span class="comment">// 다음 노드가 뱀 또는 사다리에 연결되어 있다면 즉시 이동(반드시 이동해야함)</span></span><br><span class="line"><span class="keyword">if</span> (dist[next] == <span class="number">-1</span> &amp;&amp; node + i &lt;= <span class="number">100</span>) <span class="comment">// 범위 내에서 아직 방문하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(next);</span><br><span class="line">dist[next] = dist[node] + <span class="number">1</span>; <span class="comment">// 주사위 횟수 추가</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dist[<span class="number">100</span>] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16928&quot;&gt;&lt;a href=&quot;#Problem-16928&quot; class=&quot;headerlink&quot; title=&quot;Problem 16928&quot;&gt;&lt;/a&gt;Problem 16928&lt;/h1&gt;&lt;h2 id=&quot;뱀과-사다리-게임&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16948번 데스 나이트</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/25/algorithm16948/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/25/algorithm16948/</id>
    <published>2020-02-25T09:51:12.000Z</published>
    <updated>2020-03-03T09:58:09.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16948"><a href="#Problem-16948" class="headerlink" title="Problem 16948"></a>Problem 16948</h1><h2 id="데스-나이트"><a href="#데스-나이트" class="headerlink" title="데스 나이트"></a>데스 나이트</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>게임을 좋아하는 큐브러버는 체스에서 사용할 새로운 말 “데스 나이트”를 만들었다. 데스 나이트가 있는 곳이 (r, c)라면, (r-2, c-1), (r-2, c+1), (r, c-2), (r, c+2), (r+2, c-1), (r+2, c+1)로 이동할 수 있다.</p><p>크기가 N×N인 체스판과 두 칸 (r1, c1), (r2, c2)가 주어진다. 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 구해보자. 체스판의 행과 열은 0번부터 시작한다.</p><p>데스 나이트는 체스판 밖으로 벗어날 수 없다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 체스판의 크기 N(5 ≤ N ≤ 200)이 주어진다. 둘째 줄에 r1, c1, r2, c2가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 출력한다. 이동할 수 없는 경우에는 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16948" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16948</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7<br>6 6 0 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6<br>5 1 0 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>7<br>0 3 4 3</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>bfs를 이용하여 최소 이동 횟수를 구한다.</li><li>시작 좌표를 큐에 넣고 이동 가능한 모든 경우를 확인한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span> &#125;; <span class="comment">// (x, y)로 이동 가능한 상대 좌표</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sr, sc, er, ec; <span class="comment">// 시작점, 도착점</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sr &gt;&gt; sc &gt;&gt; er &gt;&gt; ec;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">// 거리를 모두 -1로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(sr, sc)); <span class="comment">// 시작 좌표 push</span></span><br><span class="line">check[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">dist[sr][sc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front().first;</span><br><span class="line"><span class="keyword">int</span> y = q.front().second;</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="comment">// 이동 가능한 모든 경우 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n) <span class="comment">// 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span>) <span class="comment">// 아직 확인하지 않은 경우</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny));</span><br><span class="line">check[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">dist[nx][ny] = dist[x][y] + <span class="number">1</span>; <span class="comment">// 다음 좌표 push 후 거리 추가</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dist[er][ec] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16948&quot;&gt;&lt;a href=&quot;#Problem-16948&quot; class=&quot;headerlink&quot; title=&quot;Problem 16948&quot;&gt;&lt;/a&gt;Problem 16948&lt;/h1&gt;&lt;h2 id=&quot;데스-나이트&quot;&gt;&lt;a href=&quot;#데스-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11047번 동전</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/22/algorithm11047/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/22/algorithm11047/</id>
    <published>2020-02-22T09:51:12.000Z</published>
    <updated>2020-03-04T15:55:53.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11047"><a href="#Problem-11047" class="headerlink" title="Problem 11047"></a>Problem 11047</h1><h2 id="동전"><a href="#동전" class="headerlink" title="동전"></a>동전</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.</p><p>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)</p><p>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11047" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11047</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10 4200<br>1<br>5<br>10<br>50<br>100<br>500<br>1000<br>5000<br>10000<br>50000</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>6</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>동전 A(i)가 A(i+1)의 배수이므로 그리디 알고리즘으로 해결이 가능하다.</li><li>가장 큰 가치의 동전으로 나눈 몫만큼 개수를 증가시키고, 목표 금액을 가장 큰 가치의 동전으로 나눈 나머지로 변경하며 반복한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k / a[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt += k / a[i]; <span class="comment">// 가장 큰 가치의 동전으로 나눈 몫만큼 증가</span></span><br><span class="line">k %= a[i];  <span class="comment">// 나눈 나머지를 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11047&quot;&gt;&lt;a href=&quot;#Problem-11047&quot; class=&quot;headerlink&quot; title=&quot;Problem 11047&quot;&gt;&lt;/a&gt;Problem 11047&lt;/h1&gt;&lt;h2 id=&quot;동전&quot;&gt;&lt;a href=&quot;#동전&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16929번 Two Dots</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/17/algorithm16929/</id>
    <published>2020-02-17T03:24:28.000Z</published>
    <updated>2020-02-17T03:25:57.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16929"><a href="#Problem-16929" class="headerlink" title="Problem 16929"></a>Problem 16929</h1><h2 id="Two-Dots"><a href="#Two-Dots" class="headerlink" title="Two Dots"></a>Two Dots</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>Two Dots는 Playdots, Inc.에서 만든 게임이다. 게임의 기초 단계는 크기가 N×M인 게임판 위에서 진행된다.</p><p>각각의 칸은 색이 칠해진 공이 하나씩 있다. 이 게임의 핵심은 같은 색으로 이루어진 사이클을 찾는 것이다.</p><p>다음은 위의 게임판에서 만들 수 있는 사이클의 예시이다.</p><p>점 k개 d1, d2, …, dk로 이루어진 사이클의 정의는 아래와 같다.</p><ul><li>모든 k개의 점은 서로 다르다.</li><li>k는 4보다 크거나 같다.</li><li>모든 점의 색은 같다.</li><li>모든 1 ≤ i ≤ k-1에 대해서, di와 di+1은 인접하다. 또, dk와 d1도 인접해야 한다. 두 점이 인접하다는 것은 각각의 점이 들어있-는 칸이 변을 공유한다는 의미이다.</li></ul><p>게임판의 상태가 주어졌을 때, 사이클이 존재하는지 아닌지 구해보자.</p><p>2 ≤ N, M ≤ 50</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 게임판의 크기 N, M이 주어진다. 둘째 줄부터 N개의 줄에 게임판의 상태가 주어진다. 게임판은 모두 점으로 가득차 있고, 게임판의 상태는 점의 색을 의미한다. 점의 색은 알파벳 대문자 한 글자이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>사이클이 존재하는 경우에는 “Yes”, 없는 경우에는 “No”를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16929" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16929</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 4<br>AAAA<br>ABCA<br>AAAA</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>Yes</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 4<br>AAAA<br>ABCA<br>AADA</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>No</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 4<br>YYYR<br>BYBY<br>BBBY<br>BBBY</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>Yes</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>7 6<br>AAAAAB<br>ABBBAB<br>ABAAAB<br>ABABBB<br>ABAAAB<br>ABBBAB<br>AAAAAB</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>Yes</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>2 13<br>ABCDEFGHIJKLM<br>NOPQRSTUVWXYZ</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>No</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>문제에서 주어진 조건에 맞는 사이클이 형성되는지 찾는 문제이다. dfs를 통해 해결할 수 있다.</p></li><li><p>방문 여부를 체크할 배열과 탐색을 시작한 점부터 이동한 거리를 나타낼 배열을 선언한다.</p></li><li><p>인접한 같은 색깔의 점인 경우 dfs를 수행한다.</p><ul><li>이때, 사이클을 이루는지 여부를 확인하는 방법은 다음과 같다.<ul><li>cnt변수를 탐색을 진행할 때마다 1씩 증가시킨다.</li><li>처음 방문하게 되는 점의 dist배열에 현재 cnt를 저장한다.</li><li>재귀를 수행할 때 이미 방문했던 노드이며, cnt - dist[x][y] &gt;= 4 인 경우 사이클이 형성된다.</li></ul></li></ul></li><li><p>사이클이 형성되지 않는 경우</p></li></ul><p><img src="https://kyu9341.github.io/img/cycle2.png" alt="cycle"></p><ul><li>사이클이 형성되는 경우</li></ul><p><img src="https://kyu9341.github.io/img/cycle1.png" alt="cycle"></p><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> color[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">// 시작점부터 이동한 거리</span></span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// 게임판의 크기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (check[x][y]) <span class="comment">// 이미 방문했던 노드인데</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt - dist[x][y] &gt;= <span class="number">4</span>) <span class="comment">// 이동 횟수에서 현재 위치에 저장된 시작점과의 거리 차가 4 이상 = 싸이클</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line">dist[x][y] = cnt; <span class="comment">// 현재 x,y가 시작점에서 몇번 이동했는지 저장, 시작점은 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (color[nx][ny] == color[x][y]) <span class="comment">// 같은 색깔의 점인 경우(방문여부는 관계x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(nx, ny, cnt + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">color[i][j] = str[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">"No"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][j] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>))</span><br><span class="line">ans = <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16929&quot;&gt;&lt;a href=&quot;#Problem-16929&quot; class=&quot;headerlink&quot; title=&quot;Problem 16929&quot;&gt;&lt;/a&gt;Problem 16929&lt;/h1&gt;&lt;h2 id=&quot;Two-Dots&quot;&gt;&lt;a href=&quot;#T
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1707번 이분 그래프</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm1707/</id>
    <published>2020-02-15T11:05:15.000Z</published>
    <updated>2020-02-16T04:44:13.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1707"><a href="#Problem-1707" class="headerlink" title="Problem 1707"></a>Problem 1707</h1><h2 id="이분-그래프"><a href="#이분-그래프" class="headerlink" title="이분 그래프"></a>이분 그래프</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.</p><p>그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K(2≤K≤5)가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V(1≤V≤20,000)와 간선의 개수 E(1≤E≤200,000)가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 둘째 줄부터 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호가 빈 칸을 사이에 두고 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1707" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1707</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2<br>3 2<br>1 3<br>2 3<br>4 4<br>1 2<br>2 3<br>3 4<br>4 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>YES<br>NO</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>그래프를 다음과 같이 A와 B로 나눌 수 있으면 <strong>이분 그래프</strong> 라고 한다.</li></ul><p><img src="https://kyu9341.github.io/img/bipartite_graph.png" alt="bipartite_graph"></p><ul><li>A에 포함된 정점끼리 연결된 간선이 없음</li><li>B에 포함된 정점끼리 연결된 간선이 없음</li><li>모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에</li></ul><hr><ul><li><p>check배열을 bool타입 대신 int형으로 선언하여 방문하지 않은 노드는 0, 방문한 노드인데 1번 그룹이라면 1, 2번 그룹이라면 2로 저장한다.</p><ul><li>(dfs or bfs)를 통해 탐색을 수행하며 다음 노드로 넘어가면 그룹을 바꿔서 지정해준다. 이때 다음에 방문한 노드가 같은 그룹에 속한 노드라면 이분 그래프가 아니다.</li></ul></li><li><p>(dfs or bfs)에서 다음 노드가 방문하지 않은 노드라면 다음 노드로 재귀 호출하며 현재 1번 그룹이라면 다음은 2번을 넘겨주고 현재 2번이라면 1번을 넘겨준다.</p></li><li><p>다음 노드가 방문을 했던 노드인데 현재 노드와 같은 그룹이라면 이분 그래프가 아니다.</p></li><li><p>각 테스트케이스를 시작할 때마다 인접 노드와 방문 내역을 초기화 해야한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">20001</span>];</span><br><span class="line"><span class="keyword">int</span> check[<span class="number">20001</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 0 : 방문 x, 1 : 1번 그룹에 포함, 2 : 2번 그룹에 포함</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c)</span> <span class="comment">// c : 다음 방문할 노드의 그룹 ( 1 or 2 ) , 이분그래프이면 true, 아니면 false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[node] = c; <span class="comment">// c 그룹 방문 처리</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i]; <span class="comment">// 다음 노드</span></span><br><span class="line"><span class="keyword">if</span> (!check[next]) <span class="comment">// 다음 정점을 방문 안했으면 동작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!dfs(next, <span class="number">3</span> - c)) <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// false를 리턴받았으면 false리턴</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[next] == check[node]) <span class="comment">// 다음 정점이 이미 방문했던 정점인데 현재 정점과 같은 그룹이면 이분그래프가 아님</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">check[start] = c; <span class="comment">// 그룹 지정</span></span><br><span class="line">q.push(start); <span class="comment">// 첫 노드 push</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> node = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = a[node][i];</span><br><span class="line"><span class="keyword">if</span> (check[next] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">3</span> - check[node];</span><br><span class="line">check[next] = c; <span class="comment">// 다음 노드는 현재 그룹이 1이라면 2, 2라면 1로 방문 처리</span></span><br><span class="line">q.push(next); <span class="comment">// 방문처리하며 push</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (check[node] == check[next])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">// testcase</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v, e;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; v &gt;&gt; e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].<span class="built_in">clear</span>(); <span class="comment">// 인접 노드 초기화</span></span><br><span class="line">check[i] = <span class="number">0</span>; <span class="comment">// 방문 내역 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">a[n].push_back(m);</span><br><span class="line">a[m].push_back(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= v; i++) <span class="comment">// 모든 정점을 확인하여 이분 그래프가 아닌 경우가 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i] == <span class="number">0</span>) <span class="comment">// 아직 방문 안한 노드에 대해서 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bfs(i, <span class="number">1</span>) == <span class="literal">false</span>) <span class="comment">// dfs(i, 1) 도 가능</span></span><br><span class="line">ok = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ok)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1707&quot;&gt;&lt;a href=&quot;#Problem-1707&quot; class=&quot;headerlink&quot; title=&quot;Problem 1707&quot;&gt;&lt;/a&gt;Problem 1707&lt;/h1&gt;&lt;h2 id=&quot;이분-그래프&quot;&gt;&lt;a href=&quot;#이분-그래프&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2309번 일곱 난쟁이</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/15/algorithm2309/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/15/algorithm2309/</id>
    <published>2020-02-15T10:30:51.000Z</published>
    <updated>2020-02-29T15:07:16.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2309"><a href="#Problem-2309" class="headerlink" title="Problem 2309"></a>Problem 2309</h1><h2 id="일곱-난쟁이"><a href="#일곱-난쟁이" class="headerlink" title="일곱 난쟁이"></a>일곱 난쟁이</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.</p><p>아홉 명의 난쟁이는 모두 자신이 “백설 공주와 일곱 난쟁이”의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.</p><p>아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2309" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2309</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20<br>7<br>23<br>19<br>10<br>15<br>25<br>8<br>13</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>7<br>8<br>10<br>13<br>19<br>20<br>23</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>9명의 난쟁이 중 7명의 키의 합이 100인 경우를 구하는 문제이다.</li><li>9명 중 7명을 선택하는 경우의 수는 9C7 = 9C2 = (9<em>8)/(2</em>1) = 36이다.</li><li>브루트 포스 알고리즘을 이용하여 풀이한다.</li><li>이때, 출력을 오름차순으로 하라고 했으므로 미리 입력받은 배열을 오름차순으로 정렬한다.</li><li>먼저 난쟁이의 모든 키를 더해 sum에 저장한 후,<ul><li>두 난쟁이를 선택하여 두 난쟁이의 키를 sum에서 빼 100이 나오는지 판별한다.<ul><li>100이 나온 경우 현재 선택된 두 난쟁이를 제외한 나머지 난쟁이들의 키를 모두 출력한다.</li></ul></li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>[i];</span><br><span class="line">sum += <span class="built_in">height</span>[i]; <span class="comment">// 먼저 모든 난쟁이의 키를 더한다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(<span class="built_in">height</span>, <span class="built_in">height</span> + <span class="number">9</span>); <span class="comment">// 오름차순으로 출력하기 때문에 먼저 정렬</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum - <span class="built_in">height</span>[i] - <span class="built_in">height</span>[j] == <span class="number">100</span>) <span class="comment">// 9가지중 2가지를 골라 위에서 sum에서 빼서 100이 나오는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k == i || k == j) <span class="keyword">continue</span>; <span class="comment">// 뺀 난쟁이는 출력안함</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">height</span>[k] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 출력 후 프로그램 종료</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2309&quot;&gt;&lt;a href=&quot;#Problem-2309&quot; class=&quot;headerlink&quot; title=&quot;Problem 2309&quot;&gt;&lt;/a&gt;Problem 2309&lt;/h1&gt;&lt;h2 id=&quot;일곱-난쟁이&quot;&gt;&lt;a href=&quot;#일곱-난쟁이&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2225번 합분해</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm2225/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm2225/</id>
    <published>2020-02-14T13:30:51.000Z</published>
    <updated>2020-02-29T15:04:58.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2225"><a href="#Problem-2225" class="headerlink" title="Problem 2225"></a>Problem 2225</h1><h2 id="합분해"><a href="#합분해" class="headerlink" title="합분해"></a>합분해</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.</p><p>덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2225" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2225</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>20 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>21</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>점화식 d[k][N] = 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수</li><li>o + o + o + … + <strong>L</strong> = N  –&gt; <strong>L</strong> 의 자리에 올 수 있는 수 : 0 ~ N<ul><li>[ N - L ] + <strong>L</strong> = N</li><li>[ k - 1개 ] + 1개 = k<pre><code>- 따라서, d[k - 1][n - L]의 모든 경우에 L을 더해주면 d[k][n]을 구할 수 있다.  - 즉, d[k - 1][n - L]의 모든 경우를 합친 수가 d[k][n]의 경우의 수가 되는 것이다.</code></pre></li></ul></li><li>d[k][n] = sum(d[k - 1][n - L])<ul><li>0 &lt;= L &lt;= N</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1000000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k; <span class="comment">// n이하의 정수 k개를 더해 n을 만드는 경우의 수</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="comment">// 1개의 정수로 n을 만드는 경우는 모두 1</span></span><br><span class="line">d[<span class="number">1</span>][i] = <span class="number">1</span>; <span class="comment">// 초기값 설정</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= j; l++)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] += d[i - <span class="number">1</span>][j - l]; <span class="comment">// d[k][n] = sum(d[k - 1][n - L])</span></span><br><span class="line">d[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[k][n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2225&quot;&gt;&lt;a href=&quot;#Problem-2225&quot; class=&quot;headerlink&quot; title=&quot;Problem 2225&quot;&gt;&lt;/a&gt;Problem 2225&lt;/h1&gt;&lt;h2 id=&quot;합분해&quot;&gt;&lt;a href=&quot;#합분해&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1912번 연속합</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm1912/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm1912/</id>
    <published>2020-02-14T10:30:51.000Z</published>
    <updated>2020-02-29T15:02:59.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1912"><a href="#Problem-1912" class="headerlink" title="Problem 1912"></a>Problem 1912</h1><h2 id="연속합"><a href="#연속합" class="headerlink" title="연속합"></a>연속합</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p><p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 답을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1912" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1912</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>10<br>10 -4 3 1 5 6 -35 12 21 -1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>33</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = i번째 수로 끝나는 가장 큰 연속합</li><li>d[1] 부터 이전 수까지의 최대 연속합(d[i - 1] + a[i])과 현재 수열의 원소(a[i])와 비교하여 더 큰 값을 d[i]에 저장한다.<ul><li>d[i] = max(d[i-1]+a[i], a[i]) 의 과정을 n까지 반복한다.</li></ul></li><li>d[i]의 최댓값을 출력한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">100001</span>]; <span class="comment">// d[i] = i번째 수로 끝나는 가장 큰 연속합</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">d[<span class="number">1</span>] = a[<span class="number">1</span>]; <span class="comment">// 초기값 지정</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; d[i - <span class="number">1</span>] + a[i]) <span class="comment">// 현재 수열의 값과 이어지는 연속합과의 합과 비교</span></span><br><span class="line">d[i] = a[i];<span class="comment">// 더 큰 값을 d[i]에 저장</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d[i] = d[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="built_in">max</span>)<span class="comment">// d[i] 의 최댓값이 정답</span></span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1912&quot;&gt;&lt;a href=&quot;#Problem-1912&quot; class=&quot;headerlink&quot; title=&quot;Problem 1912&quot;&gt;&lt;/a&gt;Problem 1912&lt;/h1&gt;&lt;h2 id=&quot;연속합&quot;&gt;&lt;a href=&quot;#연속합&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1699번 제곱수의 합</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm1699/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm1699/</id>
    <published>2020-02-14T10:30:51.000Z</published>
    <updated>2020-02-29T15:12:00.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1699"><a href="#Problem-1699" class="headerlink" title="Problem 1699"></a>Problem 1699</h1><h2 id="제곱수의-합"><a href="#제곱수의-합" class="headerlink" title="제곱수의 합"></a>제곱수의 합</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=3^2+1^2+1^2(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=2^2+2^2+1^2+1^2+1^2(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.</p><p>주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1699" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1699</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = 자연수 i를 제곱수들의 합으로 표현하는 최소 항의 개수<ul><li>o + o + o + … + o = n</li><li>[ n - i^2 ] + i^2 = n<ul><li>d[n] =  n - i^2의 최소 개수 + 1</li></ul></li></ul></li><li>d[n] = min(d[n - i * i]) + 1 // (1 &lt;= i * i &lt;= n) –&gt; (1 &lt;= i &lt;= 루트n)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// int d[100001];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// (n - i^2) + i^2 = n -&gt; d[n] =  n - i^2의 최소 개수 + 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = i; <span class="comment">// 모두 1^2으로 표현하는 경우가 최대</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j*j &lt;= i; j++) <span class="comment">// d[n] = min(d[n - i*i]) + 1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; d[i - j * j] + <span class="number">1</span>)</span><br><span class="line">d[i] = d[i - j * j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1699&quot;&gt;&lt;a href=&quot;#Problem-1699&quot; class=&quot;headerlink&quot; title=&quot;Problem 1699&quot;&gt;&lt;/a&gt;Problem 1699&lt;/h1&gt;&lt;h2 id=&quot;제곱수의-합&quot;&gt;&lt;a href=&quot;#제곱수의-합&quot;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14002번 가장 긴 증가하는 부분 수열 4 (LIS)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/14/algorithm14002/</id>
    <published>2020-02-14T01:32:18.000Z</published>
    <updated>2020-02-24T13:16:07.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14002"><a href="#Problem-14002" class="headerlink" title="Problem 14002"></a>Problem 14002</h1><h2 id="가장-긴-증가하는-부분-수열-4-LIS"><a href="#가장-긴-증가하는-부분-수열-4-LIS" class="headerlink" title="가장 긴 증가하는 부분 수열 4 (LIS)"></a>가장 긴 증가하는 부분 수열 4 (LIS)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p><p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p><p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p><p>둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14002" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14002</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6<br>10 20 10 30 20 50</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = a[1], … a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</li><li>i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i] = d[j] + 1</li></ul><table><thead><tr><th align="center"><strong><center>i</center></strong></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th></tr></thead><tbody><tr><td align="center"><strong>a[i]</strong></td><td align="center">10</td><td align="center">20</td><td align="center">10</td><td align="center">30</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center"><strong>d[i]</strong></td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">2</td><td align="center">4</td></tr><tr><td align="center"><strong>v[i]</strong></td><td align="center">-1</td><td align="center">1</td><td align="center">-1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table><ul><li>모든 d[i] 중 최댓값을 구한다.</li><li>이 문제에서는 LIS의 길이 뿐 아니라 LIS의 원소까지 출력을 해야한다.</li><li>이전 LIS문제와 같은 방식으로 푸는데, 역추적을 위한 배열을 만들어 LIS에 연결되는 인덱스를 저장한다.<ul><li>즉, d의 값이 어느 인덱스에 의해 변하는지를 저장한 후 역추적을 통해 출력하는 방식이다.</li><li>또한 p라는 변수에 LIS의 마지막 인덱스를 넣는다. 즉, 최댓값을 가지는 인덱스에서 역추적을 시작한다.</li><li>역추적을 재귀함수를 통해 구현하였지만 스택을 사용하거나 그냥 v에 저장된 인덱스로 a[v[i]]와 같은 배열을 만들어 오름차순 정렬하여 출력해도 무방하다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// LIS 문제</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1001</span>]; <span class="comment">// 역추적을 위한 배열</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>]; <span class="comment">// d[i] = a[1], ... a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 수열의 크기</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 수열 입력</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p = <span class="number">1</span>; <span class="comment">// 역추적을 시작할 인덱스</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = <span class="number">1</span>; <span class="comment">// 모든 d[i]의 초기값은 1</span></span><br><span class="line">v[i] = <span class="number">-1</span>; <span class="comment">// 초기값은 -1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;<span class="comment">// 수열의 마지막 항이 더 크면서</span></span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; d[j] + <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) <span class="comment">// i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i]</span></span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">v[i] = j; <span class="comment">// 연결되는 인덱스를 저장 / 즉, d의 값이 어느 인덱스에 의해 변하는지 저장</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; d[i]) <span class="comment">// 모든 d[i] 중 최댓값이 정답</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">p = i; <span class="comment">// 최댓값을 가지는 인덱스에서 역추적 시작</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">go(p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> p)</span> <span class="comment">// 역추적 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">go(v[p]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[p] &lt;&lt; <span class="string">' '</span>; <span class="comment">// 역순으로 a값 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14002&quot;&gt;&lt;a href=&quot;#Problem-14002&quot; class=&quot;headerlink&quot; title=&quot;Problem 14002&quot;&gt;&lt;/a&gt;Problem 14002&lt;/h1&gt;&lt;h2 id=&quot;가장-긴-증가하는-부분-수열-4-LIS
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 11053번 가장 긴 증가하는 부분 수열(LIS)</title>
    <link href="https://kyu9341.github.io/algorithm/2020/02/13/algorithm11053/"/>
    <id>https://kyu9341.github.io/algorithm/2020/02/13/algorithm11053/</id>
    <published>2020-02-13T01:32:18.000Z</published>
    <updated>2020-02-24T13:16:00.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-11053"><a href="#Problem-11053" class="headerlink" title="Problem 11053"></a>Problem 11053</h1><h2 id="가장-긴-증가하는-부분-수열-LIS"><a href="#가장-긴-증가하는-부분-수열-LIS" class="headerlink" title="가장 긴 증가하는 부분 수열(LIS)"></a>가장 긴 증가하는 부분 수열(LIS)</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.</p><p>예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {<strong>10</strong>, <strong>20</strong>, 10, <strong>30</strong>, 20, <strong>50</strong>} 이고, 길이는 4이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.</p><p>둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/11053" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/11053</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6<br>10 20 10 30 20 50</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>4</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>d[i] = a[1], … a[i] 까지 있을 때, a[i]를 가장 마지막 수로 하는 LIS의 길이</li><li>i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i] = d[j] + 1</li></ul><table><thead><tr><th align="center"><strong><center>i</center></strong></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th></tr></thead><tbody><tr><td align="center"><strong>a[i]</strong></td><td align="center">10</td><td align="center">20</td><td align="center">10</td><td align="center">30</td><td align="center">20</td><td align="center">50</td></tr><tr><td align="center"><strong>d[i]</strong></td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">2</td><td align="center">4</td></tr></tbody></table><ul><li>모든 d[i] 중 최댓값을 구한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// LIS 문제</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1001</span>]; <span class="comment">// d[i] = a[1], ... a[i] 까지 있을 때, a[i]를 가장 마지막으로 하는 LIS의 길이</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 수열의 크기</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 수열 입력</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 초기값 지정 수열의 크기가 1이면 LIS는 1</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">d[i] = <span class="number">1</span>; <span class="comment">// 모든 d[i]의 초기값은 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">&#123;<span class="comment">// 수열의 마지막 항이 더 크면서</span></span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; d[j] + <span class="number">1</span> &amp;&amp; a[i] &gt; a[j]) <span class="comment">// i보다 작은 LIS중에서 가장 긴 LIS에 1을 더하면 d[i]</span></span><br><span class="line">&#123;</span><br><span class="line">d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">max</span> &lt; d[i]) <span class="comment">// 모든 d[i] 중 최댓값이 정답</span></span><br><span class="line"><span class="built_in">max</span> = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-11053&quot;&gt;&lt;a href=&quot;#Problem-11053&quot; class=&quot;headerlink&quot; title=&quot;Problem 11053&quot;&gt;&lt;/a&gt;Problem 11053&lt;/h1&gt;&lt;h2 id=&quot;가장-긴-증가하는-부분-수열-LIS&quot;&gt;
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-01-10T08:30:38.949Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>크루스칼(Kruskal Algorithm) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/09/algorithmKruskal/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/09/algorithmKruskal/</id>
    <published>2020-01-09T11:21:30.000Z</published>
    <updated>2020-01-10T08:30:38.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="크루스칼-Kruskal-Algorithm"><a href="#크루스칼-Kruskal-Algorithm" class="headerlink" title="크루스칼(Kruskal Algorithm)"></a>크루스칼(Kruskal Algorithm)</h2><p>크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘이다. 즉, 최소 비용 신장 트리를 만들기 위한 대표적인 알고리즘이라고 할 수 있다. 흔히 여러 개의 도시가 있을 때 각 도시의 도로를 이용해 비용을 최소한으로 연결하고자 할 때 실제로 적용되는 알고리즘이다.</p><p>아래의 그래프를 보면 노드는 7개이고 간선의 갯수는 11개이다.</p><div style="width: 400px; height: 600px;">    <img src="https://kyu9341.github.io/img/kruskal1.png" style="width: 400px    ; height: 600px;"></div><p>위와 같은 그래프를 최소한의 비용으로 연결만 하고자 한다면 어떻게 해야할까?</p><p>일단 모든 노드를 최대한 적은 비용으로 연결만 시키면 되는 것이기 때문에 모든 간선의 정보를 오름차순으로 정렬하여 비용이 적은 간선부터 하나씩 그래프에 포함시키면 될 것이다.</p><ul><li><p>노드 1</p><ul><li>(1, 7) [12]</li><li>(1, 4) [28]</li><li>(1, 2) [67]</li><li>(1, 5) [17]</li></ul></li><li><p>노드 2</p><ul><li>(2, 4) [24]</li><li>(2, 5) [62]</li></ul></li><li><p>노드 3</p><ul><li>(3, 5) [20]</li><li>(3, 6) [37]</li></ul></li><li><p>노드 4</p><ul><li>(4, 7) [13]</li></ul></li><li><p>노드 3</p><ul><li>(5, 6) [45]</li><li>(5, 7) [73]</li></ul></li></ul><p>우선 위와 같이 간선의 정보들을 저장한다. 노드 1부터 노드 7까지 연결된 모든 간선을 정보를 저장한 것이다. 6, 7이 정보가 없는 이유는 이미 다른 노드들의 간선 정보에 모두 포함되었기 때문이다. 이렇게 총 11개의 간선 정보를 간선의 비용을 기준으로 오름차순 정렬을 수행해보자.</p><ul><li>정렬된 간선 정보<ul><li>(1, 7) [12]</li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><p>이제 다음과 같은 규칙에 따라 그래프를 연결하면 된다.</p><ol><li>정렬된 순서에 맞게 그래프에 포함시킨다.</li><li>포함시키기 전에는 사이클 테이블을 확인한다.</li><li>사이클을 형성하는 경우 간선을 포함하지 않는다.</li></ol><p>여기서 사이클은 그래프가 서로 연결되어 아래와 같이 사이클을 형성하는 경우이다. 최소 비용 신장 트리에서는 사이클이 발생하면 안된다. 모든 노드를 연결하기만 하면 되는데 사이클이 발생한다는 것은 이미 연결된 노드끼리 다시 연결한다는 뜻이기 때문이다.</p><div style="width: 400px; height: 600px;">    <img src="https://kyu9341.github.io/img/kruskal2.png" style="width: 400px    ; height: 600px;"></div><p>사이클이 발생의 여부는 저번 포스팅의 Union-Find 알고리즘을 적용하여 구할 수 있다.</p><p>초기 상태는 다음과 같을 것이다.</p><ul><li>정렬된 간선 정보<ul><li>(1, 7) [12]</li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><ul><li>사이클 테이블<table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table></li></ul><p>이제 첫 번째 간선부터 시작하면</p><h5 id="첫-번째-간선-선택"><a href="#첫-번째-간선-선택" class="headerlink" title="첫 번째 간선 선택"></a>첫 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li>(4, 7) [13]</li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 200px; height: 200px;">      <img src="https://kyu9341.github.io/img/kruskal3.png" style="width: 200px      ; height: 200px;">  </div></li></ul><h5 id="두-번째-간선-선택"><a href="#두-번째-간선-선택" class="headerlink" title="두 번째 간선 선택"></a>두 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li>(1, 7) [12]</li><li><strong>(4, 7) [13]</strong></li><li>(1, 5) [17]</li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">5</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 200px;">      <img src="https://kyu9341.github.io/img/kruskal4.png" style="width: 300px      ; height: 200px;">  </div></li></ul><h5 id="세-번째-간선-선택"><a href="#세-번째-간선-선택" class="headerlink" title="세 번째 간선 선택"></a>세 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li>(3, 5) [20]</li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 300px;">      <img src="https://kyu9341.github.io/img/kruskal5.png" style="width: 300px      ; height: 300px;">  </div></li></ul><h5 id="네-번째-간선-선택"><a href="#네-번째-간선-선택" class="headerlink" title="네 번째 간선 선택"></a>네 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li>(2, 4) [24]</li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal6.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="다섯-번째-간선-선택"><a href="#다섯-번째-간선-선택" class="headerlink" title="다섯 번째 간선 선택"></a>다섯 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li>(1, 4) [28]</li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal7.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="여섯-번째-간선-선택"><a href="#여섯-번째-간선-선택" class="headerlink" title="여섯 번째 간선 선택"></a>여섯 번째 간선 선택</h5><ul><li>정렬된 간선 정보<ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li>(3, 6) [37]</li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li></ul><p>이 때 1과 4가 이미 연결되어 있으므로 무시하고 넘어간다. 사이클 테이블의 값이 서로 동일한 것을 보면 된다.</p><ul><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">6</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal7.png" style="width: 300px      ; height: 400px;">  </div></li></ul><h5 id="일곱-번째-간선-선택"><a href="#일곱-번째-간선-선택" class="headerlink" title="일곱 번째 간선 선택"></a>일곱 번째 간선 선택</h5><ul><li><p>정렬된 간선 정보</p><ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li><strong>(3, 6) [37]</strong></li><li>(5, 6) [45]</li><li>(2, 5) [62]</li><li>(1, 2) [67]</li><li>(5, 7) [73]</li></ul></li><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal8.png" style="width: 300px      ; height: 400px;">  </div></li></ul><p>위와 같이 사이클 테이블의 값이 모두 1이 되며 최소 비용 신장 트리가 완성된 것을 볼 수 있다. 나머지 남은 4개의 간선은 모두 연결되어 있으므로 스킵하여 다음과 같이 완성된다.</p><h5 id="완성"><a href="#완성" class="headerlink" title="완성"></a>완성</h5><ul><li>정렬된 간선 정보<ul><li><strong>(1, 7) [12]</strong></li><li><strong>(4, 7) [13]</strong></li><li><strong>(1, 5) [17]</strong></li><li><strong>(3, 5) [20]</strong></li><li><strong>(2, 4) [24]</strong></li><li><del>(1, 4) [28]</del></li><li><strong>(3, 6) [37]</strong></li><li><del>(5, 6) [45]</del></li><li><del>(2, 5) [62]</del></li><li><del>(1, 2) [67]</del></li><li><del>(5, 7) [73]</del></li></ul></li></ul><ul><li><p>사이클 테이블</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table></li><li><p>그래프 상태</p>  <div style="width: 300px; height: 400px;">      <img src="https://kyu9341.github.io/img/kruskal9.png" style="width: 300px      ; height: 400px;">  </div></li></ul><p>따라서 총 비용은 12 + 13 + 17 + 20 + 24 + 37 = 123 이 된다. 코드로 구현해 보면 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/.png" style="width: 300px     ; height: 100px;"> </div><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230994142" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230994142</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;크루스칼-Kruskal-Algorithm&quot;&gt;&lt;a href=&quot;#크루스칼-Kruskal-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;크루스칼(Kruskal Algorithm)&quot;&gt;&lt;/a&gt;크루스칼(Kruskal Algori
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>합집합 찾기(Union-Find) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/05/algorithmUnion-Find/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/05/algorithmUnion-Find/</id>
    <published>2020-01-05T05:59:47.000Z</published>
    <updated>2020-01-10T09:00:18.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="합집합-찾기-Union-Find"><a href="#합집합-찾기-Union-Find" class="headerlink" title="합집합 찾기(Union-Find)"></a>합집합 찾기(Union-Find)</h2><ul><li>Union-Find는 대표적인 그래프 알고리즘이며 서로소 집합(Disjoint-Set) 알고리즘이라고도 부른다.</li><li>여러 개의 노드가 존재할 때 두 개의 노드를 선택해서 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘이다.</li><li>Union-Find는 두 가지 연산으로 이루어져 있다.<ul><li>Find() : x가 어떤 집합에 포함디어 있는지 찾는 연산</li><li>Union() : x와 y가 포함되어 있는 집합을 합치는 연산</li></ul></li></ul><p>다음의 그림을 보자</p>  <div style="width: 430px; height: 400px;">      <img src="https://kyu9341.github.io/img/uf1.png" style="width: 430px      ; height: 400px;">  </div><p>위와 같이 여러 개의 노드가 서로 자유분방하게 존재한다고 생각해보자. 이와 같이 모두 연결되지 않고 각자 자기 자신만을 집합의 원소로 가지고 있을 때를 다음과 같이 표현할 수 있다. 모든 값이 자기 자신을 가리키도록 만드는 것이다. 아래 표에서 첫 행은 노드 번호를 의미하고 두 번째 행은 부모 노드 번호를 의미한다. 즉, 자신이 어떠한 부모 노드에 포함되어 있는지를 의미한다.</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table>  <div style="width: 430px; height: 400px;">      <img src="https://kyu9341.github.io/img/uf2.png" style="width: 430px      ; height: 400px;">  </div><p>이 때 위와 같이 1과 2가 연결되었다고 해보자. 이러한 연결성을 프로그래밍 언어로 어떻게 표현할 수 있을 지에 대한 내용이 Union-Find라고 생각하면 된다.</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table><p>  1과 2의 연결성을 위와 같이 표현할 수 있다. 2번째 인덱스의 값에 1이 들어가는 것이다. 이렇게 부모를 합칠 때는 <strong>일반적으로 더 작은 값 쪽으로</strong> 합치게 된다. 이것을 Union()이라고 볼 수 있다.</p>  <div style="width: 430px; height: 400px;">      <img src="https://kyu9341.github.io/img/uf3.png" style="width: 430px      ; height: 400px;">  </div><p>이제 위와 같이 2와 3도 연결되었다면</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table><p>위와 같이 표현할 수 있는데, 여기서는 1과 3이 연결되었는지 어떻게 파악할 수 있을까? 1과 3은 부모가 각각 1과 2로 다르기 때문에 부모 노드만 보고는 한번에 파악할 수 없다. 그렇기 때문에 <strong>재귀 함수</strong> 가 사용된다.</p><p>3의 부모를 찾기 위해서 먼저 3이 가리키는 2를 찾는다. 2는 부모인 1을 가리키고 있으므로 3의 부모는 1이 되는 것이다. 이러한 과정은 재귀적으로 수행될 때 효과적으로 표현할 수 있다. 그래서 결과적으로 합침(Union)연산이 모두 수행되고 나면 다음과 같이 표가 구성된다.</p><table><thead><tr><th align="center"><center>노드 번호</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">부모 노드 번호</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td></tr></tbody></table><p>노드 1, 2, 3의 부모가 모두 1이기 때문에 이 세 가지 노드는 모두 같은 그래프에 속한다고 할 수 있다. 이것이 Union-Find이다. Find알고리즘은 두 개의 노드의 부모 노드를 확인하여 현재 같은 집합에 속하는지를 확인하는 알고리즘이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 부모 노드를 찾는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] == x)<span class="keyword">return</span> x; <span class="comment">// 부모 노드가 자신인 경우 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> parent[x] = getParent(parent, parent[x]);</span><br><span class="line"><span class="comment">// 부모 노드의 값과 자신이 다르다면 재귀 호출</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 부모 노드를 합치는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a &lt; b) parent[b] = a; <span class="comment">// 더 작은 값을 부모 노드로 지정</span></span><br><span class="line"><span class="keyword">else</span> parent[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 같은 부모를 가지는지 확인</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = getParent(parent, a); <span class="comment">// a의 부모 노드 확인</span></span><br><span class="line">b = getParent(parent, b); <span class="comment">// b의 부모 노드 확인</span></span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 같은 부모를 가진다면 1을 리턴</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 다르다면 0리턴</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b; <span class="comment">// 연결을 확인할 두 노드 번호</span></span><br><span class="line"><span class="keyword">int</span> parent[<span class="number">11</span>]; <span class="comment">// 각 노드의 부모를 담을 배열 (인덱스 : 자식 노드, 값 : 부모 노드)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line">unionParent(parent, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">unionParent(parent, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"연결되어 있는지 확인할 노드 번호 : "</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"와 "</span> &lt;&lt; b &lt;&lt; <span class="string">"의 연결 여부 : "</span> &lt;&lt; findParent(parent, a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/uf.png" style="width: 300px     ; height: 100px;"> </div><p>위와 같은 상태에서는 1과 3이 연결되어 있는 것을 볼 수 있으며 unionParent()함수를 사용하여 다른 노드의 부모 노드를 연결하면 연결한 노드의 연결 여부가 정상적으로 출력되는 것을 확인할 수 있을 것이다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230967614" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230967614</a><br><a href="https://brenden.tistory.com/33?category=747314" target="_blank" rel="external nofollow noopener noreferrer">https://brenden.tistory.com/33?category=747314</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;합집합-찾기-Union-Find&quot;&gt;&lt;a href=&quot;#합집합-찾기-Union-Find&quot; class=&quot;headerlink&quot; title=&quot;합집합 찾기(Union-Find)&quot;&gt;&lt;/a&gt;합집합 찾기(Union-Find)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Un
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>깊이 우선 탐색(Depth First Search, DFS) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/03/algorithmDFS/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/03/algorithmDFS/</id>
    <published>2020-01-03T06:11:01.000Z</published>
    <updated>2020-01-11T06:03:32.807Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 깊이 우선 탐색에 대해 알아보자.</p><h2 id="깊이-우선-탐색-Depth-First-Search-DFS"><a href="#깊이-우선-탐색-Depth-First-Search-DFS" class="headerlink" title="깊이 우선 탐색(Depth First Search, DFS)"></a>깊이 우선 탐색(Depth First Search, DFS)</h2><blockquote><p>깊이 우선 탐색(depth-first search: DFS)은 맹목적 탐색방법의 하나로 탐색트리의 최근에 첨가된 노드를 선택하고, 이 노드에 적용 가능한 동작자 중 하나를 적용하여 트리에 다음 수준(level)의 한 개의 자식노드를 첨가하며, 첨가된 자식 노드가 목표노드일 때까지 앞의 자식 노드의 첨가 과정을 반복해 가는 방식이다.<br>출처 : 위키백과</p></blockquote><p>깊이 우선 탐색(Depth First Search)은 탐색을 함에 있어서 보다 깊은 것을 우선적으로 탐색하는 알고리즘이다. 이러한 깊이 우선 탐색은 맹목적으로 각 노드를 탐색할 때 주로 사용된다. <strong>너비 우선 탐색(Breadth First Search)</strong> 에서는 큐(Queue)가 사용되었다면 <strong>깊이 우선 탐색(Depth First Search)</strong> 에서는 스택(Stack)이 사용된다. 더하여 사실 스택을 사용하지 않아도 구현이 가능하다는 특징이 있다. 컴퓨터는 구조적으로 항상 스택의 원리를 사용하기 때문이다.</p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>자기 자신을 호출하는 순환 알고리즘의 형태를 가진다.</li><li>그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.</li></ul><p>다음의 그림을 보자</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/bfs1.png" style="width: 460px    ; height: 460px;"></div><p>DFS는 맨 처음에 시작 노드(Start Node)를 스택에 삽입하면서 시작한다. 또한 시작 노드를 방문했다고 <strong>방문 처리</strong> 를 해주도록 한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs1.png" style="width: 460px    ; height: 460px;"></div><p>이제 BFS는 다음과 같은 알고리즘에 의해 동작한다.</p><ol><li>스택의 최상단 노드를 확인한다.</li><li>최상단 노드에게 방문하지 않은 인접 노드가 있으면 그 노드를 스택에 넣고 방문처리한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 뺀다.</li></ol><p>위의 1번과 2번을 계속해서 반복하면 된다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs3.png" style="width: 460px    ; height: 460px;"></div><p>스택에 있던 최상단 노드가 1번 노드이므로 인접한 노드 중 방문하지 않은 2번 노드를 삽입한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs4.png" style="width: 460px    ; height: 460px;"></div><p>이후에 2번 노드의 인접 노드 중 방문하지 않은 노드인 3번 노드를 스택에 삽입한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs5.png" style="width: 460px    ; height: 460px;"></div><p>이어서 3번 노드의 인접 노드 중 방문하지 않은 6번 노드를 스택에 삽입</p> <div style="width: 460px; height: 460px;">     <img src="https://kyu9341.github.io/img/dfs6.png" style="width: 460px     ; height: 460px;"> </div><p>6번 노드의 인접 노드 중 방문하지 않은 7번 노드를 삽입</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs8.png" style="width: 460px    ; height: 460px;"></div><p>7번 노드, 6번 노드, 3번 노드는 인접 노드를 모두 방문하였기 때문에 스택에서 빠져나오게 된다. 이후에 2번 노드를 보았을 때 인접 노드인 4번 노드를 아직 방문하지 않았으므로 스택에 넣는다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs9.png" style="width: 460px    ; height: 460px;"></div><p>결과적으로 4번 노드의 인접 노드인 5번 노드가 스택에 들어가고 이후에 스택에서 하나씩 다 노드들이 빠져나오게 된다. 결과적으로 다음 그림과 같다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/dfs10.png" style="width: 460px    ; height: 460px;"></div><p>따라서 방문 경로는 1 - 2 - 3 - 6 - 7 - 4 - 5 이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">8</span>]; <span class="comment">// 방문한 노드인지 기록</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">8</span>]; <span class="comment">// 그래프를 표현할 벡터</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x]) <span class="keyword">return</span>; <span class="comment">// 방문했던 노드면 리턴</span></span><br><span class="line">c[x] = <span class="literal">true</span>; <span class="comment">// 방문 처리</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[x].<span class="built_in">size</span>(); i++) <span class="comment">// 각 벡터에 연결된 노드 수만큼 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = a[x][i]; <span class="comment">// 현재 노드</span></span><br><span class="line">dfs(y); <span class="comment">// 재귀 함수로 스택을 구현</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1과 2를 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">2</span>);</span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1과 3을 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2와 3을 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 4를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">4</span>);</span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 5를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3과 6을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">6</span>);</span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3과 7을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 4와 5를 연결</span></span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 6과 7을 연결</span></span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// BFS 수행</span></span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/dfs.png" style="width: 300px     ; height: 100px;"> </div><p>결과는 위와 같이  1 - 2 - 3 - 6 - 7 - 4 - 5 의 순서로 탐색이 된 것을 확인할 수 있다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230945092" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230945092</a><br><a href="https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89</a><br><a href="https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 깊이 우선 탐색에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;깊이-우선-탐색-Depth-First-Search-DFS&quot;&gt;&lt;a href=&quot;#깊이-우선-탐색-Depth-First-Search-DFS&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>너비 우선 탐색(Breadth First Search, BFS) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/03/algorithmBFS/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/03/algorithmBFS/</id>
    <published>2020-01-03T02:58:21.000Z</published>
    <updated>2020-01-11T06:07:22.564Z</updated>
    
    <content type="html"><![CDATA[<p>드디어 정렬 알고리즘이 끝나고 탐색 알고리즘이다. 이번 포스팅에서는 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘에 대해 알아보자.</p><h2 id="너비-우선-탐색-Breadth-First-Search-BFS"><a href="#너비-우선-탐색-Breadth-First-Search-BFS" class="headerlink" title="너비 우선 탐색(Breadth First Search, BFS)"></a>너비 우선 탐색(Breadth First Search, BFS)</h2><blockquote><p>너비 우선 탐색(Breadth-first search, BFS)은 맹목적 탐색방법의 하나로 시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다. 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서도 너비 우선 검색을 적용한다. OPEN List 는 큐를 사용해야만 레벨 순서대로 접근이 가능하다.<br>출처 : 위키백과</p></blockquote><p>너비 우선 탐색은 맹목적인 탐색을 하고자 할 때 사용할 수 있는 탐색 기법이다. 최단 경로를 찾아준다는 점에서 최단길이를 보장해야 할 때 많이 사용된다.</p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.</li><li>BFS는 재귀적으로 동작하지 않는다.</li><li>그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.</li><li>BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(Queue)를 사용한다.</li></ul><p>다음의 그림을 보자</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/bfs1.png" style="width: 460px    ; height: 460px;"></div><p>BFS는 맨 처음에 시작 노드(Start Node)를 큐에 삽입하면서 시작한다. 또한 시작 노드를 방문했다고 <strong>방문 처리</strong> 를 해주도록 한다.</p><div style="width: 460px; height: 460px;">    <img src="https://kyu9341.github.io/img/bfs2.png" style="width: 460px    ; height: 460px;"></div><p>이제 BFS는 다음과 같은 알고리즘에 의해 동작한다.</p><ol><li>큐에서 하나의 노드를 꺼낸다.</li><li>해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입한다.</li></ol><p>위의 1번과 2번을 계속해서 반복하면 된다.</p><div style="width: 460px; height: 530px;">    <img src="https://kyu9341.github.io/img/bfs3.png" style="width: 460px    ; height: 530px;"></div><p>먼저 시작 노드 1을 큐에서 꺼냈다. 그리고 주변 노드인 2와 3이 모두 방문된 적이 없으므로 큐에 넣어준다. 결과는 위와 같다.</p><div style="width: 460px; height: 530px;">    <img src="https://kyu9341.github.io/img/bfs4.png" style="width: 460px    ; height: 530px;"></div><p>큐에서 2를 꺼낸 직후에는 그 인접한 노드 1, 3, 4, 5 중에서 1과 3은 이미 방문한 적이 있으므로 패스하고 4와 5를 큐에 삽입한다.</p><div style="width: 460px; height: 530px;">    <img src="https://kyu9341.github.io/img/bfs5.png" style="width: 460px    ; height: 530px;"></div><p> 이후에 노드 3을 큐에서 꺼낸 뒤 인접한 노드인 6과 7을 삽입한다. 노드 1과 노드 2는 방문한 적이 있으므로 6과 7만 큐에 넣어주면 된다. 따라서 위와 같이 기본적으로 모든 노드가 방문처리가 되었다. 이제 남은 노드들을 큐에서 꺼내주기만 하면 된다.</p> <div style="width: 570px; height: 530px;">     <img src="https://kyu9341.github.io/img/bfs6.png" style="width: 570px     ; height: 530px;"> </div><p>차례대로 꺼내면 위와 같이 된다. 큐에서 꺼낸 순서를 보면 1, 2, 3, 4, 5, 6, 7이다. 아무렇게나 탐색하는 것이 아니라 이와 같이 1부터 ‘가까운’ 노드들 부터 탐색이 이루어진다는 점에서 너비 우선 탐색이라고 한다. 거리가 먼 노드인 4, 5, 6, 7은 가장 마지막에 탐색이 이루어지게 된다. C++코드로 구현하게 되면 다음과 같다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">8</span>]; <span class="comment">// 방문한 노드인지 기록</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[<span class="number">8</span>]; <span class="comment">// 그래프를 표현할 벡터</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(start); <span class="comment">// 첫 번째 노드 큐에 삽입</span></span><br><span class="line">c[start] = <span class="literal">true</span>; <span class="comment">// 시작 노드 방문 처리</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); <span class="comment">// 맨 앞의 원소 저장</span></span><br><span class="line">q.pop(); <span class="comment">// 맨 앞의 원소 삭제</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[x].<span class="built_in">size</span>(); i++) <span class="comment">// 각 벡터에 연결된 노드 수만큼 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y = a[x][i]; <span class="comment">// 현재 노드</span></span><br><span class="line"><span class="keyword">if</span> (!c[y]) <span class="comment">// 방문했었는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(y); <span class="comment">// 아직 방문하지 않은 노드들을 큐에 삽입</span></span><br><span class="line">c[y] = <span class="literal">true</span>; <span class="comment">// 해당 원소 방문 처리</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1과 2를 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">2</span>);</span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1과 3을 연결</span></span><br><span class="line">a[<span class="number">1</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 2와 3을 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">3</span>);</span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 4를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">4</span>);</span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2와 5를 연결</span></span><br><span class="line">a[<span class="number">2</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3과 6을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">6</span>);</span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3과 7을 연결</span></span><br><span class="line">a[<span class="number">3</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 4와 5를 연결</span></span><br><span class="line">a[<span class="number">4</span>].push_back(<span class="number">5</span>);</span><br><span class="line">a[<span class="number">5</span>].push_back(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 6과 7을 연결</span></span><br><span class="line">a[<span class="number">6</span>].push_back(<span class="number">7</span>);</span><br><span class="line">a[<span class="number">7</span>].push_back(<span class="number">6</span>);</span><br><span class="line"><span class="comment">// BFS 수행</span></span><br><span class="line">bfs(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div style="width: 300px; height: 100px;">     <img src="https://kyu9341.github.io/img/bfs.png" style="width: 300px     ; height: 100px;"> </div><p>결과는 위와 같이 1 2 3 4 5 6 7의 순서로 탐색이 된 것을 확인할 수 있다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221230944971" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221230944971</a><br><a href="https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EB%84%88%EB%B9%84_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89</a><br><a href="https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;드디어 정렬 알고리즘이 끝나고 탐색 알고리즘이다. 이번 포스팅에서는 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘에 대해 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;너비-우선-탐색-Breadth-First-Search-BFS&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>(C++) STL 라이브러리</title>
    <link href="https://kyu9341.github.io/C-C/2020/01/03/C3/"/>
    <id>https://kyu9341.github.io/C-C/2020/01/03/C3/</id>
    <published>2020-01-03T01:52:18.000Z</published>
    <updated>2020-01-03T02:44:30.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="STL-이란"><a href="#STL-이란" class="headerlink" title="STL 이란?"></a>STL 이란?</h2><ul><li>Standard Template Library의 약자로서 C++에서 제공하는 템플릿 기반 표준 라이브러리이다.</li><li>프로그램에 필요한 자료구조와 알고리즘을 Template로 제공하는 라이브러리</li><li>STL라이브러리는 크게 STL 컨테이너(Container)와 STL 알고리즘(Algorithm)으로 구성되어 있다.</li></ul><h3 id="STL-컨테이너-Container"><a href="#STL-컨테이너-Container" class="headerlink" title="STL 컨테이너(Container)"></a>STL 컨테이너(Container)</h3><p>STL 컨테이너는 데이터를 보관하고 관리하기 위한 여러가지 기능을 제공한다.</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><ul><li>동적 배열이므로 배열의 크기를 변경할 수 있다.</li><li>임의 접근이 가능하며, 뒤에서의 삽입이 빠르다.</li><li>삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1)보장</li><li>Java의 ArrayList와 동일하다고 볼 수있다.</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><ul><li>연결리스트이므로 데이터를 순차적으로 접근하고 관리할 때 유용하다.</li><li>위치에 관계없이 삽입과 삭제가 빠르다.</li><li>삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1)보장</li></ul><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><ul><li>덱, 데크라고 한다.</li><li>임의 접근이 가능하며 앞과 뒤에서의 삽입이 빠르다.</li><li>삽입, 삭제, 탐색 O(n), 임의 원소 접근 O(1)보장</li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul><li>특정 키(key)로 데이터를 접근하고 관리할 수 있다.</li><li>키로 값에 접근하며 삽입과 삭제가 빠르다.</li><li>삽입, 삭제, 탐색 모두 O(log n) 보장</li></ul><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul><li>원소를 순서대로 관리하며 소속 검사와 삽입, 삭제가 빠르다.</li><li>중복된 원소를 허용하지 않는다.</li><li>삽입, 삭제, 탐색 모두 O(log n) 보장</li></ul><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><ul><li>top에서만 삽입과 삭제가 가능하다.</li><li>LIFO(Last In First Out)방식으로 데이터를 삽입, 삭제한다.(후입선출)</li><li>삽입, 삭제 O(1) 보장</li></ul><h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><ul><li>삽입은 뒤쪽에서, 삭제는 앞쪽에서 수행한다.</li><li>FIFO(First In First Out)방식으로 데이터를 삽입, 삭제한다.(선입선출)</li><li>삽입, 삭제 O(1) 보장</li></ul><p>STL 컨테이너는 데이터를 저장하는 방식과 삽입, 정렬, 삭제하는 관리 방식에 따라 크게 세 가지 부류로 나눠볼 수 있다.</p><ul><li><p>순차 컨테이너</p><ul><li>데이터를 순차적으로 저장하는 가장 일반적인 컨테이너</li><li>삽입된 데이터를 저장할 때 별도의 제약이나 관리 규칙을 갖지 않는다.</li><li>임의의 위치에 원소를 삽입하거나 삭제할 수 있다.</li><li>vector, list, deque 등이 속한다.</li></ul></li><li><p>연관 컨테이너</p><ul><li>데이터를 무조건 저장만 하는 것이 아니라 일정한 규칙에 따라서 데이터를 관리하는 컨테이너</li><li>정렬이나 해시 등의 방법을 통해 삽입되는 데이터를 항상 일정한 기준에 맞는 위치에 저장하므로 검색 속도가 빠르다.</li><li>set, map 등이 속한다.</li></ul></li><li><p>어댑터 컨테이너</p><ul><li>순차 컨테이너를 변형하여 데이터를 미리 정해진 방식에 따라 관리한다.</li><li>데이터를 삽입하고 제거하는 순서가 항상 컨테이너의 규칙에 의해 결정된다.</li><li>stack, queue, priority_queue 등이 속한다.</li></ul></li></ul><p>STL 컨테이너는 공통적으로 <strong>iterator 클래스를 제공</strong> 한다.<br>iterator는 반복자라고도 하는데 마치 포인터처럼 STL컨테이너의 특정 위치를 나타내는 역할을 한다.</p><ul><li>++연산자를 이용해 다음 원소를 가리키도록 변경할 수 있고, * 연산자를 통해 해당 원소에 접근할 수 도 있다.</li><li>list.begin(), list.end()와 같은 함수를 제공하는대 begin은 컨테이너의 가장 처음, end는 컨테이너의 마지막 위치를 가리킨다.</li></ul><h3 id="STL-알고리즘-Algorithm"><a href="#STL-알고리즘-Algorithm" class="headerlink" title="STL 알고리즘(Algorithm)"></a>STL 알고리즘(Algorithm)</h3><p>STL 알고리즘은 STL이 제공하는 범용 함수를 말한다.<br>정렬이나 검색처럼 프로그램에 구현에 자주 사용되는 기능을 함수 템플릿으로 준비해둔 것.</p><p>STL 알고리즘은 크게 네 가지로 분류 할 수 있다.</p><ul><li><p>변경 불가 시퀀스 알고리즘 (find, for_each)</p></li><li><p>변경 가능 시퀀스 알고리즘 (copy, generate, remove, replace, fill, swap, reverse, transform)</p></li><li><p>정렬 관련 알고리즘 (sort, binary_search, merge)</p></li><li><p>범용 수치 알고리즘 (accumulate, inner_product)</p></li></ul><blockquote><p>참조<br><a href="https://wonjayk.tistory.com/208?category=535160" target="_blank" rel="external nofollow noopener noreferrer">https://wonjayk.tistory.com/208?category=535160</a><br><a href="https://blockdmask.tistory.com/67?category=249379" target="_blank" rel="external nofollow noopener noreferrer">https://blockdmask.tistory.com/67?category=249379</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;STL-이란&quot;&gt;&lt;a href=&quot;#STL-이란&quot; class=&quot;headerlink&quot; title=&quot;STL 이란?&quot;&gt;&lt;/a&gt;STL 이란?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Standard Template Library의 약자로서 C++에서 제공하는 템플릿
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://kyu9341.github.io/categories/C-C/"/>
    
    
  </entry>
  
  <entry>
    <title>계수 정렬(Counting Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2020/01/02/algorithmCountingSort/"/>
    <id>https://kyu9341.github.io/algorithm/2020/01/02/algorithmCountingSort/</id>
    <published>2020-01-02T06:19:40.000Z</published>
    <updated>2020-01-03T01:33:48.615Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>계수 정렬(Counting Sort)</strong> 에 대해 알아보겠다. 지금까지 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬을 공부해 보았다. 이 중 가장 빠른 정렬 알고리즘의 시간 복잡도는 O(N*logN)이었다. 이번에 배울 계수 정렬은 시간 복잡도가 O(N)이다. 하지만 데이터의 범위에 대해 조건이 있는 경우만 아주 빠른 속도를 보여준다.</p><h2 id="계수-정렬-Counting-Sort"><a href="#계수-정렬-Counting-Sort" class="headerlink" title="계수 정렬(Counting Sort)"></a>계수 정렬(Counting Sort)</h2><blockquote><ul><li>원소간 비교하지 않고 각 원소가 .몇개 등장하는지 갯수를 세어 정렬하는 방식이다.</li><li>모든 원소는 양의 정수이다.</li><li>시간 복잡도는 O(n + k)로 퀵 정렬, 병합정렬에 비해 일반적으로 빠르다.</li><li>정렬을 위한 길이 n의 배열 하나, 계수를 위한 길이 k의 배열 하나. O(n + k)의 공간 복잡도를 가진다.</li></ul></blockquote><p>1, 3, 2, 4, 3, 2, 5, 3, 1, 2, 3, 4, 4, 3, 5, 1, 2, 3, 5, 2, 3, 1, 4, 3, 5, 1, 2, 1, 1, 1</p><hr><p>위와 같은 30개의 데이터를 정렬한다고 하자. 위의 데이터는 1부터 5 사이에 속한다는 특징이 있다. 이를 계수 정렬을 이용하여 정렬해 보도록 하겠다. 계수 정렬은 단순하게 크기를 기준으로 세는 알고리즘이다.</p><p>지금까지는 모든 데이터를 그 자체로 위치를 바꾸어가면서 정렬하는 알고르즘에 대해 공부를 하였다. 이번에 다룰 계수 정렬은 크기를 기준으로 갯수만 세주면 되기 때문에 위치를 바꿀 필요가 없다. 또한 모든 데이터에 한 번씩만 접근하면 된다는 점에서 효율적이다.</p><h6 id="초기-상태"><a href="#초기-상태" class="headerlink" title="초기 상태"></a>초기 상태</h6><p>1 3 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="1번째-상태"><a href="#1번째-상태" class="headerlink" title="1번째 상태"></a>1번째 상태</h6><p><strong>1</strong> 3 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="2번째-상태"><a href="#2번째-상태" class="headerlink" title="2번째 상태"></a>2번째 상태</h6><p><strong>1 3</strong> 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="3번째-상태"><a href="#3번째-상태" class="headerlink" title="3번째 상태"></a>3번째 상태</h6><p><strong>1 3 2</strong> 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h6 id="4번째-상태"><a href="#4번째-상태" class="headerlink" title="4번째 상태"></a>4번째 상태</h6><p><strong>1 3 2 4</strong> 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><h6 id="5번째-상태"><a href="#5번째-상태" class="headerlink" title="5번째 상태"></a>5번째 상태</h6><p><strong>1 3 2 4 3</strong> 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1</p><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>위와 같은 방식으로 해당 크기의 원소를 만나는 경우 숫자를 1씩 더해주면 된다. 이러한 방식을 계속해서 반복하면 다음과 같은 결과가 나온다.</p><h6 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h6><table><thead><tr><th align="center"><center>크기 = 1</center></th><th align="center"><center>크기 = 2</center></th><th align="center"><center>크기 = 3</center></th><th align="center"><center>크기 = 4</center></th><th align="center"><center>크기 = 5</center></th></tr></thead><tbody><tr><td align="center">8</td><td align="center">6</td><td align="center">8</td><td align="center">4</td><td align="center">4</td></tr></tbody></table><p>이제 크기를 1부터 5까지 해당 숫자만큼 출력을 하면 된다. 즉, 1을 8번 출력하고 2를 6번, 3을 8번, 4를 4번, 5를 4번 출력하면 정렬이 이루어진다.</p><p>1 1 1 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 5 5 5 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count[<span class="number">6</span>]; <span class="comment">// 정렬할 수의 최댓값 + 1만큼 누적합 배열 할당</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">30</span>] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="comment">// 갯수를 카운트할 배열 초기화</span></span><br><span class="line">count[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) <span class="comment">// 각 크기의 갯수 카운트</span></span><br><span class="line">count[<span class="built_in">array</span>[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="comment">// 순서대로 갯수만큼 출력</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(count[i] != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= count[i]; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드도 아주 간결하다. 데이터의 크기가 1부터 5 사이인 점에서 반복 또한 5번만 수행하면 된다. 모든 데이터의 크기 범위를 메모리 상에 표현할 수 있다면 O(N)이라는 압도적인 속도로 정렬을 수행할 수 있다는 것이다. 그러나 Counting Sort는 대부분의 상황에서 엄청난 메모리 낭비를 야기할 수 있다. 예를 들어, 1, 1, 3, 100 의 데이터를 정렬하기 위해서는 누적합 배열의 길이를 101로 잡는 메모리 낭비를 하게 된다. 만약 배열의 최댓값으로 10억이 포함되었다면 엄청난 낭비가 될 것이다. 이러한 문제점 때문에 위와 같이 범위가 특정한 상황에서만 주로 사용이 된다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221228361368" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221228361368</a><br><a href="https://yaboong.github.io/algorithms/2018/03/20/counting-sort/" target="_blank" rel="external nofollow noopener noreferrer">https://yaboong.github.io/algorithms/2018/03/20/counting-sort/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;계수 정렬(Counting Sort)&lt;/strong&gt; 에 대해 알아보겠다. 지금까지 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 병합 정렬, 힙 정렬을 공부해 보았다. 이 중 가장 빠른 정렬 알고리즘의 시간 복
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>힙 정렬(Heap Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/28/algorithmHeapSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/28/algorithmHeapSort/</id>
    <published>2019-12-28T09:53:12.000Z</published>
    <updated>2020-01-11T13:49:32.832Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>힙 정렬(Heap Sort)</strong> 에 대해 알아보겠다. 힙 정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 또한 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기 때문에 반드시 알고 넘어가야 하는 정렬 알고리즘이라고 한다. 힙 정렬은 힙 트리 구조(Heap Tree Structure)를 이용하는 정렬 방법이다.</p><h2 id="힙-정렬-Heap-Sort"><a href="#힙-정렬-Heap-Sort" class="headerlink" title="힙 정렬(Heap Sort)"></a>힙 정렬(Heap Sort)</h2><blockquote><p>힙 정렬(Heapsort)이란 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법으로서, 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다. 최대 힙을 구성하여 정렬하는 방법은 아래 예와 같다.</p><ol><li>n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다.</li><li>최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다.</li><li>가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다.</li><li>2와 3을 반복한다.<br>출처 - 위키백과</li></ol></blockquote><p>우선 힙(Heap)이 무엇인지 알아야 한다. 그리고 힙을 알기 전에 이진 트리(Binary Tree)에 대해 알아야 한다. 이진 트리란 컴퓨터 안에서 데이터를 표현할 때 데이터를 각 노드(Node)에 담은 뒤에 노드를 두 개씩 이어 붙이눈 구조이다. 이 때 트리 구조에 맞게 부모 노드에서 자식 노드로 가지가 뻗힌다. 이진 트리는 모든 노드의 자식 노드가 2개 이하인 노드이다.</p><ul><li><strong>이진 트리</strong> : 모든 노드의 자식 노드가 2개 이하인 트리 구조<div style="width: 380px; height: 380px;">  <img src="https://kyu9341.github.io/img/binarytree.png" style="width: 380px  ; height: 380px;"></div></li></ul><p>흔히 위와 같은 구조를 이진 트리라고 한다. <strong>여기서 트리(Tree)</strong> 라는 것은 말 그대로 가지를 뻗어나가는 것처럼 데이터가 서로 연결되어 있다는 것이다. 트리는 그 형태에 따라 종류가 다양한데 여기서는 위와 같은 이진 트리만 알면 된다. 이제 <strong>완전 이진 트리(Complete Binary Tree)</strong> 에 대해 알아보자.</p><p>완전 이진 트리는 데이터가 루트(Root)노드부터 시작하여 자식 노드가 왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가는 구조의 이진 트리이다. 즉, 완전 이진 트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽히 가득 찬 구조이다.</p><div style="width: 350px; height: 350px;">    <img src="https://kyu9341.github.io/img/cbt.png" style="width: 350px    ; height: 350px;"></div><p>이제 <strong>힙(Geap)</strong> 에 대해 알아보자. 힙은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다. 힙에는 최대 힙과 최소 힙이 존재하는데 최대 힙은 부모 노드가 자식 노드보다 큰 힙이며 최소 힙은 부모 노드가 자식 노드보다 작은 힙이다.</p><div style="width: 900px; height: 400px;">    <img src="https://kyu9341.github.io/img/heap.png" style="width: 900px    ; height: 400px;"></div><p>힙은 위와 같은 구조이며 일단 힙 정렬을 하기 위해서는 정해진 데이터를 힙 구조를 가지도록 만들어야 한다.</p><div style="width: 510px; height: 480px;">    <img src="https://kyu9341.github.io/img/heap1.png" style="width: 510px    ; height: 480px;"></div><p>힙 정렬을 수행하기 위해서는 <strong>힙 생성 알고리즘(Heapify Algorithm)</strong> 을 사용한다. 힙 생성 알고리즘은 특정한 하나의 노드에 대해서 수행하는 것이다. 또한 ‘하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태를 가정한다는 특징’이 있다. 위의 트리에서 5만 최대 힙 정렬을 수행해주면 전체 트리가 최대 힙 구조로 형성되는 상태이다.</p><p>힙 생성 알고리즘은 <strong>특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘</strong> 이다. 또한 위치를 바꾼 뒤에도 여전히 자식이 존재하는 경우 자식이 더이상 존재하지 않을때 까지 자식 중에서 더 큰 자식과 자신의 위치를 바꾸어야 한다. 즉, 위에서 5의 자식인 7과 4 중에서 더 큰 자식인 7과 5의 위치를 바꾸어 주면 된다. 바꾼 결과는 아래와 같다.</p><div style="width: 400px; height: 440px;">    <img src="https://kyu9341.github.io/img/heap2.png" style="width: 400px    ; height: 440px;"></div><p>위와 같이 힙 생성 알고리즘은 전체 트리를 힙 구조를 가지도록 만든다는 점에서 굉장히 중요한 알고리즘이다. 이러한 힙 생성 알고리즘의 시간 복잡도는 몇일까? 한 번 자식 노드로 내려갈 때마다 노드의 갯수가 2배씩 증가한다는 점에서 O(logN)이다. 예를 들어 데이터의 갯수가 1024개라면 10번 정도만 내려가도 된다는 뜻이다.</p><p>이제 예시를 보며 실제 힙 정렬 과정을 수행해보자.</p><p>7 6 5 8 3 5 9 1 6</p><p>위의 데이터를 오름차순으로 정렬한다고 해보자. 기본적으로 이진 트리를 표현하는 가장 쉬운 방법은 배열에 그대로 삽입하는 것이다. 현재 정렬할 데이터의 갯수가 9개이기 때문에 인덱스 0붙터 8까지 차례로 담아주면 된다.</p><table><thead><tr><th align="center"><center>0</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">7</td><td align="center">6</td><td align="center">5</td><td align="center">8</td><td align="center">3</td><td align="center">5</td><td align="center">9</td><td align="center">1</td><td align="center">6</td></tr></tbody></table><p>다시 말해 완전 이진 트리에 삽입이 되는 순서대로 인덱스를 붙여주는 것이다. 위 배열을 완전 이진 트리 형태로 출력하면 다음과 같다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt.png" style="width: 490px    ; height: 410px;"></div><p>말 그대로 배열에 있는 인덱스가 그대로 차례대로 트리로 표현된 것이다. 위와 같은 상황에서 힙 생성 알고리즘을 적용하여 전체 트리를 힙 구조로 만들면 된다. 이 때 데이터의 갯수가 N개 이므로 전체 트리를 힙 구조로 만드는 복잡도는 O(N*logN)이다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt1.png" style="width: 490px    ; height: 410px;"></div><p>그래서 결과적으로는 위와 같이 최대 힙이 구성된다. 이제부터 실제로 우리가 원하던 정렬을 직관적으로 수행할 수 있다. 루트(Root)에 있는 값을 가장 뒤쪽으로 보내면서 힙 트리의 크기를 1씩 빼주는 것이다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt2.png" style="width: 490px    ; height: 410px;"></div><p>위와 같이 9와 6을 바꾼 뒤에 9는 정렬이 완료된 것이므로 빨간색으로 표현한다. 이제 9를 제외하고 나머지 8개 원소를 기준으로 또 힙 생성 알고리즘(Heapify)를 수행한다. 결과는 다음과 같다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt3.png" style="width: 490px    ; height: 410px;"></div><p>이제 다시 가장 큰 숫자인 8이 루트에 존재한다. 이것을 가장 뒤쪽의 원소와 서로 바꾼다.</p><div style="width: 490px; height: 410px;">    <img src="https://kyu9341.github.io/img/bt4.png" style="width: 490px    ; height: 410px;"></div><p>그럼 위와 같이 8과 9가 가장 뒤에 배열되어 정렬된 것을 볼 수 있다. 이제 이 과정을 반복하면 된다. 힙 생성 알고리즘의 시간 복잡도는 O(logN)이고 전체 데이터의 갯수가 N개이므로 결과적으로 힙 정렬의 시간 복잡도는 O(N*logN)이라고 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> heap[number] = &#123; <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">printArray(heap, number);</span><br><span class="line"><span class="comment">// 전체 트리 구조를 최대 힙 구조로 바꾼다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; number; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = i;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> root = (c - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 자기 자신의 부모를 의미</span></span><br><span class="line"><span class="keyword">if</span> (heap[root] &lt; heap[c]) <span class="comment">// 부모보다 자식이 크다면 위치를 바꿈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">c = root; <span class="comment">// 부모의 인덱스로 변환하여 0이 될때까지 올라감</span></span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">printArray(heap, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 크기를 줄여가며 반복적으로 힙을 구성</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = number - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 마지막 인덱스부터 시작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 가장 큰 값을 맨 뒤로 보냄</span></span><br><span class="line"><span class="keyword">int</span> temp = heap[<span class="number">0</span>];</span><br><span class="line">heap[<span class="number">0</span>] = heap[i];</span><br><span class="line">heap[i] = temp;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 자식 중에 더 큰 값 찾기</span></span><br><span class="line"><span class="comment">// 옆의 값과 비교하여 더 큰 값의 인덱스를 c에 지정</span></span><br><span class="line"><span class="keyword">if</span> (heap[c] &lt; heap[c + <span class="number">1</span>] &amp;&amp; c &lt; i - <span class="number">1</span>) <span class="comment">// 범위를 넘지 않는 한에서</span></span><br><span class="line">c++;</span><br><span class="line"><span class="comment">// 루트보다 자식이 더 크다면 교환</span></span><br><span class="line"><span class="keyword">if</span> (heap[root] &lt; heap[c] &amp;&amp; c &lt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">root = c; <span class="comment">// 자식의 인덱스로 변환하여 정렬되지 않은 마지막 인덱스까지 진행</span></span><br><span class="line">&#125; <span class="keyword">while</span> (c &lt; i); <span class="comment">// 정렬된 인덱스 전까지 반복</span></span><br><span class="line">printArray(heap, number);</span><br><span class="line">&#125;</span><br><span class="line">printArray(heap, number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최대 힙을 이용하여 위와 같이 힙 정렬을 작성할 수 있으며 진행 과정은 다음과 같다.</p><div style="width: 200px; height: 200px;">    <img src="https://kyu9341.github.io/img/heapsort.png" style="width: 200px    ; height: 200px;"></div><p>힙 정렬은 병합 정렬과 다르게 별도로 추가적인 배열이 필요하지 않다는 점에서 메모리 측면에서 매우 효율적이다. 또한 항상 O(N*logN)을 보장할 수 있다는 점에서 아주 강력한 알고리즘이다. 하지만 단순히 속도만 놓고 비교하면 퀵 정렬이 평균적으로 더 빠르기 때문에 힙 정렬이 일반적으로 많이 사용되지는 않는다고 한다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221228342808" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221228342808</a><br><a href="https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC</a><br><a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;힙 정렬(Heap Sort)&lt;/strong&gt; 에 대해 알아보겠다. 힙 정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 또한 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기 때문에 반드
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>병합 정렬(Merge Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/27/algorithmMergeSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/27/algorithmMergeSort/</id>
    <published>2019-12-27T11:44:19.000Z</published>
    <updated>2020-01-03T01:21:09.360Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>병합 정렬(Merge Sort)</strong> 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 ‘분할 정복’방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.</p><p>퀵 정렬은 피벗 값에 따라서 편향되게 분할할 가능성이 있다는 점에서 최악의 경우 O(N^2)의 시간 복잡도를 가지지만 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(N*logN)을 보장한다.</p><h2 id="병합-정렬-Merge-Sort"><a href="#병합-정렬-Merge-Sort" class="headerlink" title="병합 정렬(Merge Sort)"></a>병합 정렬(Merge Sort)</h2><blockquote><p>합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다. 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다. 존 폰 노이만이 1945년에 개발했다. 하향식 합병 정렬에 대한 자세한 설명과 분석은 1948년 초 헤르만 골드스타인과 폰 노이만의 보고서에 등장하였다.<br>합병 정렬은 다음과 같이 작동한다.</p><ol><li>리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는</li><li>분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.</li><li>정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.</li><li>결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.</li><li>복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.</li></ol><p>출처 - 위키백과</p></blockquote><p>병합 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할한 뒤에 각자계산하고 나중에 합치는 방법을 채택한다. 즉, 기본 아이디어는 일단 정확히 반으로 나누고 나중에 정렬하는 것이다.</p><div style="width: 750px; height: 500px;">    <img src="https://kyu9341.github.io/img/mergeSort.png" style="width: 750px    ; height: 500px;"></div><p>위의 그림처럼 초기 상태의 배열에서 각각 절반씩 계속해서 나누어 크기가 1인 배열로 나눈다. 이후 다시 크기가 1인 배열 두 개씩 병합하며 정렬을 수행한다.(1단계) 그럼 크기가 2인 배열 4개가 되었을 것이고, 4개의 배열은 정렬이 되어있다. 다시 4개의 배열을 두 개씩 병합하여 크기가 4인 배열 2개가 되고, 이 과정에서 정렬이 수행된다.(2단계) 마지막으로 크기가 4인 배열 2개를 병합하여 크기가 8인 배열로 돌아가며 정렬이 된다.(3단계) 이러한 과정으로 진행이 되는데 이때 병합되는 과정은 3단계로 이루어진다. 그 이유는 초기 배열의 크기가 8이기 때문에 log(2)8 = 3 단계가 필요한 것이다.</p><p>따라서, 크기가 N인 배열을 정렬한다면 단계는 log(2)N을 유지하게 된다. 또한 데이터의 갯수만큼만 연산하면 되기 때문에 정렬 자체에 필요한 수행시간은 N이다. 결과적으로 총 시간 복잡도는 O(N*logN)이 된다.</p><p>위에서 병합이 되는 순간 정렬이 같이 된다고 했다. 그 과정을 한번 살펴보자.</p><p>1단계에서는 배열의 크기가 1이기 때문에 두 수만 비교하여 작은 수를 앞에 두면 된다.</p><p>2단계에서는 크기가 2인 배열 두 개를 병합하게 되므로 우선 각 배열에서 가장 작은 값을 비교한다. 이때, 각 배열은 정렬되어있는 상태이기 때문에 두 배열의 가장 앞에 있는 값을 서로 비교한다. 위의 그림을 예로 들면 [10, 21]과 [12, 20]에서 먼저 10과 12를 비교하게 되는 것이다. 10이 더 작으므로 10을 새로 만들어질 배열의 맨 앞에 둔다.</p><p> 그럼 [10, 21]이 있던 배열은 21만 남아있는 상태일 것이다. 그럼 21이 가장 작은 원소이므로 21과 [12, 20]이 들어있는 배열의 최솟값 12와 비교를 하여 12가 더 작으므로 새로 만들어질 배열의 두번째 자리에 12가 들어간다. [10, 12, - , - ] 와 같은 상태일 것이며 이제 남은 [ - , 21] 과 [ - , 20]를 비교하여 더 작은 20이 먼저 들어가 [10, 12, 20, 21]과 같이 정렬이 수행된다.</p><p> 3단계에서도 2단계와 마찬가지로 두 배열의 최솟값 부터 비교하게 되며 이 과정이 반복되어 정렬이 완료된다.</p><p> 이러한 과정을 잘 보면 각 부분 집합은 이미 정렬이 된 상태이므로 이미 정렬된 두 배열을 합치는 것은 N번의 연산만 수행하면 된다. 즉 시간 복잡도 O(N)이면 되는 것이다. 즉, 가로축은 N 세로축은 logN이므로 총 시간 복잡도가 O(N*logN)인 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> sorted[number]; <span class="comment">// 정렬 배열은 반드시 전역 변수로 사용(추가적인 배열)</span></span><br><span class="line"><span class="comment">// 정렬을 수행할 때 추가적인 배열이 필요, 필요할 때마다 배열을 생성한다면 비효율적임</span></span><br><span class="line"><span class="comment">// 전역변수로 모든 함수가 공통적으로 사용하도록 하여 메모리 소모를 최소화</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> middle, <span class="keyword">int</span> n)</span> <span class="comment">// 두 개의 정렬된 부분 배열을 이용해 새롭게 정렬된 배열을 생성하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// m : 시작점 , middle : 중간점, n : 끝점</span></span><br><span class="line"><span class="keyword">int</span> i = m; <span class="comment">// 좌측 부분 배열의 시작점</span></span><br><span class="line"><span class="keyword">int</span> j = middle + <span class="number">1</span>; <span class="comment">// 우측 부분 배열의 시작점</span></span><br><span class="line"><span class="keyword">int</span> k = m; <span class="comment">// 새로운 배열의 시작점</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 작은 순서대로 배열에 삽입</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 남은 데이터 삽입</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; middle) <span class="comment">// 왼쪽 배열이 먼저 모두 삽입된 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = j; t &lt;= n; t++) <span class="comment">// 오른쪽 배열을 순서대로 삽입</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 오른쪽 배열이 먼저 모두 삽입된 경우, (j &gt; n)인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = i; t &lt;= middle; t++) <span class="comment">// 왼쪽 배열을 순서대로 삽입</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 정렬된 배열을 실제 배열에 삽입</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = m; t &lt;= n; t++)</span><br><span class="line">a[t] = sorted[t];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> middle;</span><br><span class="line"><span class="comment">// 크기가 1보다 큰 경우</span></span><br><span class="line"><span class="keyword">if</span> (m &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">middle = (m + n) / <span class="number">2</span>;</span><br><span class="line">mergeSort(a, m, middle);</span><br><span class="line">mergeSort(a, middle + <span class="number">1</span>, n);</span><br><span class="line">merge(a, m, middle, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[number] = &#123; <span class="number">21</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">22</span> &#125;;</span><br><span class="line">printArray(arr, number);</span><br><span class="line">mergeSort(arr, <span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line">printArray(arr, number);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/merge.png" style="width: 250px    ; height: 200px;"></div><p>진행 과정을 출력해보면 위와 같은 과정으로 진행이 되는 것을 확인할 수 있다.</p><p>병합 정렬을 구현할 때 신경써야 할 부분은 정렬에 사용되는 배열은 전역 변수로 선언해야 한다는 것이다. 만약 함수 안에서 배열을 선언하면 매 번 배열을 선언해야하기 때문에 메모리 낭비가 크다. 이와 같이 병합 정렬은 기존의 데이터를 담을 추가적인 배열 공간이 필요하다는 점에서 메모리 활용이 비효율적인 단점이 있다.</p><p>병합 정렬은 일반적인 경우 퀵 정렬보다 느리지만 어떠한 상황에서도 O(N*logN)을 보장한다는 점에서 아주 효율적인 알고리즘이다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221242106787" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221242106787</a><br><a href="https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC</a><br><a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;병합 정렬(Merge Sort)&lt;/strong&gt; 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 ‘분할 정복’방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>삽입 정렬(Insertion Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/22/algorithmInsertionSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/22/algorithmInsertionSort/</id>
    <published>2019-12-22T02:44:19.000Z</published>
    <updated>2020-01-03T01:21:24.091Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 삽입 정렬에 대해 알아보겠다. 앞서 다루었던 정렬 알고리즘과 같은 시간복잡도인 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속한다.</p><h2 id="삽입-정렬-Selection-Sort"><a href="#삽입-정렬-Selection-Sort" class="headerlink" title="삽입 정렬(Selection Sort)"></a>삽입 정렬(Selection Sort)</h2><blockquote><p>삽입 정렬(揷入整列, insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.</p><p>출처 - 위키백과</p></blockquote><p>삽입 정렬은 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결한다. 다른 정렬 방식들은 무조건 위치를 바꾸는 방식이었다면 삽입 정렬은 필요할 때만 위치를 바꾸게 된다. 이와 같은 특성 때문에 선택 정렬이나 버블 정렬보다 빠르며 특정한 경우에서는 아주 빠르게 동작하기도 한다.</p><p>삽입 정렬은 현재 위치의 숫자가 앞의 숫자들의 어느 위치에 들어갈지 찾아 적절한 위치에 삽입되는 방식이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, index, temp;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = temp;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>삽입 정렬은 위와 같이 구현할 수 있으며 진행 과정은 아래와 같다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/insertsort.png" style="width: 250px    ; height: 200px;"></div><p>중간 과정에도 앞부분은 계속해서 정렬이 되어있는 것을 확인할 수 있다. 삽입 정렬은 앞서 말했듯이 선택 정렬과 버블 정렬보다는 뛰어나지만 최악의 경우는 앞의 정렬 방식과 같은 수만큼 연산이 일어난다. (O(N^2)) 하지만 2 3 4 5 6 7 8 9 10 1 과 같이 거의 정렬이 된 상태의 경우에는 아주 빠른 속도로 정렬이 가능하다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226806398" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226806398</a><br><a href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 삽입 정렬에 대해 알아보겠다. 앞서 다루었던 정렬 알고리즘과 같은 시간복잡도인 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속한다.&lt;/p&gt;
&lt;h2 id=&quot;삽입-정렬-Selection-Sort&quot;&gt;&lt;a href=&quot;#삽입-정렬-Sele
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>퀵 정렬(Quick Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/22/algorithmQuickSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/22/algorithmQuickSort/</id>
    <published>2019-12-22T02:44:19.000Z</published>
    <updated>2020-01-03T01:20:25.295Z</updated>
    
    <content type="html"><![CDATA[<p>이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 그 대표적인 빠른 알고리즘이 <strong>퀵 정렬</strong> 알고리즘이다.</p><h2 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬(Quick Sort)"></a>퀵 정렬(Quick Sort)</h2><blockquote><p>퀵 정렬은 분할 정복(divide and conquer) 방법을 통해 리스트를 정렬한다.</p><ol><li><p>리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗이라고 한다.</p></li><li><p>피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.</p></li><li><p>분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.</p></li></ol><p>재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.</p><p>출처 - 위키백과</p></blockquote><p>퀵 정렬은 대표적인 ‘분할 정복’ 알고리즘으로 평균 속도가 O(N*logN)이다. 이때 logN은 사실상 거의 상수라고 해도 무방할 만큼 작은 수이다.</p><p>예를 들어, 2^10 이 약 1,000 이고 2^20이 약 1,000,000 이므로 N이 1,000,000이라 하더라도</p><div style="width: 100px; height: 20px;">    <img src="http://chart.apis.google.com/chart?cht=tx&chl= log_2N = 20" style="width: 100px; height: 20px;"></div><p>밖에 되지 않는다. 즉, 굉장히 빠르다는 것을 알 수 있다.</p><p>퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬한다. 더 쉽게 말하자면 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눈다.</p><p>일반적으로 퀵 정렬 같은 경우는 피벗 값을 설정할 때 가장 앞에 있는 수를 피벗 값으로 설정한다.</p><p><strong>3</strong> <strong>7</strong> 8 1 5 9 6 10 <strong>2</strong> 4 에서 시작한다고 하면 피벗 값은 3이다.</p><p>이후 <strong>왼쪽에서 오른쪽으로 이동하며 피벗 값보다 큰 값</strong> 을 찾고 <strong>오른쪽부터 왼쪽으로 이동하며 피벗 값보다 작은 값</strong> 을 찾는다. 찾으면 두 값의 위치를 바꾸어준다.</p><p><strong>3</strong> 2 <strong>8 1</strong> 5 9 6 10 7 4</p><p>피벗 값은 3으로 유지하고 같은 방식으로 왼쪽에서 큰 값(8)과 오른쪽에서 작은 값(1)을 구해 바꿔주면</p><p><strong>3</strong> 2 <strong>8 1</strong> 5 9 6 10 7 4</p><p>이 되며 한 번 더 수행하면 마찬가지로 8과 1 인데 엇갈린 상태가 된다. 즉, 작은 값의 인덱스가 큰 값의 인덱스보다 작아지게 되면 엇갈린 상태인 것이다. 이때는 왼쪽에 있는 값(더 작은값)과 피벗 값인 3과 바꿔주면 된다.</p><p>1 2 <strong>3</strong> 8 5 9 6 10 7 4</p><p>여기까지 된다면 3은 정렬이 된 것이고 한 번 분할이 완료된 것이다. 3보다 왼쪽에 있는 수들은 모두 3보다 작고, 3보다 오른쪽에 있는 수들은 모두 3보다 큰 특징을 가진다.</p><p>이제 왼쪽 집합과 오른쪽 집합으로 나누어 피벗 값을 각각 설정하고 다시 퀵 정렬을 수행하게 된다. 왼쪽 집합에서는 1이 피벗 값이고 오른쪽 집합에서는 8이 피벗 값이 된다. 먼저 왼쪽부터 보면 1보다 큰 값은 오른쪽에 있고 작은 값은 없지만 왼쪽에 있다고 가정하고 1이 정렬이 된다.</p><p><strong>1</strong> 2 <strong>3</strong> <strong>8</strong> 5 9 6 10 7 4</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 9 6 10 7 4</p><p>마찬가지로 2도 정렬이 되며 오른쪽 부분을 보면 왼쪽에서부터 8보다 큰 값인 9를 찾고 오른쪽에서부터 8보다 작은 4를 찾게된다. 지금은 엇갈리지 않았으므로 9와 4를 바꿔준다.</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 4 6 10 7 9</p><p>마찬가지로 10과 7을 선택하게 되고 바꿔준다.</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 4 6 7 10 9</p><p>여기서 한번 더 수행하면 7과 10이 엇갈린 상태이므로 7과 8의 위치가 바뀌어</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> 7 5 4 6 <strong>8</strong> 10 9</p><p>위와 같이 다시 8을 기준으로 왼쪽 집합과 오른쪽 집합으로 나뉘어 왼쪽은 8보다 작은 값들만, 오른쪽은 8보다 큰 값들만 모이게 된다.</p><p>이러한 과정을 계속해서 반복하면 모두 정렬이 수행된다.</p><p>퀵 정렬처럼 분할을 하여 연산을 하면 빠른 이유에 대해 조금 더 살펴보면</p><p>1 2 3 4 5 6 7 8 9 10 이 있을 때</p><p>N^2 = 10 * 10 = 100 인 반면</p><p>1 2 3 4 5 -&gt; 5 * 5 = 25</p><p>6 7 8 9 10 -&gt; 5 * 5 = 25</p><p>가 되므로 분할하여 구한 후 더하면 50이 되며 100보다 훨씬 작은 횟수의 연산으로 정렬을 수행할 수 있다. 이것이 분할 정복이 강력한 이유이다.</p><p>이때 2씩 계속해서 나누어지는 과정을 log_(2) N 으로 표현하게 된다.</p><p>즉, 데이터의 개수가 N이고 반씩 쪼개 들어가기 때문에 O(N*log_(2) N)이라고 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> <span class="comment">// start, end -&gt; 부분집합의 시작과 끝 인덱스</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>) <span class="keyword">return</span>; <span class="comment">// 원소가 1개인 경우</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key = start; <span class="comment">// 피벗 값 첫번째 원소의 인덱스</span></span><br><span class="line"><span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) <span class="comment">// 엇갈릴 때까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (data[i] &lt;= data[key]) <span class="comment">// 키 값보다 큰 값을 만날 때까지 이동</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (data[j] &gt;= data[key] &amp;&amp; j &gt; start) <span class="comment">// 키 값보다 작은 값을 만날 때까지 이동</span></span><br><span class="line">&#123; <span class="comment">// 범위를 넘어가지 않도록 j &gt; start를 걸어줌</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt; j) <span class="comment">// 현재 엇갈린 상태면 작은 값(j)을 키 값과 교체</span></span><br><span class="line">&#123;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j] = data[key];</span><br><span class="line">data[key] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 엇갈리지 않은 상태라면 i와 j를 교체</span></span><br><span class="line">&#123;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j] = data[i];</span><br><span class="line">data[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">quickSort(data, start, j - <span class="number">1</span>);</span><br><span class="line">quickSort(data, j + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[number] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">quickSort(data, <span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 : "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 재귀함수를 이용하여 작성할 수 있고 아래와 같이 정렬이 진행된다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/quicksort.png" style="width: 250px    ; height: 200px;"></div><p>퀵 정렬은 평균 시간 복잡도는 O(N*logN)이지만 최악의 경우 시간 복잡도는 O(N^2)이 되기도 한다. 이미 정렬이 되어있는 경우나 거의 정렬이 되어있는 경우에는 퀵 정렬의 효율이 매우 떨어진다. 반면 삽입 정렬은 이런 경우를 빠르게 해결할 수 있다. 즉, 정렬할 데이터의 특성에 따라 적절한 정렬 알고리즘을 사용하는 것이 중요하다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226813382" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226813382</a><br><a href="https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>버블정렬(Bubble Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/21/algorithmBubbleSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/21/algorithmBubbleSort/</id>
    <published>2019-12-21T08:31:15.000Z</published>
    <updated>2020-01-03T01:34:05.214Z</updated>
    
    <content type="html"><![CDATA[<p>저번 포스팅에서는 선택정렬에 대해 공부해보았고 이번에는 버블 정렬에 대해 알아보겠다. 마찬가지로 일련의 숫자들을 오름차순으로 정렬하는 문제이다.</p><h2 id="버블-정렬"><a href="#버블-정렬" class="headerlink" title="버블 정렬"></a>버블 정렬</h2><blockquote><p>거품 정렬(Bubble sort)은 두 인접한 원소를 검사하여 정렬하는 방법이다. 시간 복잡도가 O(n^2)로 상당히 느리지만, 코드가 단순하기 때문에 자주 사용된다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다.</p><p>출처 - 위키백과</p></blockquote><p>버블 정렬 또한 선택 정렬과 같이 아주 직관적인 해결방법인데 바로 가까이에 있는 두 숫자끼리 비교를 하여 더 작은 숫자를 앞으로 보내주는 것을 반복하는 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">9</span> - i; j++) <span class="comment">// 버블정렬은 뒤쪽부터 정렬이 되므로 9-i만큼만 반복하면 된다.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드로 표현할 수 있고 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 버블 정렬은 뒤쪽부터 정렬이 수행되는 것을 확인할 수 있다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/bubblesort.png" style="width: 250px    ; height: 200px;"></div><p>이제 시간복잡도를 확인해 보자. 버블 정렬도 선택 정렬과 마찬가지로 10 + 9 + 8 + 7 + 6 + 5 + .. + 1 만큼 연산을 수행하므로 O(N^2)으로 동일하지만 버블 정렬은 각 싸이클마다 모두 자리를 바꿔주는 연산을 수행하기 때문에 선택 정렬보다 훨씬 비효율적이고 정렬 알고르즘 중에 가장 느린 알고리즘이다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226803544" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226803544</a><br><a href="https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번 포스팅에서는 선택정렬에 대해 공부해보았고 이번에는 버블 정렬에 대해 알아보겠다. 마찬가지로 일련의 숫자들을 오름차순으로 정렬하는 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;버블-정렬&quot;&gt;&lt;a href=&quot;#버블-정렬&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>선택정렬(Selection Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/21/algorithmSelectionSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/21/algorithmSelectionSort/</id>
    <published>2019-12-21T05:12:42.000Z</published>
    <updated>2020-01-03T01:20:10.232Z</updated>
    
    <content type="html"><![CDATA[<p>이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주기 때문이라고 한다. 그래서 여러가지의 정렬 알고리즘을 먼저 배우고 알고리즘의 시간 복잡도에 대해 단계적으로 이해해 보자.</p><h2 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬(Selection Sort)"></a>선택 정렬(Selection Sort)</h2><blockquote><h3 id="선택-정렬"><a href="#선택-정렬" class="headerlink" title="선택 정렬"></a>선택 정렬</h3><p>선택 정렬은 제자리 정렬 알고리즘의 하나로, 다음와 같은 순서로 이루어진다.</p><ol><li>주어진 리스트 중에 최소값을 찾는다</li><li>그 값을 맨 앞에 위치한 값과 교체한다.(패스)</li><li>맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.</li></ol><p>출처 - 위키백과</p></blockquote><p>위의 설명처럼 선택 정렬은 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘이다. 예를 들어, 3 1 2 5 4 라는 순서의 숫자들을 오름차순으로 정렬한다고 생각해보자. 먼저 리스트의 최솟값을 구하여 가장 앞의 숫자와 위치를 바꾸게 되면 1이 최솟값이므로 3과 자리를 바꾸어 1 3 2 5 4 가 된다. 다음 1을 뺀 나머지의 리스트의 최솟값은 2 이므로 3과 자리를 바꾸어 1 2 3 5 4가 되고, 다음은 3이 최솟값이므로 넘어가서 같은 과정을 반복하면 1 2 3 4 5 로 오름차순 정렬이 끝나게 된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, <span class="built_in">min</span>, index, temp; <span class="comment">// min : 최솟값, index : 최솟값의 인덱스</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">min</span>) <span class="comment">// 최솟값을 구함</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = <span class="built_in">array</span>[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp = <span class="built_in">array</span>[i]; <span class="comment">// 최솟값과 자리 바꾸기</span></span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">min</span>;</span><br><span class="line"><span class="built_in">array</span>[index] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 선택정렬을 작성할 수 있다. 또한 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 선택 정렬은 앞쪽부터 정렬이 수행되는 것을 확인할 수 있다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/selectionsort.png" style="width: 250px    ; height: 200px;"></div><p>이제 선택 정렬을 수행하는데에 얼마만큼의 시간이 걸리는지를 시간복잡도로 표현할 수 있는데 계산 방법은 다음과 같다.</p><p> 1 2 3 4 5 6 7 8 9 10 의 10개의 수를 정렬한다고 생각하면</p><p> 10 + 9 + 8 + … + 1 의 수 만큼 비교연산을 수행해야 한다. 즉, 10 * (10 + 1) / 2 = 55</p><p> 이것을 등차수열의 식에 의해 표현하면 <strong>N * (N + 1) / 2</strong> 로 표현할 수 있다. 즉, 이 알고리즘의 수행시간을 앞의 수식처럼 표현할 수가 있다는 것이다. 이때 일반적으로 컴퓨터에서는 2로 나눈다거나 1을 더한다거나 하는 것은 N이 매우 커지는 경우에는 무시할 수 있기 때문에 간단하게 더하거나 나누거나 하는 연산들은 모두 무시를 하게 된다.(가장 큰 차수만 보고 판단) 따라서 위의 수식이 <strong>N * N</strong> 으로 표현 할 수 가있다는 것이다.</p><p> 이것을 O(N * N) =&gt; O(N^2)이라고 표시할 수 있는데 이와 같은 표기법은 특정한 알고리즘의 수행시간을 간략하게 표현하는 방법이며 O(Big-O) 표기법이라 한다.</p><p>일반적으로 정렬 알고리즘에서 N^2의 복잡도는 아주 비효율적이고 느린 속도라고 할 수 있다.</p><blockquote><p>참조<br><a href="https://blog.naver.com/ndb796/221226800661" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226800661</a><br><a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 부분 Mosaic</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing6/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing6/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:13.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="논리-연산"><a href="#논리-연산" class="headerlink" title="논리 연산"></a>논리 연산</h2><p>영상을 처리하기 위하여 단순하게 수를 더하거나 빼는 연산만을 수행하는 것이 아니라 영상에 대하여 논리적인 연산을 수행하여 원하는 결과를 얻을 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle</span><span class="params">(uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">double</span> diameter)</span> <span class="comment">// 원하는 반지름의 크기로 원 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> tmp, xSquare, ySquare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Row;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line">ySquare = (<span class="built_in">abs</span>(Row / <span class="number">2</span> - i)) * (<span class="built_in">abs</span>(Row / <span class="number">2</span> - i)); <span class="comment">// (Row/2, Col/2) 는 중심의 좌표</span></span><br><span class="line">xSquare = (<span class="built_in">abs</span>(Col / <span class="number">2</span> - j)) * (<span class="built_in">abs</span>(Col / <span class="number">2</span> - j));</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">sqrt</span>(ySquare + xSquare); <span class="comment">// tmp는 현재 위치의 중심과의 거리 - 피타고라스 정리 x^2 + y^2 = z^2</span></span><br><span class="line"><span class="comment">//sqrt() : 제곱근을 구하는 함수</span></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; diameter) Result[i][j] = <span class="number">255</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">else</span> Result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 반지름의 길이를 매개변수로 받아 원하는 반지름을 가지는 원을 생성해주는 함수이다. 중심과의 거리를 이용하여 반지름보다 큰 범위의 값은 모두 0으로 작은 값은 모두 255로 변환하게 된다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/circle100.png" style="width: 512px    ; height: 512px;"></div><p>위의 이미지는 반지름이 100인 circle image이다. 다음은 두 이미지를 인자로 받아 and 연산과 or 연산을 수행해주는 함수이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaskOr</span><span class="params">(uchar** in1Img, uchar** in2Img, uchar** outImg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// or 연산</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outImg[i][j] = in1Img[i][j] | in2Img[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaskAnd</span><span class="params">(uchar** in1Img, uchar** in2Img, uchar** outImg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// and 연산</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outImg[i][j] = in1Img[i][j] &amp; in2Img[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 함수들을 이용하여 lena영상의 얼굴 부분만을 구할 수 있다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenaface.png" style="width: 512px    ; height: 512px;"></div>위의 이미지는 lena와 circle을 AND연산을 수행하여 얻은 결과이다.(diameter=150)<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenaor.png" style="width: 512px    ; height: 512px;"></div>위의 이미지는 lena와 circle을 OR연산을 수행하여 얻은 결과이다.<p>이를 응용하면 원하는 부분만 모자이크 처리를 수행하는 것이 가능하다. 먼저 lena와 circle이미지를 OR연산을 수행한 뒤 앞서 해보았던 mosaic 함수를 이용하여 모자이크된 lena영상과 AND연산을 수행하면 된다. 하지만 위와 같은 방법을 사용하면 메모리를 여러 개 할당해야하는 불편함과 위치를 원하는 곳으로 지정할 수 없는 불편함 있기 때문에 다음과 같은 함수를 작성하였다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleMosaic</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> diameter, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, a, b;</span><br><span class="line"><span class="keyword">double</span> tmp, xSquare, ySquare, avg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mtmp, count;</span><br><span class="line"></span><br><span class="line">mosaic(img, outimg, Row, Col, block); <span class="comment">// outimg에 모자이크된 이미지 저장</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line">ySquare = (y - j) * (y - j);</span><br><span class="line">xSquare = (x - i) * (x - i);</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">sqrt</span>(ySquare + xSquare); <span class="comment">// 피타고라스 정리 -&gt; 중심과의 거리 찾기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; diameter) outimg[i][j]; <span class="comment">// 현재 픽셀의 위치가 입력받은 반지름보다 작으면 모자이크된 이미지를 유지</span></span><br><span class="line"><span class="keyword">else</span> outimg[i][j] = img[i][j]; <span class="comment">// 그렇지 않으면 원본이미지를 대입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 함수는 원하는 좌표와 반지름을 매개변수로 받아 해당하는 위치에 모자이크 처리를 수행하는 함수이다. mosaic함수는<a href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/12/ImageProcessing2.html">이전 포스팅</a>에서 사용했던 함수이고 circle이미지를 제작할 때 사용했던 방식으로 작성하였다. 위의 함수를 이용하면 다음과 같은 이미지도 출력이 가능하다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/partMosaic.png" style="width: 512px    ; height: 512px;"></div>부분 모자이크(300,350) (diameter=100, block=8)## 응용<p>이번엔 원형이 아닌 사각형 이미지를 생성하는 함수와 그 함수를 응용하여 사각형으로 부분 모자이크를 수행하는 함수이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Square</span><span class="params">(uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">double</span> diameter)</span> <span class="comment">// 사각형 이미지 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> tmp;</span><br><span class="line">diameter = diameter / <span class="number">2</span>; <span class="comment">// 사각형의 한변의 길이를 입력받았으므로 1/2 해줌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= (Row / <span class="number">2</span>) - diameter &amp;&amp; i &lt;= (Row / <span class="number">2</span>) + diameter &amp;&amp; j &gt;= (Col / <span class="number">2</span>) - diameter &amp;&amp; j &lt;= (Col / <span class="number">2</span>) + diameter)</span><br><span class="line">Result[i][j] = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span> Result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SquareMosaic</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> diameter, <span class="keyword">int</span> block)</span> <span class="comment">// 사각형 부분 모자이크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">diameter = diameter / <span class="number">2</span>; <span class="comment">// 사각형의 한 변의 길이를 입력받았으므로 1/2 해줌</span></span><br><span class="line"></span><br><span class="line">mosaic(img, outimg, Row, Col, block);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= x - diameter &amp;&amp; i &lt;= x + diameter &amp;&amp; j &gt;= y - diameter &amp;&amp; j &lt;= y + diameter) <span class="comment">// 사각형 범위 지정</span></span><br><span class="line">outimg[i][j]; <span class="comment">// 사각형 내부는 모자이크 이미지 유지</span></span><br><span class="line"><span class="keyword">else</span> outimg[i][j] = img[i][j]; <span class="comment">// 사각형 외부를 원본 대입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사각형의 한 변의 길이를 입력받아 사각형 이미지 및 사각형 부분 모자이크를 수행하며 결과는 다음과 같다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/square.png" style="width: 512px    ; height: 512px;"></div>Square Image (diameter=200)<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenasquare.png" style="width: 512px    ; height: 512px;"></div>사각형 부분 모자이크(300,300) (diameter=150, block=8)<p>위와 같이 사각형 모양으로도 부분 모자이크를 구현할 수 있다. 영상처리에서 논리 연산은 원하는 영상의 모양을 얻거나 제거하기 위한 기법으로 사용되며 얼굴에서 치아나 눈 등 특별히 보고 싶은 부분이 있다면 특정한 영상을 이용하여 원하는 결과 영상을 얻을 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;논리-연산&quot;&gt;&lt;a href=&quot;#논리-연산&quot; class=&quot;headerlink&quot; title=&quot;논리 연산&quot;&gt;&lt;/a&gt;논리 연산&lt;/h2&gt;&lt;p&gt;영상을 처리하기 위하여 단순하게 수를 더하거나 빼는 연산만을 수행하는 것이 아니라 영상에 대하여 논리적인
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 공간 필터링</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing9/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing9/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:27.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spatial-Filtering-공간-필터링"><a href="#Spatial-Filtering-공간-필터링" class="headerlink" title="Spatial Filtering (공간 필터링)"></a>Spatial Filtering (공간 필터링)</h2><p>영상처리에서 필터링은 영상 내에서 특별히 원하는 성분을 추출해내는 과정에 대한 용어이다. 필터링은 크게 두 가지로 나뉘는데 하나는 저주파 필터링이고 하나는 고주파 필터링이다. 필터링의 용어는 모두 주파수 영역에서 다루는 용어를 그대로 사용한다. 공간필터링이라는 용어는 영상을 입력으로 하여 출력을 영상으로 내어주는 공간상에서의 결과를 보여주는데 따른 용어이다.</p><h3 id="Spatial-Smoothing-Filtering"><a href="#Spatial-Smoothing-Filtering" class="headerlink" title="Spatial Smoothing Filtering"></a>Spatial Smoothing Filtering</h3><p>공간필터링의 처음은 저주파 필터링의 특징을 보여주는 Smoothing Filtering이라고도 한다. 일반적으로 평균을 취하는 형태로 그 결과를 얻을 수 있으며 주파수 상에서의 처리가 아닌 경우 지정된 필터를 사용하여 영상처리를 수행한다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/gaussainFiltering.png" style="width: 800px    ; height: 400px;"></div><p>위의 영상은 가우시안 스무딩 필터를 적용하여 얻은 결과이다. 스무딩 필터의 특징은 영상 내 잡음제거가 주요한 목적이며 고주파 성분을 제거하여 화면을 부드럽게 만들어주는 것이 특징이다.</p><div style="width: 400px; height: 200px;">    <img src="https://kyu9341.github.io/img/filter.png" style="width: 400px    ; height: 200px;"></div><p>위의 표는 각각 가우시안 필터와 평균 필터인데 평균 필터는 모두 같은 값으로 나누는 반면, 가우시안 필터는 가운데 부분의 값을 좀 더 큰 값으로 할당하여 중심 값을 보존하면서 주변의 값에 대한 평균을 취하는 형태로, 원본 형태가 살아있는 부드러운 결과 영상을 보여준다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/averagelena.png" style="width: 800px    ; height: 400px;"></div><p>위의 영상은 3x3 Average Filter를 사용한 결과 영상이며 3x3 윈도우 내의 평균값에 대한 영상의 결과의 부드러움이 아주 약하게 나타나는 것을 알 수 있다. 윈도우 크기에 따라 스무딩 효과의 차이가 크게 나타나며 이러한 결과는 어떤 필터를 사용하는가에 따라 그 결과가 확연히 달라진다.<br> 영상 필터링을 위한 처리에서 중요한 요소 중의 하나가 외곽 부분에 대한 처리이다. 일반적으로 영상의 외곽 부분에 대한 처리는 크게 3가지로 구분할 수 있다.</p><ol><li>주변에 0을 채워 넣어 영상 외곽 부분의 값을 0이라 가정하고 필터링을 수행<br>(zero padding)</li><li>대칭되는 영상이 계속적으로 존재한다는 가정 하에 영상의 외곽부분을 처리(대칭 기법)</li><li>영상이 회선의 특징을 가지고 반복된다는 가정 하에 영상의 외곽부분을 처리<br>어떤 방법을 사용하던지 영상의 외곽 경계선 영역 몇 칸에 대한 처리이기 때문에 영상의 선명도에는 커다란 영향을 미치지 않는다. 그렇지만 최종적으로 원하는 결과를 얻기 위해서는 어떤 방법을 사용할지에 대해 고민해야 할 것이다.</li></ol><p>다음은 각각 jet image와 livingroom image에 가우시안 필터와 평균 필터를 적용시킨 모습이다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/jetga.png" style="width: 800px    ; height: 400px;"></div><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/livingroomGA.png" style="width: 800px    ; height: 400px;"></div><p>가우시안 필터링과 스무딩 필터링의 차이는 필터 계수의 값에 의한 원본 영상의 영향이라고 생각하면 된다. 기본적으로 스무딩 필터는 원 영상을 뭉개는 효과가 나타나기 때문에 전체적인 모양은 흐릿한 결과를 보여주게 되는데 이러한 특성 때문에 잡음 제거를 위하여 많이 사용한다.</p><p>다음의 코드는 가우시안 필터와 평균 필터를 사용하는 코드이며 그 아래의 코드는 컨볼루션을 수행하는 코드이다. 잠깐 컨볼루션에 대해 알아보겠다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mod == <span class="number">10</span>) <span class="comment">// Average nad Gaussian Filtering</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag = 0 -&gt; Gaussian Filtering\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag = 1 -&gt; Average Filtering\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag : "</span>); <span class="comment">// 0 : Gaussian , 1 : Average</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line">gaussMask = d_alloc(block_size, block_size);</span><br><span class="line">aveMask = d_alloc(block_size, block_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//gaussian mask 설정</span></span><br><span class="line">gaussMask[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// average mask 설정</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">aveMask[i][j] = <span class="number">1</span> / <span class="number">9.</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Start Simple Filtering \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">convolution(gaussMask, block_size, Col, Row, img, outimg);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">convolution(aveMask, block_size, Col, Row, img, outimg);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag must be 0 or 1 \n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Finished Simple Filtering \n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convolution</span><span class="params">(<span class="keyword">double</span>** h, <span class="keyword">int</span> F_length, <span class="keyword">int</span> size_x, <span class="keyword">int</span> size_y, uchar** image1, uchar** image2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  컨볼루션 계산은 마스크와 이미지 상에 대응되는 값끼리 곱하여 모두 더하여 구하며, 결과값을 결과 영상의 현재 위치에 기록</span></span><br><span class="line"><span class="keyword">int</span> i, j, x, y;</span><br><span class="line"><span class="keyword">int</span> margin, indexX, indexY;</span><br><span class="line"><span class="keyword">double</span> sum, coeff;</span><br><span class="line"></span><br><span class="line">margin = (<span class="keyword">int</span>)(F_length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_y; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size_x; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; F_length; y++)</span><br><span class="line">&#123;</span><br><span class="line">indexY = i - margin + y;</span><br><span class="line"><span class="keyword">if</span> (indexY &lt; <span class="number">0</span>) indexY = -indexY;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (indexY &gt;= size_y) indexY = (<span class="number">2</span> * size_y - indexY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; F_length; x++)</span><br><span class="line">&#123;</span><br><span class="line">indexX = j - margin + x;</span><br><span class="line"><span class="keyword">if</span> (indexX &lt; <span class="number">0</span>) indexX = -indexX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (indexX &gt;= size_x) indexX = (<span class="number">2</span> * size_x - indexX - <span class="number">1</span>); <span class="comment">// 외곽 처리 (대칭 기법(시메트릭)??)</span></span><br><span class="line"></span><br><span class="line">sum += h[y][x] * (<span class="keyword">double</span>)image1[indexY][indexX]; <span class="comment">// 마스크의 각 값을 이미지의 픽셀 값과 곱하여 모두 더해준다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum += 128; // 양각 효과를 보기 위해 추가 -&gt; 이부분만 다름</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clipping</span></span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0.</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) sum = <span class="number">255</span>;</span><br><span class="line">image2[i][j] = (uchar)sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Convolution-합성곱"><a href="#Convolution-합성곱" class="headerlink" title="Convolution (합성곱)"></a>Convolution (합성곱)</h2><p>Convolution은 합성곱이라는 뜻이다. 특정한 크기의 필터를 사용하여 이미지의 각 픽셀을 지나가며 필터의 위치에 해당하는 픽셀과 모두 곱한 후 그 곱한 값을 모두 더하여 현재 중앙 픽셀 값에 넣어주는 것이다.</p><div style="width: 512px; height: 256px;">    <img src="https://kyu9341.github.io/img/convolution1.png" style="width: 512px    ; height: 256px;"></div><p>위의 그림처럼 이미지에서 합성곱이란, 필터를 이동시켜가며 이미지와 곱한 결과를 모두 더하는 것인데, 이러한 필터를 어떤 값을 넣어 사용하느냐에 따라 이미지의 색상, 밝기, 엣지 추출등 여러 가지 기능을 수행할 수 있다. 또한 필터는 주로 커널이라고 부르기도 한다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/splena.png" style="width: 512px    ; height: 512px;"></div><h3 id="Median-Filter-미디안-필터"><a href="#Median-Filter-미디안-필터" class="headerlink" title="Median Filter (미디안 필터)"></a>Median Filter (미디안 필터)</h3><p>미디언 필터링은 비선형 필터로 수학적인 증명이 가능한 필터가 아니다. 수학적으로 증명이 어렵다는 이야기는 그 결과를 예측할 수 없는 이상한 방향으로 갈 수 있다는 뜻이기도 하다. 미디언 필터링이라는 용어는 영상의 중간 값을 결과로 취하기 때문에 붙여진 이름이다. 미디언 필터는 Max Filter, Min Filter와 더불어 영상 내에 존재하는 값을 이용하여 결과를 얻는 대표적인 비선형 필터이다. 영상 내에서 3x3, 혹은 5x5와 같은 윈도우 크기를 정하여 그 크기 안에 있는 영상의 순서를 가장 작은 수부터 큰 수까지 정렬을 수행하여 그 결과의 중간 값을 원하는 결과 값으로 대체하는 필터링 기법이다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/3355lena.png" style="width: 800px    ; height: 400px;"></div><p>미디언 필터링은 salt-and-pepper 잡음에 강한 특성을 가지고 있어서 영상 내 잡음 성분이 salt-and-pepper 잡음 성분인 경우 다른 어떤 필터링 결과보다 우수한 결과를 보여준다.</p><p>위의 영상을 보면 salt-and-pepper 잡음이 있는 lena영상에 대해 미디언 필터링을 수행한 결과 존재하던 잡음이 거의 사라진 것을 볼 수 있으며 5x5의 커널로 미디언 필터링을 수행한 결과를 보면 하얀 점이나 검은 점은 보이지 않으나 영상에 전체적으로 더 많은 스무딩 현상이 발생한 것을 확인할 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(uchar* Sort, uchar* median_value, <span class="keyword">int</span> Mode, <span class="keyword">int</span> filterSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, x;</span><br><span class="line">uchar temp, swap;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; filterSize * filterSize; x++)</span><br><span class="line">&#123;</span><br><span class="line">temp = Sort[x];</span><br><span class="line"><span class="keyword">for</span> (i = x; i &lt; filterSize * filterSize - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= Sort[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap = temp;</span><br><span class="line">temp = Sort[i + <span class="number">1</span>];</span><br><span class="line">Sort[i + <span class="number">1</span>] = swap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Sort[x] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Mode == <span class="number">-1</span>)</span><br><span class="line">* median_value = (uchar)Sort[<span class="number">0</span>]; <span class="comment">// median filter의 중앙값을 필터내의 최솟값으로 설정</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Mode == <span class="number">0</span>)</span><br><span class="line">* median_value = (uchar)Sort[filterSize * filterSize / <span class="number">2</span>]; <span class="comment">// median filter의 중앙값을 필터내의 중간값으로 설정</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Mode == <span class="number">1</span>)</span><br><span class="line">* median_value = (uchar)Sort[filterSize * filterSize - <span class="number">1</span>]; <span class="comment">// median filter의 중앙값을 필터내의 최대값으로 설정</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">median</span><span class="params">(uchar** inImg, uchar** outImg, <span class="keyword">int</span> ROW, <span class="keyword">int</span> COL, <span class="keyword">int</span> Mode, <span class="keyword">int</span> filterSize)</span> <span class="comment">// Median Filtering</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, x, y, z, count = <span class="number">0</span>;</span><br><span class="line">uchar median_value; <span class="comment">// 필터의 중앙값</span></span><br><span class="line">uchar* Sort;</span><br><span class="line">Sort = (uchar*)<span class="built_in">malloc</span>(filterSize * filterSize * <span class="keyword">sizeof</span>(uchar)); <span class="comment">// 필터의 마스크값을 정렬해 저장할 포인터 배열 동적할당</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">outImg[i][j] = inImg[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW - filterSize; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL - filterSize; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; filterSize; x++)</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; filterSize; y++)</span><br><span class="line">Sort[filterSize * x + y] = inImg[i + x][j + y];</span><br><span class="line">Bubble_sort(Sort, &amp;median_value, Mode, filterSize);</span><br><span class="line">outImg[i + <span class="number">1</span>][j + <span class="number">1</span>] = median_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(Sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 미디언 필터링을 수행하는 함수이다. 입력받은 필터사이즈에 따라 메모리를 할당하여 필터를 생성하고 버블 정렬 알고리즘을 통해 정렬을 수행하여 중간 값을 찾아낸다. 또한 Max필터와 Min필터도 구현이 되어있는데 Max, Min 필터는 미디언 필터와 같이 순서에 기반한 필터로 필터 내의 최댓값, 최솟값을 결과로 취하는 필터이다. salt-and-pepper잡음을 가지는 lena영상에 Max, Min 필터를 적용한 결과는 아래와 같다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/splenamaxmin.png" style="width: 800px    ; height: 400px;"></div><p>위의 필터링 결과를 보면 알 수 있듯이 잘못 사용한 필터는 수용하기 힘든 결과를 나타내기도 한다. Max Min 필터가 성능이 나쁜 것이 아니라 현재 잡음 상태에 적절하지 않은 것이다. 모든 필터링은 그 특성에 맞는 작업을 수행하기에 가장 적합한 필터를 찾는 것이 중요하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spatial-Filtering-공간-필터링&quot;&gt;&lt;a href=&quot;#Spatial-Filtering-공간-필터링&quot; class=&quot;headerlink&quot; title=&quot;Spatial Filtering (공간 필터링)&quot;&gt;&lt;/a&gt;Spatial Filt
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - Add Noise</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing5/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing5/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:10.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Add-Noise"><a href="#Add-Noise" class="headerlink" title="Add Noise"></a>Add Noise</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">uniform</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>((<span class="keyword">double</span>)(rand() &amp; RAND_MAX) / RAND_MAX - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gaussian</span><span class="params">()</span> <span class="comment">// 가우시안 난수 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">ready</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> gstore;</span><br><span class="line"><span class="keyword">double</span> v1, v2, r, fac, gaus;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">uniform</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ready</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v1 = <span class="number">2.</span> * uniform();</span><br><span class="line">v2 = <span class="number">2.</span> * uniform();</span><br><span class="line">r = v1 * v1 + v2 * v2;</span><br><span class="line">&#125; <span class="keyword">while</span> (r &gt; <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">fac = <span class="built_in">sqrt</span>(<span class="number">-2.</span> * <span class="built_in">log</span>(r) / r);</span><br><span class="line">gstore = v1 * fac;</span><br><span class="line">gaus = v2 * fac;</span><br><span class="line"><span class="built_in">ready</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ready</span> = <span class="number">0</span>;</span><br><span class="line">gaus = gstore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(gaus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddNoise</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// 가우시안 난수를 더해 잡음 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"></span><br><span class="line">outimg[i][j] = img[i][j] + gaussian() * <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 가우시안 난수를 생성하는 함수와 그 함수를 이용하여 이미지에 잡음을 더해주는 함수이다. 위의 함수를 사용할 때 메인 함수에 srand(time(NULL)); 를 넣어주어야 랜덤 값이 정상적으로 발생한다. 아래는 가우시안 랜덤 잡음에 lena영상을 더하여 얻은 잡음가산 영상이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenanoise.png" style="width: 512px    ; height: 512px;"></div><p>영상의 원 값에 화소별로 랜덤 잡음을 더하여 그 결과 값으로 얻은 것으로 잡음이 심한 가우시안 잡음은 제거하는 것이 매우 어렵다. 영상에 더해진 잡음이 가우시안 잡음처럼 평균이 0인 값이라면 잡음 영상을 계속적으로 더해 좋은 결과 영상을 얻을 수 있다.</p><p>다음의 코드를 보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RmNoise</span><span class="params">(uchar** img, <span class="keyword">int</span>** tempimg, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> count)</span> <span class="comment">// 잡음영상을 더해 잡음 제거</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; count; k++) &#123; <span class="comment">// count : 잡음영상 더할 횟수</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">tempimg[i][j] += (img[i][j] + gaussian() * <span class="number">50</span>);</span><br><span class="line"><span class="comment">// unsigned char 는 0~255 의 값만을 지니기 때문에</span></span><br><span class="line"><span class="comment">// int형으로 선언하여 누적시킴</span></span><br><span class="line"><span class="comment">//printf("%lf\n", gaussian() * 50);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">temp = tempimg[i][j] / count; <span class="comment">// 누적 값을 평균내어 temp에 저장</span></span><br><span class="line"><span class="comment">//printf("temp : %d\n", temp);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span>) <span class="comment">// clipping</span></span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">outimg[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; <span class="number">255</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="number">255</span>;</span><br><span class="line">outimg[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">outimg[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("outimg[i][j] : %d\n", outimg[i][j]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 잡음 영상을 입력받은 count값만큼 더하여 평균을 낸 영상을 구하는 함수이다. 다음은 위의 함수를 사용하여 각각 잡음 5개, 20개, 50개를 더한 영상이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/noise5.png" style="width: 512px    ; height: 512px;"></div>5개를 더한 결과 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/noise20.png" style="width: 512px    ; height: 512px;"></div>20개를 더한 결과 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/noise50.png" style="width: 512px    ; height: 512px;"></div>50개를 더한 결과 영상<p>위의 영상들과 같이 잡음 영상을 많이 더할수록 잡음을 더 잘 제거하는 모습을 확인할 수 있다. 잡음 영상을 단순한 가산연산으로 처리하는 방식이 좋은 결과를 나타내는 경우가 많이 있는데 그것은 잡음이 원 영상과 상관관계가 없는 경우의 가산 잡음인 경우에 해당된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Add-Noise&quot;&gt;&lt;a href=&quot;#Add-Noise&quot; class=&quot;headerlink&quot; title=&quot;Add Noise&quot;&gt;&lt;/a&gt;Add Noise&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 콘트라스트 스트레칭(Contrast Streching)</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing8/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing8/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:22.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="콘트라스트-스트레칭"><a href="#콘트라스트-스트레칭" class="headerlink" title="콘트라스트 스트레칭"></a>콘트라스트 스트레칭</h2><p>콘트라스트 스트레칭은 히스토그램의 분포가 얼마나 넓게 퍼져 있는가에 따라 인간의 시각 체계가 선명하게 영상을 인식하는 과정에 대한 작업이다. 밝은 화소와 어두운 화소들의 분포가 고르게 퍼져 있어야 인간은 영상을 선명하게 인식하므로 영상의 화소 분포가 좀 더 넓은 영역에 걸쳐서 퍼지도록 스트레칭 시키는 작업이다. 히스토그램 평활화는 히스토그램의 전체적인 분포를 중심으로 동작하나 콘트라스트 스트레칭은 콘트라스트가 너무 높거나 낮은 영상에 대하여 콘트라스트를 넓게 펴주는 작업을 수행하는 히스토그램 평활화의 일종이라고 보면 된다.<br>콘트라스트 스트레칭을 수행하는 수식은 아래와 같이 정의한다.</p><div style="width: 512px; height: 80px;">    <img src="https://kyu9341.github.io/img/contrast.png" style="width: 512px    ; height: 80px;"></div><p>새로운 화소 값은 영상내의 히스토그램을 구한 결과 값에서 가장 큰 값과 가장 작은 값을 구한 후, 기존의 화소 값에서 가장 작은 값을 뺀 결과에 최댓값을 곱해서 구한다. 이 때 최댓값과 최솟값의 범위가 좁을수록 콘트라스트 스트레칭이 잘 일어난다. 콘트라스트 스트레칭은 일반 영상에 적용하는 경우, 즉 최솟값이 0이고 최댓값이 255인 경우 효과를 보기 어려운 기법이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/light.png" style="width: 512px    ; height: 512px;"></div><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lightcontrast.png" style="width: 512px    ; height: 512px;"></div>위의 영상은 밝은 레나 영상에 콘트라스트 스트레칭을 적용한 결과이다. 밝은 레나 영상의 최솟값은 115, 최댓값은 248이다. 최솟값이 큰 값을 가지고 있어 히스토그램이 밝은 영역으로 치우친 영상의 모양으로 콘트라스트 스트레칭 결과 영상이 보기에도 선명하고 좋은 결과를 보여주는 것을 알 수 있다.<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lightcontrasthisto.png" style="width: 512px    ; height: 512px;"></div><p>위의 히스토그램을 보면 알 수 있듯이 최솟값과 최댓값이 스트레칭되어 각각 0과 255를 가지도록 변화한 것을 볼 수 있다.</p><div style="width: 512px; height: 256px;">    <img src="https://kyu9341.github.io/img/cmancontrast.png" style="width: 512px    ; height: 256px;"></div><div style="width: 512px; height: 256px;">    <img src="https://kyu9341.github.io/img/jetcontrast.png" style="width: 512px    ; height: 256px;"></div>위의 영상들은 각각 카메라맨과 제트기 영상에 대하여 콘트라스트 스트레칭을 수행한 결과이다. 카메라맨 영상은 0부터 255까지의 값을 모두 가지고 있어 그 결과가 거의 변한 것이 없으나 제트기 영상은 15부터 231의 값을 가지므로 원 영상보다 선명한 결과를 보여준다. 콘트라스트 스트레칭은 영상이 가지는 그레이 레벨의 값이 0부터 255로 변화되며 영상이 가지는 그레이 레벨 값을 모두 펼쳐주는 역할을 한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contrastStreching</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> X_Size, <span class="keyword">int</span> Y_Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, histogram[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">255</span>, <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">uchar LUT[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">double</span> scaleFactor, tmp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">histogram[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Y_Size; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; X_Size; j++)</span><br><span class="line">&#123;</span><br><span class="line">histogram[img[i][j]]++; <span class="comment">// 영상의 히스토그램을 구함</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="comment">// 히스토그램의 최솟값을 구함</span></span><br><span class="line"><span class="keyword">if</span> (histogram[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">255</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 히스토그램의 최댓값을 구함</span></span><br><span class="line"><span class="keyword">if</span> (histogram[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Low Threshold is %d High Threshold is %d\n"</span>, <span class="built_in">min</span>, <span class="built_in">max</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>; i++)</span><br><span class="line">LUT[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">255</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">LUT[i] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">scaleFactor = <span class="number">255.0</span> / (<span class="keyword">double</span>)(<span class="built_in">max</span> - <span class="built_in">min</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="built_in">min</span>; i &lt; <span class="built_in">max</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = (i - <span class="built_in">min</span>) * scaleFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; <span class="number">255</span>) tmp = <span class="number">255</span>;</span><br><span class="line">LUT[i] = (uchar)tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Y_Size; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; X_Size; j++)</span><br><span class="line">outimg[i][j] = LUT[img[i][j]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 콘트라스트 스트레칭을 수행하는 함수이며 영상내의 히스토그램을 구해 최솟값과 최댓값을 각각 구해 위의 수식을 적용시키는 구조로 작성되었다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;콘트라스트-스트레칭&quot;&gt;&lt;a href=&quot;#콘트라스트-스트레칭&quot; class=&quot;headerlink&quot; title=&quot;콘트라스트 스트레칭&quot;&gt;&lt;/a&gt;콘트라스트 스트레칭&lt;/h2&gt;&lt;p&gt;콘트라스트 스트레칭은 히스토그램의 분포가 얼마나 넓게 퍼져 있는가에 
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 히스토그램</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing7/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing7/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:18.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="히스토그램"><a href="#히스토그램" class="headerlink" title="히스토그램"></a>히스토그램</h2><p>영상에서의 히스토그램은 그레이레벨 값 k개의 개수가 영상 전체 안에서 몇 개가 존재하는지를 알려주는 값이다. 즉, 그레이레벨 값 0부터 255까지가 영상 전체에서 몇 개씩 존재하는가를 알려주는 지표 값이다. 히스토그램은 영상의 그레이레벨의 프로파일(profile)을 보여주는 기능을 한다고 생각하면 된다. 그러나 영상의 크기가 다양하기 때문에 개수만으로 표현하는 경우 그 개수의 정확성에 문제가 발생할 수 있으므로 영상전체 화소수로 나누어 확률적인 표현으로 나타낸다. 즉, k번째 개수가 Nk개인 경우 Nk/(Row*Col)와 같이 전체 화소수로 나누어 k 의 그레이 레벨이 갖는 개수를 표현한 것을 히스토그램이라 한다.</p><div style="width: 600px; height: 1000px;">    <img src="https://kyu9341.github.io/img/his.png" style="width: 600px    ; height: 1000px;"></div><p>위의 이미지들은 각각 lena.512의 원본과 각각 gamma collection을 통해 gamma값을 3, 0.45로 지정하여 밝고 어둡게 만든 영상들의 히스토그램이다. 원본의 히스토그램을 보면 0부터 255까지의 값이 존재하나 0과 255의 근처에는 값이 거의 없는 것을 볼 수 있으며 전체적으로 고르게 히스토그램이 분포한 것을 확인할 수 있다. 반면, 밝은 영상에서는 밝은 값들이 많기 때문에 우측으로 치우친 것을 확인할 수 있고 어두운 영상에서는 밝은 값들이 적고 상대적으로 어두운 값들이 많기 때문에 주로 좌측으로 분포한 것을 확인할 수 있다.</p><div style="width: 600px; height: 1000px;">    <img src="https://kyu9341.github.io/img/his1.png" style="width: 600px    ; height: 1000px;"></div><p>위의 이미지들은 각각 카메라맨, 페퍼, 페이스 이미지들과 히스토그램이다. 각각의 이미지와 히스토그램을 보면 이미지의 값들에 따른 히스토그램이 나타나는 것을 알 수 있다. Camera Man의 경우에는 밝은 배경과 어두운 사람의 옷 때문에 밝은 부분의 값과 어두운 부분의 값이 각각 많이 분포해 독특하게 나타나는 것을 볼 수 있다. 이런 영상의 경우에는 전체적인 콘트라스트를 개선하는데 어려움이 존재한다. 다음으로 Pepper는 보는 것과 같이 고르게 분포되어 있는 것을 알 수 있고 Face는 전체적으로 밝은 영상이므로 밝은 부분에 몰려있는 것을 확인 할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;히스토그램&quot;&gt;&lt;a href=&quot;#히스토그램&quot; class=&quot;headerlink&quot; title=&quot;히스토그램&quot;&gt;&lt;/a&gt;히스토그램&lt;/h2&gt;&lt;p&gt;영상에서의 히스토그램은 그레이레벨 값 k개의 개수가 영상 전체 안에서 몇 개가 존재하는지를 알려주는 값이
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - Bit Plane</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/29/ImageProcessing4/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/29/ImageProcessing4/</id>
    <published>2019-11-29T02:01:22.000Z</published>
    <updated>2019-12-27T06:41:05.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bit-Plane"><a href="#Bit-Plane" class="headerlink" title="Bit Plane"></a>Bit Plane</h2><p>표준 디지털 영상은 8bits로 구성되어 0부터 255까지의 값을 가지고 있는 구조이다. 256레벨의 그레이 스케일 값이라고 표현하기도 하는데 이진영상을 위에서 구성한 것과 같이 각 bit위치에서의 영상을 독립된 영상으로 표현하는 방법을 알아본다. 영상은 8개의 bit plane으로 구성되어 있으며 최상위 비트가 1인 경우 128보다 큰 값을 가지게 되고 바로 하위 비트가 1인 경우는 64보다 큰 값을 갖는 구조를 가지고 있다. 각 위치에서의 비트가 1인 경우 영상 값이 존재하는 표시인 255로 표시하여 화면에 보여주고 0인 경우 0으로 표현하여 이진 영상으로 각 bit plane을 표현한다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitSlicing</span><span class="params">(uchar** img, uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> <span class="built_in">position</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 해당 position 값에 맞는 mask값을 통해 이미지를 구함</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">uchar mask = <span class="number">0x01</span>;</span><br><span class="line">mask &lt;&lt;= <span class="built_in">position</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Row;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; img[i][j]) == <span class="built_in">pow</span>(<span class="number">2</span>, <span class="built_in">position</span>)) <span class="comment">//pow(2, position) = mask</span></span><br><span class="line">&#123;</span><br><span class="line">Result[i][j] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 position값에 따라 해당하는 bit palne의 이미지를 생성하는 코드이다.</p><div style="width: 700px; height: 800px;">    <img src="https://kyu9341.github.io/img/lenabitplane.png" style="width: 700px    ; height: 800px;"></div><p>위의 이미지는 Bit Plane 8장에 대한 영상결과를 보여준다. 각각의 비트가 1인 경우 255로 표현하여 이진화된 영상을 보여준다.</p><h2 id="ImageCombine"><a href="#ImageCombine" class="headerlink" title="ImageCombine"></a>ImageCombine</h2><p>이진화된 비트 영상은 비트의 정보만으로 영상이 얼마나 많은 정보를 가지고 있는지를 알 수 있다. 이러한 비트 정보를 몇 개를 모아야 사람이 보기에 지장이 없는지 확인해보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageCombine</span><span class="params">(uchar** img, uchar** tmpimg, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">int</span> direction)</span> <span class="comment">// 7부터 position까지의 비트이미지를 합성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">uchar mask = <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">1</span>) <span class="comment">// 7부터 position까지 합성</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">7</span>; k &gt; <span class="number">7</span> - <span class="built_in">position</span>; k--) <span class="comment">// 7부터 입력받은 장수까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line">mask &lt;&lt;= k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) <span class="comment">// BitSlicing</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; img[i][j]) == mask) <span class="comment">//pow(2, position) = mask</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outimg[i][j] += tmpimg[i][j] &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line">mask = <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br><span class="line">average(outimg, Row, Col);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 비트슬라이싱된 이미지에 해당 mask를 and연산 하는 이유</span></span><br><span class="line"><span class="comment"> 해당 비트값만 255로 변환하고 나머지는 0으로 변환했기 때문에</span></span><br><span class="line"><span class="comment"> 즉 255 : 0b1111111 &amp; 0b1000000 =&gt; 0b1000000</span></span><br><span class="line"><span class="comment">    &amp; 0b0100000 =&gt; 0b0100000</span></span><br><span class="line"><span class="comment">와 같이 변환 후 모두 더해줘야 정상적인 값이 나옴.</span></span><br><span class="line"><span class="comment">\*/</span></span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">2</span>) <span class="comment">// 1부터 position까지 합성</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="built_in">position</span>; k++) <span class="comment">// 1부터 입력받은 장수까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line">mask &lt;&lt;= k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) <span class="comment">// BitSlicing</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; img[i][j]) == mask) <span class="comment">//pow(2, position) = mask</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) <span class="comment">// BitMasking, MaskAdd</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outimg[i][j] += tmpimg[i][j] &amp; mask; <span class="comment">// 비트슬라이싱된 tmpimg를 해당 비트의 마스크 값으로 마스킹 후 누적</span></span><br><span class="line">&#125;</span><br><span class="line">mask = <span class="number">0x01</span>; <span class="comment">// 초기화</span></span><br><span class="line">&#125;</span><br><span class="line">average(outimg, Row, Col);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 입력 받은 direction과 position값에 따라 상위 비트 혹은 하위 비트부터 원하는 장수를 더한 이미지를 생성해주는 함수이다. 일일이 각 비트의 이미지를 생성해 더하지 않도록 하기 위해 위와 같이 mask를 쉬프트 연산을 통해 변경하며 각각의 bit에 해당하는 이미지를 누적시켰다. 아래는 위의 함수를 통해 생성한 이미지를 출력한 결과이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lena876.png" style="width: 512px    ; height: 512px;"></div>8, 7, 6bit 합성 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lena8765.png" style="width: 512px    ; height: 512px;"></div>8, 7, 6, 5bit 합성 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lena12345.png" style="width: 512px    ; height: 512px;"></div>1, 2, 3, 4, 5bit 합성 영상<p>상위 비트부터 많은 비트를 합성할수록 원 영상과 비슷한 결과를 보여주는 것을 알 수 있다. 또한 하위 비트부터 더하면 높은 값을 가지는 bit가 빠져있으므로 전체적으로 어두운 영상을 보여주게 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bit-Plane&quot;&gt;&lt;a href=&quot;#Bit-Plane&quot; class=&quot;headerlink&quot; title=&quot;Bit Plane&quot;&gt;&lt;/a&gt;Bit Plane&lt;/h2&gt;&lt;p&gt;표준 디지털 영상은 8bits로 구성되어 0부터 255까지의 값을 가지고 있
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>ICT멘토링 딥러닝 교육 2일차</title>
    <link href="https://kyu9341.github.io/MachineLearning/2019/11/24/marchinelearning4/"/>
    <id>https://kyu9341.github.io/MachineLearning/2019/11/24/marchinelearning4/</id>
    <published>2019-11-24T01:01:25.000Z</published>
    <updated>2020-01-03T01:36:05.794Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 둘째 날 배운 내용을 리뷰해보겠다. 둘째 날에는 이미지 분류 이론, Azure Cloud GPU활용, Cifar10 이미지 분류에 대해서 배웠다.</p><h3 id="Convolutional-Neural-Network-CNN"><a href="#Convolutional-Neural-Network-CNN" class="headerlink" title="Convolutional Neural Network(CNN)"></a>Convolutional Neural Network(CNN)</h3><p>딥러닝이나 머신러닝 관련 자료들을 보면 자주 등장하던 CNN이다. 주로 이미지를 학습시킨다고 하면 제일 먼저 떠오르는 단어이다.</p><p>CNN(합성곱 신경망)은 필터링 기법을 인공신경망에 적용함으로써 이미지를 더욱 효과적으로 처리하기 위해 고안되었다. 이미지를 Dense(fully connected) Layer로 처리하려 한다면 feature가 너무 많아져 불필요한 weight가 많아지고 효율이 떨어지게 된다. 또한 Dense Layer는 1차원 데이터만 input으로 받을 수 있기 때문에 3차원 데이터를 평탄화하여 입력해야 한다. 여기서 3차원 데이터의 공간적 정보가 소실되는 문제가 발생한다. 반면 Convolutional Layer에서는 형상을 유지한다. 입/출력 모두 3차원 데이터로 처리하기 때문에 공간적 정보를 유지할 수 있다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/cnn.png" style="width: 100%    ; height: 400px;"></div><h4 id="Convolutional-Layer"><a href="#Convolutional-Layer" class="headerlink" title="Convolutional Layer"></a>Convolutional Layer</h4><p>Convolution은 합성곱이라는 뜻이다. 최근에 영상처리 수업을 들으며 등장했던 단어이기 때문에 이해가 잘 되었다. 특정한 크기의 필터를 사용하여 이미지의 각 픽셀을 지나가며 필터의 위치에 해당하는 픽셀과 모두 곱한 후 그 곱한 값을 모두 더하여 현재 중앙 픽셀 값에 넣어주는 것이다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/convolution.png" style="width: 100%    ; height: 400px;"></div>위의 그림처럼 이미지에서 합성곱이란 필터를 이동시켜가며 이미지와 곱한 결과를 모두 더하는 것인데, 이러한 필터를 어떤 값을 넣어 사용하느냐에 따라 이미지의 색상, 밝기, 엣지 추출등 여러가지 기능을 수행할 수 있다. 또한 필터는 주로 커널이라고 부르기도 한다.<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p>1만큼 패딩했다고 한다면, 입력 데이터 사방 1픽셀을 특정 값으로 채워 늘리는 것을 말한다. 주로 출력 크기를 조정할 목적으로 사용되는데 이를테면 (5, 5)데이터에 (3, 3)필터를 적용하면 출력이 (3, 3)이 된다. 이처럼 합성곱 연산을 거칠 때 마다 크기가 작아지게 되는데 출력 크기가 너무 줄어드는 것을 막기 위해 패딩을 사용한다. 패딩을 사용하면 그만큼 입력 데이터를 그게 만들어 출력 데이터를 입력 데이터와 동일한 형상으로 조정할 수 있으므로 입력 데이터의 공간적 크기를 고정한 채로 다음 계층에 전달할 수 있다.</p><h4 id="Pooling-layer"><a href="#Pooling-layer" class="headerlink" title="Pooling layer"></a>Pooling layer</h4><p>풀링은 가로/세로 방향의 공간을 줄이는 연산이다. 풀링의 종류로는 Max Pooling과 Average Pooling이 있는데 이미지 인식 분야에서는 주로 Max Pooling을 사용한다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/pooling.png" style="width: 100%    ; height: 400px;"></div><ul><li><p>Average pooling : 지정된 구역의 평균값을 가져와 대체함</p></li><li><p>Max pooling layer: 지정된 구역의 가장 큰 값을 가져와 대체함(사소한 정보 차이는 무시)</p><p>    이미지가 가지는 큰 특징을 유지하며 사이즈를 줄임 (특징 일반화 가능)</p><p>    예를 들어 강아지의 종이 다른 경우에도 큰 특징만 가지고 커버가능</p><p>    데이터가 지역적으로 학습되지 않도록 함</p></li></ul><h2 id="실습1"><a href="#실습1" class="headerlink" title="실습1"></a>실습1</h2><p>첫번째는 간단하게 이미지만 불러와서 확인하는 과정이다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN"><a href="#2019-11-24-딥-러닝-과정-CNN" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="준비-실습-Image-살펴보기"><a href="#준비-실습-Image-살펴보기" class="headerlink" title="준비 실습. Image 살펴보기"></a>준비 실습. Image 살펴보기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. package 가져오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 가져오기</span></span><br><span class="line"></span><br><span class="line">image_gray = Image.open(<span class="string">'01image.png'</span>)</span><br><span class="line">image_color = Image.open(<span class="string">'02image.png'</span>)</span><br><span class="line">image_jet = Image.open(<span class="string">'jet.png'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(image_gray.size)</span><br><span class="line">print(image_gray)</span><br><span class="line"><span class="comment"># print(image_jet)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(image_color.size) <span class="comment"># size만 뽑으면 가로 세로만 나옴</span></span><br><span class="line">print(image_gray.size)</span><br><span class="line"><span class="comment"># print(image_jet.size)</span></span><br></pre></td></tr></table></figure><pre><code>(28, 28)&lt;PIL.PngImagePlugin.PngImageFile image mode=L size=28x28 at 0x1405C55AE08&gt;(32, 32)(28, 28)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 이미지 array로 변환하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image_array = np.array(image_gray)</span><br><span class="line">image_array_color = np.array(image_color)</span><br><span class="line"><span class="comment"># image_array_jet = np.array(image_jet)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(image_array.shape) <span class="comment"># 학습 시킬때 항상 numpy data로 변환하며 shape를 확인해야함</span></span><br><span class="line">print(image_array_color.shape) <span class="comment"># numpy array로 변환하여 출력하면 (32, 32, 3)처럼 뎁스도 출력 가능</span></span><br><span class="line"><span class="comment"># 3차원 데이터여야만 CNN에 넣어서 학습이 가능 따라서 gray scale은 reshape해줘야함</span></span><br><span class="line"><span class="comment"># print(image_array_jet.shape)</span></span><br><span class="line">reshpaed_1d = image_array.reshape(<span class="number">28</span>*<span class="number">28</span>) <span class="comment"># gray image -&gt;reshape</span></span><br><span class="line">reshaped_3d = image_array.reshape(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>) <span class="comment"># gray image -&gt; 3d로 변경하여 cnn이 가능하도록 함</span></span><br><span class="line"></span><br><span class="line">print(reshpaed_1d.shape)</span><br><span class="line">print(reshaped_3d.shape)</span><br></pre></td></tr></table></figure><pre><code>(28, 28)(32, 32, 3)(784,)(28, 28, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 이미지 살펴보기</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(image_array)</span></span><br><span class="line">print(image_array_color)</span><br><span class="line"><span class="comment"># print(image_array_jet)</span></span><br><span class="line"><span class="comment"># print(reshaped_3d)</span></span><br></pre></td></tr></table></figure><pre><code>[[[125 125 116]  [110 101  91]  [102  90  83]  ...  [202 207 214]  [200 205 212]  [202 208 214]]  ...  [143 117  82]  [143 116  84]  [144 116  86]]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 이미지 시각화</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.imshow(image_array, cmap=plt.cm.gray) <span class="comment"># gray scale를 정상적으로 띄우려면 color map 을 지정해야함</span></span><br><span class="line">plt.imshow(image_array_color)</span><br><span class="line"><span class="comment"># plt.imshow(image_array_jet)</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x1405c59de48&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_6_1.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습2"><a href="#실습2" class="headerlink" title="실습2"></a>실습2</h2><p>두번째 실습은 CNN모델을 적용하기 전에 MLT만 사용하여 이미지를 학습시켜보았다. MLT는 1차원 데이터만 input으로 받을 수 있기 때문에 gray scale의 2차원 데이터는 1차원으로 reshape을 해주어야 학습이 가능하다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-1"><a href="#2019-11-24-딥-러닝-과정-CNN-1" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="첫번째-실습-Keras-모델-생성-학습-MNIST-MLP"><a href="#첫번째-실습-Keras-모델-생성-학습-MNIST-MLP" class="headerlink" title="첫번째 실습. Keras 모델 생성/학습 - MNIST : MLP"></a>첫번째 실습. Keras 모델 생성/학습 - MNIST : MLP</h3><p><a href="https://keras.io/ko/datasets/#mnist" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist  <span class="comment"># 많이 쓰이는 데이터 케라스에서 제공</span></span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(60000, 28, 28)(60000,)(10000, 28, 28)(10000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap=plt.cm.gray)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x12a2b101c48&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X_train.shape) <span class="comment"># 28*28 이미지 (2차원) 6만개 -&gt; 1차원 6만개</span></span><br></pre></td></tr></table></figure><pre><code>(60000, 28, 28)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. 이미지 데이터 전처리 : 2차원-&gt;1차원 🌟🌟🌟</span></span><br><span class="line"></span><br><span class="line">X_train = X_train.reshape((<span class="number">60000</span>, <span class="number">28</span> * <span class="number">28</span>)) <span class="comment"># -&gt; 1차원 6만개로 변환</span></span><br><span class="line">X_test = X_test.reshape((<span class="number">10000</span>, <span class="number">28</span> * <span class="number">28</span>))</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line"></span><br><span class="line">print(X_train)</span><br></pre></td></tr></table></figure><pre><code>(60000, 784)(10000, 784)[[0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] ... [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. 이미지 데이터 전처리 : Normalzation</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">print(X_train[<span class="number">9</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label 전처리 (one-hot encoding)</span></span><br><span class="line">print(y_train[:<span class="number">10</span>]) <span class="comment"># 앞에서 10개, label : 숫자가 어떤 숫자인지</span></span><br></pre></td></tr></table></figure><pre><code>[5 0 4 1 9 2 1 3 1 4]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label 전처리 (one-hot encoding)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[[0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4-1 Validation 셋 나누기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                    test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                    random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line"></span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 784)(48000, 10)(12000, 784)(12000, 10)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : MLP</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">512</span>, input_dim=<span class="number">784</span>, activation=<span class="string">'relu'</span>)) <span class="comment"># 다음 노드의 수 : 512(inputdata가 784이므로 적당히 크게)</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)) <span class="comment"># 출력 층 10개중 어떤건지 알기 위해 10으로 지정</span></span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_6&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_9 (Dense)              (None, 512)               401920    _________________________________________________________________dense_10 (Dense)             (None, 10)                5130      =================================================================Total params: 407,050Trainable params: 407,050Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size=<span class="number">128</span></span><br><span class="line">epochs=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">         epochs=epochs,</span><br><span class="line">         batch_size=batch_size,</span><br><span class="line">         validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">         verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 48000 samples, validate on 12000 samplesEpoch 1/1048000/48000 [==============================] - 2s 37us/step - loss: 1.2137 - accuracy: 0.7386 - val_loss: 0.6995 - val_accuracy: 0.8526Epoch 2/1048000/48000 [==============================] - 2s 34us/step - loss: 0.5725 - accuracy: 0.8683 - val_loss: 0.4960 - val_accuracy: 0.8789Epoch 3/1048000/48000 [==============================] - 2s 42us/step - loss: 0.4501 - accuracy: 0.8855 - val_loss: 0.4243 - val_accuracy: 0.8904Epoch 4/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3967 - accuracy: 0.8948 - val_loss: 0.3847 - val_accuracy: 0.8984Epoch 5/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3648 - accuracy: 0.9019 - val_loss: 0.3599 - val_accuracy: 0.9035Epoch 6/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3425 - accuracy: 0.9064 - val_loss: 0.3419 - val_accuracy: 0.9077Epoch 7/1048000/48000 [==============================] - 2s 38us/step - loss: 0.3257 - accuracy: 0.9103 - val_loss: 0.3276 - val_accuracy: 0.9109Epoch 8/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3121 - accuracy: 0.9145 - val_loss: 0.3155 - val_accuracy: 0.9133Epoch 9/1048000/48000 [==============================] - 2s 41us/step - loss: 0.3006 - accuracy: 0.9174 - val_loss: 0.3064 - val_accuracy: 0.9160Epoch 10/1048000/48000 [==============================] - 2s 40us/step - loss: 0.2906 - accuracy: 0.9201 - val_loss: 0.2977 - val_accuracy: 0.9183</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br><span class="line"></span><br><span class="line">print(test_loss, test_acc)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 0s 25us/step0.2771936253398657 0.9223999977111816</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap = <span class="string">'Greys'</span>, interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_14_0.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_14_1.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_14_2.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.plot(history.history['val_accuracy'])</span></span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_15_0.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습3"><a href="#실습3" class="headerlink" title="실습3"></a>실습3</h2><p>이번에는 실제로 CNN을 사용하여 딥러닝을 수행했다. MLT를 수행하기 이전에 Convolution Layer 및 Pooling Layer를 거쳐 학습이 진행된다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-2"><a href="#2019-11-24-딥-러닝-과정-CNN-2" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="두번째-실습-Keras-모델-생성-학습-MNIST-CNN"><a href="#두번째-실습-Keras-모델-생성-학습-MNIST-CNN" class="headerlink" title="두번째 실습. Keras 모델 생성/학습 - MNIST : CNN"></a>두번째 실습. Keras 모델 생성/학습 - MNIST : CNN</h3><p><a href="https://keras.io/ko/datasets/#mnist" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                 random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28)(48000,)(10000, 28, 28)(10000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap=plt.cm.gray)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x240c6b78c48&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1a.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. 이미지 데이터 전처리 : 2차원-&gt;3차원 🌟🌟🌟</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w=h=28            </span></span><br><span class="line"><span class="comment"># X_train = X_train.reshape(X_train.shape[0], w, h, 1)</span></span><br><span class="line"><span class="comment"># 위의 두줄로 대체 가능 위의 방식이 재사용에 용이</span></span><br><span class="line"></span><br><span class="line">X_train = X_train.reshape(<span class="number">48000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">X_val = X_val.reshape(<span class="number">12000</span>, <span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br><span class="line">X_test = X_test.reshape((<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line"></span><br><span class="line">print(X_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28, 1)(12000, 28, 28, 1)(10000, 28, 28, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. 이미지 데이터 전처리 : Normalzation</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_val = X_val / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label 전처리 (one-hot encoding)</span></span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>]) <span class="comment"># 앞에서 10개, label : 숫자가 어떤 숫자인지</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_val = to_categorical(y_val)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[9 9 9 5 3 2 0 4 2 7][[0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : CNN 🌟🌟🌟</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Conv2D, MaxPooling2D, Flatten</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(filters=<span class="number">32</span>,</span><br><span class="line">                kernel_size=(<span class="number">3</span>,<span class="number">3</span>),</span><br><span class="line">                padding=<span class="string">'same'</span>,</span><br><span class="line">                activation=<span class="string">'relu'</span>,</span><br><span class="line">                input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_10&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_9 (Conv2D)            (None, 28, 28, 32)        320       _________________________________________________________________max_pooling2d_7 (MaxPooling2 (None, 14, 14, 32)        0         _________________________________________________________________flatten_6 (Flatten)          (None, 6272)              0         _________________________________________________________________dense_9 (Dense)              (None, 128)               802944    _________________________________________________________________dense_10 (Dense)             (None, 10)                1290      =================================================================Total params: 804,554Trainable params: 804,554Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size=<span class="number">128</span></span><br><span class="line">epochs=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">         epochs=epochs,</span><br><span class="line">         batch_size=batch_size,</span><br><span class="line">         validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">         verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>W1124 16:01:22.815376 23724 deprecation_wrapper.py:119] From c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\keras\backend\tensorflow_backend.py:422: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.Train on 48000 samples, validate on 12000 samplesEpoch 1/1048000/48000 [==============================] - 10s 203us/step - loss: 1.1062 - accuracy: 0.7491 - val_loss: 0.4400 - val_accuracy: 0.8799Epoch 2/1048000/48000 [==============================] - 10s 207us/step - loss: 0.3706 - accuracy: 0.8950 - val_loss: 0.3396 - val_accuracy: 0.9028Epoch 3/1048000/48000 [==============================] - 12s 242us/step - loss: 0.3099 - accuracy: 0.9095 - val_loss: 0.3000 - val_accuracy: 0.9153Epoch 4/1048000/48000 [==============================] - 12s 245us/step - loss: 0.2787 - accuracy: 0.9186 - val_loss: 0.2750 - val_accuracy: 0.9217Epoch 5/1048000/48000 [==============================] - 12s 244us/step - loss: 0.2548 - accuracy: 0.9252 - val_loss: 0.2543 - val_accuracy: 0.9284Epoch 6/1048000/48000 [==============================] - 12s 252us/step - loss: 0.2348 - accuracy: 0.9316 - val_loss: 0.2379 - val_accuracy: 0.9331Epoch 7/1048000/48000 [==============================] - 12s 251us/step - loss: 0.2173 - accuracy: 0.9372 - val_loss: 0.2233 - val_accuracy: 0.9353Epoch 8/1048000/48000 [==============================] - 13s 269us/step - loss: 0.2025 - accuracy: 0.9405 - val_loss: 0.2106 - val_accuracy: 0.9405Epoch 9/1048000/48000 [==============================] - 13s 265us/step - loss: 0.1898 - accuracy: 0.9446 - val_loss: 0.1987 - val_accuracy: 0.9421Epoch 10/1048000/48000 [==============================] - 12s 251us/step - loss: 0.1782 - accuracy: 0.9475 - val_loss: 0.1957 - val_accuracy: 0.9433</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 1s 83us/step</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap = <span class="string">'Greys'</span>, interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_0a.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_1a.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_2a.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_0a.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_1a.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습4"><a href="#실습4" class="headerlink" title="실습4"></a>실습4</h2><p>위에서 학습한 방식을 그대로 사용하여 Fashion MNIST 데이터에 적용하여 딥러닝을 수행해보았다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-3"><a href="#2019-11-24-딥-러닝-과정-CNN-3" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="세번째-실습-Keras-모델-생성-학습-Fashion-MNIST-CNN"><a href="#세번째-실습-Keras-모델-생성-학습-Fashion-MNIST-CNN" class="headerlink" title="세번째 실습. Keras 모델 생성/학습 - Fashion MNIST : CNN"></a>세번째 실습. Keras 모델 생성/학습 - Fashion MNIST : CNN</h3><p><a href="https://keras.io/ko/datasets/#-mnist" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> fashion_mnist</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = fashion_mnist.load_data()</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                 random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28)(48000,)(12000, 28, 28)(12000,)(10000, 28, 28)(10000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap = plt.cm.gray)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x2ab820aac08&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1b.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. 이미지 데이터 전처리 : 2차원-&gt;3차원 🌟🌟🌟</span></span><br><span class="line">X_train = X_train.reshape(<span class="number">48000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">X_val = X_val.reshape(<span class="number">12000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">X_test = X_test.reshape(<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(X_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28, 1)(12000, 28, 28, 1)(10000, 28, 28, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. 이미지 데이터 전처리 : Normalzation</span></span><br><span class="line"></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_val = X_val / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label categorical (one-hot encoding)</span></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_val = to_categorical(y_val)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[3 1 2 6 7 3 5 1 1 5][[0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 1. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : CNN</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Conv2D, MaxPool2D, Flatten, Dropout</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(filters=<span class="number">32</span>,  <span class="comment"># 필터의 개수</span></span><br><span class="line">                kernel_size=(<span class="number">3</span>,<span class="number">3</span>),  <span class="comment"># 필터 사이즈</span></span><br><span class="line">                padding=<span class="string">'same'</span>,  <span class="comment"># padding</span></span><br><span class="line">                activation=<span class="string">'relu'</span>,  <span class="comment"># activation 함수 설정</span></span><br><span class="line">                input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))) <span class="comment"># (input_dim)</span></span><br><span class="line"></span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>))) <span class="comment"># 보통 (2,2)를 넣음</span></span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.3</span>))<span class="comment"># Dropout 설정</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)) <span class="comment"># 다중 분류 문제이기 때문에 softmax</span></span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_5&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_5 (Conv2D)            (None, 28, 28, 32)        320       _________________________________________________________________max_pooling2d_5 (MaxPooling2 (None, 14, 14, 32)        0         _________________________________________________________________flatten_5 (Flatten)          (None, 6272)              0         _________________________________________________________________dense_5 (Dense)              (None, 128)               802944    _________________________________________________________________dropout_2 (Dropout)          (None, 128)               0         _________________________________________________________________dense_6 (Dense)              (None, 10)                1290      =================================================================Total params: 804,554Trainable params: 804,554Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">             optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">                    epochs=epochs,</span><br><span class="line">                    batch_size=batch_size,</span><br><span class="line">                    validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">                    verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 48000 samples, validate on 12000 samplesEpoch 1/1048000/48000 [==============================] - 25s 511us/step - loss: 0.5189 - accuracy: 0.8164 - val_loss: 0.3606 - val_accuracy: 0.8741Epoch 2/1048000/48000 [==============================] - 23s 488us/step - loss: 0.3464 - accuracy: 0.8777 - val_loss: 0.3015 - val_accuracy: 0.8932Epoch 3/1048000/48000 [==============================] - 23s 487us/step - loss: 0.2950 - accuracy: 0.8942 - val_loss: 0.2767 - val_accuracy: 0.9023Epoch 4/1048000/48000 [==============================] - 23s 484us/step - loss: 0.2648 - accuracy: 0.9041 - val_loss: 0.2626 - val_accuracy: 0.9061Epoch 5/1048000/48000 [==============================] - 23s 480us/step - loss: 0.2444 - accuracy: 0.9106 - val_loss: 0.2510 - val_accuracy: 0.9106Epoch 6/1048000/48000 [==============================] - 23s 479us/step - loss: 0.2241 - accuracy: 0.9170 - val_loss: 0.2577 - val_accuracy: 0.9068Epoch 7/1048000/48000 [==============================] - 24s 503us/step - loss: 0.2093 - accuracy: 0.9236 - val_loss: 0.2417 - val_accuracy: 0.9126Epoch 8/1048000/48000 [==============================] - 24s 509us/step - loss: 0.1926 - accuracy: 0.9288 - val_loss: 0.2380 - val_accuracy: 0.9153Epoch 9/1048000/48000 [==============================] - 24s 504us/step - loss: 0.1821 - accuracy: 0.9325 - val_loss: 0.2352 - val_accuracy: 0.9190Epoch 10/1048000/48000 [==============================] - 24s 506us/step - loss: 0.1699 - accuracy: 0.9368 - val_loss: 0.2329 - val_accuracy: 0.9191</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 2s 206us/step</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap = <span class="string">'Greys'</span>, interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_0b.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_1b.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_2b.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_0b.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_1b.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습5"><a href="#실습5" class="headerlink" title="실습5"></a>실습5</h2><p>마지막으로 cifar10 데이터셋에 대한 이미지 분류(Image Classification)를 수행하는 Convolutional Neural Networks(CNNs)을 만드는 예제를 수행하였다..</p><p>CIFAR-10은 이미지 인식 분야에서 널리 쓰이는 벤치마크 데이터셋 중 하나이다. CIFAR-10 데이터셋은 아래와 같이 총 10개의 레이블로 이루어져 있다.</p><p>airplane, automobile, bird, cat, deer, dog, frog, horse, ship, and truck.</p><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/cifar.png" style="width: 50%    ; height: 300px;"></div><p>각각의 레이블마다 32×32 크기 이미지인 50,000개의 training 데이터셋, 10,000개의 test 데이터셋이 존재하고, 결과적으로 총 60,000개의 32×32 크기의 이미지로 데이터셋이 구성되어 있다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-4"><a href="#2019-11-24-딥-러닝-과정-CNN-4" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="네번째-실습-Keras-모델-생성-학습-cifar10-CNN"><a href="#네번째-실습-Keras-모델-생성-학습-cifar10-CNN" class="headerlink" title="네번째 실습. Keras 모델 생성/학습 - cifar10 : CNN"></a>네번째 실습. Keras 모델 생성/학습 - cifar10 : CNN</h3><p><a href="https://keras.io/ko/datasets/#-cifar10" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> cifar10</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = cifar10.load_data()</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                 random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(40000, 32, 32, 3)(40000, 1)(10000, 32, 32, 3)(10000, 1)(10000, 32, 32, 3)(10000, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x2a31e4ed948&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1c.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 이미지 데이터 전처리</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_val = X_val / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label categorical (one-hot encoding)</span></span><br><span class="line"><span class="comment"># print(y_train[:10])</span></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_val = to_categorical(y_val)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[[0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : CNN</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dropout, Dense, Conv2D, MaxPooling2D, Flatten</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(filters=<span class="number">32</span>,</span><br><span class="line">                kernel_size=(<span class="number">3</span>,<span class="number">3</span>),</span><br><span class="line">                padding=<span class="string">'same'</span>,</span><br><span class="line">                activation=<span class="string">'relu'</span>,</span><br><span class="line">                input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.3</span>))</span><br><span class="line">model.add(Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_7&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_10 (Conv2D)           (None, 32, 32, 32)        896       _________________________________________________________________conv2d_11 (Conv2D)           (None, 32, 32, 64)        18496     _________________________________________________________________max_pooling2d_7 (MaxPooling2 (None, 16, 16, 64)        0         _________________________________________________________________flatten_7 (Flatten)          (None, 16384)             0         _________________________________________________________________dense_16 (Dense)             (None, 128)               2097280   _________________________________________________________________dropout_11 (Dropout)         (None, 128)               0         _________________________________________________________________dense_17 (Dense)             (None, 64)                8256      _________________________________________________________________dropout_12 (Dropout)         (None, 64)                0         _________________________________________________________________dense_18 (Dense)             (None, 10)                650       =================================================================Total params: 2,125,578Trainable params: 2,125,578Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">             optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">                    epochs=epochs,</span><br><span class="line">                    batch_size=batch_size,</span><br><span class="line">                    validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">                    verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 40000 samples, validate on 10000 samplesEpoch 1/1040000/40000 [==============================] - 67s 2ms/step - loss: 1.7432 - accuracy: 0.3568 - val_loss: 1.3433 - val_accuracy: 0.5201Epoch 2/1040000/40000 [==============================] - 72s 2ms/step - loss: 1.3271 - accuracy: 0.5257 - val_loss: 1.1500 - val_accuracy: 0.5906Epoch 3/1040000/40000 [==============================] - 77s 2ms/step - loss: 1.1586 - accuracy: 0.5886 - val_loss: 1.0559 - val_accuracy: 0.6271Epoch 4/1040000/40000 [==============================] - 79s 2ms/step - loss: 1.0281 - accuracy: 0.6375 - val_loss: 0.9819 - val_accuracy: 0.6544Epoch 5/1040000/40000 [==============================] - 77s 2ms/step - loss: 0.9405 - accuracy: 0.6692 - val_loss: 0.9503 - val_accuracy: 0.6616Epoch 6/1040000/40000 [==============================] - 74s 2ms/step - loss: 0.8635 - accuracy: 0.6951 - val_loss: 0.9583 - val_accuracy: 0.6658Epoch 7/1040000/40000 [==============================] - 80s 2ms/step - loss: 0.7953 - accuracy: 0.7214 - val_loss: 0.9359 - val_accuracy: 0.6790Epoch 8/1040000/40000 [==============================] - 74s 2ms/step - loss: 0.7194 - accuracy: 0.7470 - val_loss: 0.9354 - val_accuracy: 0.6783Epoch 9/1040000/40000 [==============================] - 79s 2ms/step - loss: 0.6575 - accuracy: 0.7661 - val_loss: 0.9470 - val_accuracy: 0.6804Epoch 10/1040000/40000 [==============================] - 76s 2ms/step - loss: 0.6005 - accuracy: 0.7867 - val_loss: 1.0215 - val_accuracy: 0.6707</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 5s 517us/step</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index], interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_10_0c.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_10_1c.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_10_2c.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_0c.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_1c.png" style="width: 50%    ; height: 300px;"></div><blockquote><p>참조<br><a href="https://umbum.tistory.com/223" target="_blank" rel="external nofollow noopener noreferrer">https://umbum.tistory.com/223</a><br><a href="https://untitledtblog.tistory.com/150" target="_blank" rel="external nofollow noopener noreferrer">https://untitledtblog.tistory.com/150</a><br><a href="https://adeshpande3.github.io/A-Beginner%27s-Guide-To-Understanding-Convolutional-Neural-Networks/" target="_blank" rel="external nofollow noopener noreferrer">https://adeshpande3.github.io/A-Beginner%27s-Guide-To-Understanding-Convolutional-Neural-Networks/</a><br><a href="http://solarisailab.com/archives/1700" target="_blank" rel="external nofollow noopener noreferrer">http://solarisailab.com/archives/1700</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 둘째 날 배운 내용을 리뷰해보겠다. 둘째 날에는 이미지 분류 이론, Azure Cloud GPU활용, Cifar10 이미지 분류에 대해서 배웠다.&lt;/p&gt;
&lt;h3 id=&quot;Convolutional-Neural-Network-CNN&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://kyu9341.github.io/categories/MachineLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>ICT멘토링 딥러닝 교육 1일차</title>
    <link href="https://kyu9341.github.io/MachineLearning/2019/11/23/marchinelearning3/"/>
    <id>https://kyu9341.github.io/MachineLearning/2019/11/23/marchinelearning3/</id>
    <published>2019-11-23T00:54:56.000Z</published>
    <updated>2020-01-03T01:36:21.646Z</updated>
    
    <content type="html"><![CDATA[<p>저번주에 한이음에서 주최한 머신러닝 ICT멘토링 AI머신러닝(기초) 교육에 이어 이번에는 AI딥러닝 교육에 참가하게 되었다. 이번주도 토일 10:00 ~ 18:00까지 진행되는데 첫째 날은 딥러닝 이론, 케라스, Azure Cloud 설정, MLP 설정에 대해 배웠다.</p><h3 id="딥러닝이란"><a href="#딥러닝이란" class="headerlink" title="딥러닝이란?"></a>딥러닝이란?</h3><p>Deep Learning = Deep Neural Network = Artificial Neural Network(ANN) 인공 신경망<br>= Multi Layer Perceptron</p><p>인공신경망을 사용하는 머신러닝 모델링 방법 중 하나(Neural Network)이며 다층 인공신경망 구조를 사용하여 빅 데이터 학습한다.</p><h4 id="perceptron"><a href="#perceptron" class="headerlink" title="perceptron"></a>perceptron</h4><p>인공 신경망의 한 종류.</p><p><strong>단층 퍼셉트론</strong> 은 다수의 신호(Input)을 받아서 하나의 신호(Output)를 출력한다. 이 동작은 뉴런과 아주 유사하고 그 과정은 다음과 같다. 다수의 입력을 받았을 때, 퍼셉트론은 각 입력 신호의 세기에 따라 다른 가중치를 부여한다. 그 결과를 고유한 방식으로 처리한 후, 입력 신호의 합이 일정 값을 초과한다면 그 결과를 다른 뉴련으로 전달한다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/perceptron.png" style="width: 90%    ; height: 250px;"></div><p>과거에는 이 퍼셉트론을 하드웨어를 이용하여 구현했다. 이 방식으로도 AND와 OR 문제를 해결이 가능했다. 그러나 이러한 단층 퍼셉트론으로는 XOR문제를 해결할 수 없었다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/xor.png" style="width: 100%    ; height: 250px;"></div><p>이러한 문제를 해결할 수 있는 것이 <strong>다층 퍼셉트론</strong> 이다.</p><p>딥러닝은 기본적으로 다음과 같은 순서로 진행이 된다.</p><p>Weight Initialization -&gt; Forward Propagation -&gt; Back Propagation</p><p>And Gate 연산을 예시로 퍼셉트론의 동작 순서에 대해 알아보자.</p><p><strong>Weight Initialization (가중치 초기화)</strong> : 예를 들어 노드를 3개를 쌓는다면 입력 값마다 3개의 가중치가 생성된다. 아래의 예시에서는 And Gate에서의 동작을 예로 들었는데 여기서는 0과 1 두개의 노드가 존재하므로 각 입력 값마다 2개의 가중치를 생성하여 계산하였다.</p><p><strong>Forward Propagation(순전파)</strong> : 가중치 초기화를 진행한 후에 각각의 입력 값과 가중치 값을 곱해주며 노드(퍼셉트론)에 들어온 값들을 모두 더해 activation function을 적용시켜 출력을 하게 된다. activation function은 threshold값을 지정해 그 값보다 크면 1, 작으면 0이 되는 식으로 동작할 수 있다.</p><p>Ex) And gate     <strong>activation function(활성함수)</strong> : ex) [(0.5 &lt; sum) : 1 / (0.5 &gt; sum) : 0]</p><table><thead><tr><th align="left"></th><th align="left">w1 * x1</th><th align="left">w2 * x2</th><th align="left">sum</th><th align="center">activate function</th><th align="right">output</th><th align="right">result</th></tr></thead><tbody><tr><td align="left">[0, 0]</td><td align="left">0.7*0</td><td align="left">0.4*0</td><td align="left">0</td><td align="center">0</td><td align="right">0</td><td align="right">true</td></tr><tr><td align="left">[1, 0]</td><td align="left">0.7*1</td><td align="left">0.4*0</td><td align="left">0.7</td><td align="center">1</td><td align="right">0</td><td align="right">false</td></tr><tr><td align="left">[0, 1]</td><td align="left">0.7*0</td><td align="left">0.4*1</td><td align="left">0.4</td><td align="center">0</td><td align="right">0</td><td align="right">true</td></tr><tr><td align="left">[1, 1]</td><td align="left">0.7*1</td><td align="left">0.4*1</td><td align="left">1.1</td><td align="center">1</td><td align="right">1</td><td align="right">true</td></tr></tbody></table><p> 세번째 행 : 틀린 결과 -&gt; Weight 재설정</p><p><strong>Back Propagation(역전파)</strong> : 위의 표와 같이 activation function을 거쳐 나온 결과값과 실제 값과의 차이를 비교하여 값이 틀렸다면 다시 가중치를 재설정하여 Forward Propagation과정을 반복한다.</p><p>예측 값과 실제 값의 차이를 비교하는 과정으로 아래의 cost function이 사용된다.</p><ul><li><strong>Cost function</strong> (=loss function = error function = objective function)</li></ul><p>예측 값과 실제 값의 차이를 기반으로 모델의 정확도(성능)을 판단하기 위한 함수로 아래의 수식을 따른다.</p><div style="width: 30%; height: 50px;">    <img src="https://kyu9341.github.io/img/lossfunction.png" style="width:100%    ; height: 50px;"></div><p>오차를 구하여 모델의 정확도를 판단하는데 이 값이 작을수록 모델의 성능이 좋다는 것을 뜻한다. 그래프로 본다면 아래와 같은데 이 오차를 줄이는 방법으로 경사하강법이 있다.</p><h4 id="Gradient-Descent-경사하강법"><a href="#Gradient-Descent-경사하강법" class="headerlink" title="Gradient Descent(경사하강법)"></a>Gradient Descent(경사하강법)</h4><p>해당 함수의 최소값 위치를 찾기 위해 비용함수(Cost Function)의 기울기가 (-)가 되는 방향으로 이동하여 최소값(=기울기 0)을 찾는 알고리즘이다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/Descent.png" style="width: 100%    ; height: 250px;"></div><h4 id="Optimizer-최적화기"><a href="#Optimizer-최적화기" class="headerlink" title="Optimizer(최적화기)"></a>Optimizer(최적화기)</h4><p>위에서 말한 최소값을 찾기 위한 방법으로 SGD, Momentum, NAG, Adagrad, Adadelta, Rmsprop, Adam 등의 여러가지 방법이 있는데, SGD는 layer가 늦은 경우 빠르게 찾아주고 데이터가 간단한 경우에 주로 사용한다. Adam은 정확도가 가장 높아서 일반적으로 가장 많이 사용한다고 한다.</p><p><strong>optimizer의 발전과정</strong></p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/optimizer.png" style="width: 90%    ; height: 250px;"></div><h4 id="Vanishing-Gradient"><a href="#Vanishing-Gradient" class="headerlink" title="Vanishing Gradient"></a>Vanishing Gradient</h4><p>Vanishing Gradient Problem(기울기 값이 사라지는 문제)는 인공신경망을 기울기 값을 베이스로 하는  mothod(backpropagation)로 학습시키려고 할 때 발생하는 문제이다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/vanishing.png" style="width: 90%    ; height: 250px;"></div><p>Vanishing Gradient Problem은 activate function을 의존적으로 일어난다. sigmoid함수나 tanh함수를 사용함으로써 발생하는 문제인데 layer가 깊어질수록 전달이 약해진다.<br>이 문제를 해결하기 위해서는 sigmoid함수 대신 ReLU 함수나 Leakey ReLU 등의 함수를 사용하면 된다.</p><h4 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h4><p>저번 머신러닝 교육 내용에도 있었지만 역시 딥러닝에도 Overfitting이 존재한다. overfitting은 훈련 데이터에만 정확도가 높아져 새로운 데이터에는 성능이 떨어지는 현상을 말하는데 이를 위한 해결방안으로 다음과 같은 것들이 있다.</p><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/regularization.png" style="width: 80%    ; height: 350px;"></div><p>–    L1 Regularization  :  세세한 값들은 무시하고 큰 특징들만 추출</p><p>–    L2 Regularization  :  세부적인 값들을 약하게 해줌</p><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/dropout.png" style="width: 80%    ; height: 350px;"></div><dl><dt>–    Dropout : hidden node 중 몇 개를 끊어 냄 -&gt; 똑같은 것만 학습하는 것을 방지</dt><dd>성능이 좋고 많이 사용 (20~50% 노드를 꺼줌)</dd></dl><h4 id="신경망-구조"><a href="#신경망-구조" class="headerlink" title="신경망 구조"></a>신경망 구조</h4><div style="width: 100%; height: 460px;">    <img src="https://kyu9341.github.io/img/hidden.png" style="width: 80%    ; height: 450px;"></div><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/output.png" style="width: 80%    ; height: 450px;"></div>#### 케라스다음은 딥러닝 프레임워크 중 하나인 케라스를 사용해서 jupyter notebook상에서 실습을 진행하였다. 케라스는 파이썬으로 구현된 high-level deep learning API이며 내부적으로는 TensorFlow로 동작한다. 쉬운 사용법과 간단한 문법으로 빠른 설계가 가능하고 입문자들이 사용해보기 좋다.<div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/mlt.png" style="width: 80%    ; height: 350px;"></div><p>실습은 딥러닝 방식중 하나인 MLP 를 사용하였고 AND, XOR 기능을 수행하는 모델을 만들었고 마지막으로 당뇨병 예측 모델을 만들어보았다.</p><h3 id="2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP"><a href="#2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP" class="headerlink" title="2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)"></a>2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)</h3><h2 id="첫번째-실습-Simple-Keras-모델-생성-학습-AND-Function"><a href="#첫번째-실습-Simple-Keras-모델-생성-학습-AND-Function" class="headerlink" title="첫번째 실습. Simple Keras 모델 생성/학습 - AND Function"></a>첫번째 실습. Simple Keras 모델 생성/학습 - AND Function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Numpy 가져오기</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(np.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.17.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 입력/출력 데이터 만들기</span></span><br><span class="line">X = np.array([[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">1</span>]]) <span class="comment"># numpy 형태로 입력 데이터 가져오기</span></span><br><span class="line">y = np.array([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]]) <span class="comment"># numpy 형태로 출력 데이터 가져오기</span></span><br><span class="line">                                <span class="comment"># 순서 맞춰야함</span></span><br><span class="line">print(X)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[0 0] [1 0] [0 1] [1 1]][[0] [0] [0] [1]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. Keras 패키지 가져오기</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers.core <span class="keyword">import</span> Dense, Activation</span><br><span class="line"></span><br><span class="line">print(keras.__version__)</span><br></pre></td></tr></table></figure><pre><code>2.3.1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. MLP 모델 생성</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line"><span class="comment"># model.add(Dense(4, input_dim=2)) # 첫번째인자 : node의 개수,  input_dim : feature의 개수 (x1, x2)</span></span><br><span class="line"><span class="comment"># model.add(Activation('relu')) # Activation Function 종류 설정</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">4</span>, input_dim=<span class="number">2</span>, activation=<span class="string">'relu'</span>)) <span class="comment"># 위의 두줄과 완전히 같은 뜻</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model.add(Dense(1)) # 최종 출력 1개# Dense Layer</span></span><br><span class="line"><span class="comment"># model.add(Activation('sigmoid'))</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)) <span class="comment"># 위의 두줄과 완전히 같은 뜻</span></span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br><span class="line"><span class="comment">#input 값이 2개지만 b도 하나의 값으로 추가되어 4*3 = 12 로 출력된다.</span></span><br><span class="line"><span class="comment"># Dense Layer : fully connected</span></span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_1 (Dense)              (None, 4)                 12        _________________________________________________________________dense_2 (Dense)              (None, 1)                 5         =================================================================Total params: 17Trainable params: 17Non-trainable params: 0_________________________________________________________________None</code></pre><h4 id="출력층-Output-Layer"><a href="#출력층-Output-Layer" class="headerlink" title="출력층(Output Layer)"></a>출력층(Output Layer)</h4><ul><li><p>linear : 특정 값 예측</p></li><li><p>sigmoid : 이진 클래스 예측</p></li><li><p>softmax : 다중 클래스 예측</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Compile - Optimizer, Loss function 설정</span></span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><pre><code>WARNING: Logging before flag parsing goes to stderr.W1123 21:54:23.066224 11320 deprecation.py:323] From c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\tensorflow\python\ops\nn_impl.py:180: add_dispatch_support.&lt;locals&gt;.wrapper (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version.Instructions for updating:Use tf.where in 2.0, which has the same broadcast rule as np.where</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># fit : 학습을 시키겠다,  verbose : 1 = 학습 과정을 본다 # shuffle : 한번 풀고 순서를 섞는다</span></span><br><span class="line">model.fit(X, y,</span><br><span class="line">          epochs=epochs,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          shuffle=<span class="literal">True</span>,</span><br><span class="line">          verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/10004/4 [==============================] - 0s 1ms/step - loss: 0.3339 - accuracy: 1.0000Epoch 2/10004/4 [==============================] - 0s 992us/step - loss: 0.3319 - accuracy: 1.0000....4/4 [==============================] - 0s 868us/step - loss: 0.0205 - accuracy: 1.0000Epoch 999/10004/4 [==============================] - 0s 992us/step - loss: 0.0204 - accuracy: 1.0000Epoch 1000/10004/4 [==============================] - 0s 858us/step - loss: 0.0204 - accuracy: 1.0000&lt;keras.callbacks.callbacks.History at 0x21a14b58748&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 테스트하기</span></span><br><span class="line">predict = model.predict(np.array([[<span class="number">0</span>,<span class="number">1</span>],])) <span class="comment"># ,해주어야 함 2차원 값임을 알려주기 위해</span></span><br><span class="line">print(predict)</span><br></pre></td></tr></table></figure><pre><code>[[0.0208632]]</code></pre><hr><h3 id="2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP-1"><a href="#2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP-1" class="headerlink" title="2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)"></a>2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)</h3><h2 id="세번째-실습-Keras-모델-생성-학습-당뇨병-예측-모델"><a href="#세번째-실습-Keras-모델-생성-학습-당뇨병-예측-모델" class="headerlink" title="세번째 실습. Keras 모델 생성/학습 - 당뇨병 예측 모델"></a>세번째 실습. Keras 모델 생성/학습 - 당뇨병 예측 모델</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Pandas 가져오기</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">print(pd.__version__)</span><br></pre></td></tr></table></figure><pre><code>0.24.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 데이터 불러오기</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'diabetes_data.csv'</span>)</span><br><span class="line">dataset.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/head.png" style="width: 90%    ; height: 250px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. X/y 나누기</span></span><br><span class="line"></span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>]</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">print(X.shape) <span class="comment"># (768, 8) -&gt; 8 : input_dim</span></span><br><span class="line">print(y.shape)</span><br></pre></td></tr></table></figure><pre><code>(768, 8)(768,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Train set, Test set 나누기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y,</span><br><span class="line">                                                    test_size=<span class="number">0.3</span>,</span><br><span class="line">                                                    random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">X_val, X_test, y_val, y_test = train_test_split(X_test, y_test,</span><br><span class="line">                                               test_size=<span class="number">0.5</span>,</span><br><span class="line">                                               random_state=<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line"></span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br><span class="line"></span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(537, 8)(537,)(115, 8)(115,)(116, 8)(116,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Keras 패키지 가져오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">print(keras.__version__)</span><br></pre></td></tr></table></figure><pre><code>2.2.4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. MLP 모델 생성</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">12</span>, input_dim=<span class="number">8</span>,</span><br><span class="line">                activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.3</span>))<span class="comment"># Dropout 설정</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">8</span>, activation=<span class="string">'relu'</span>))<span class="comment"># input_dim은 생략 - (12)로 자동 지정</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))<span class="comment"># Dropout 설정</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>WARNING:tensorflow:From /anaconda/envs/py35/lib/python3.5/site-packages/keras/backend/tensorflow_backend.py:3445: calling dropout (from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a future version.Instructions for updating:Please use `rate` instead of `keep_prob`. Rate should be set to `rate = 1 - keep_prob`._________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_7 (Dense)              (None, 12)                108       _________________________________________________________________dropout_1 (Dropout)          (None, 12)                0         _________________________________________________________________dense_8 (Dense)              (None, 8)                 104       _________________________________________________________________dropout_2 (Dropout)          (None, 8)                 0         _________________________________________________________________dense_9 (Dense)              (None, 1)                 9         =================================================================Total params: 221Trainable params: 221Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. Compile - Optimizer, Loss function 설정</span></span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">             optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 한번의 epochs가 끝날 때마다 history에 저장 (데이터 시각화)</span></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">         epochs=epochs,</span><br><span class="line">         batch_size=batch_size,</span><br><span class="line">         validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">         verbose=<span class="number">1</span>,</span><br><span class="line">         shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 537 samples, validate on 115 samplesEpoch 1/1000537/537 [==============================] - 1s 970us/step - loss: 4.9289 - acc: 0.5736 - val_loss: 3.2560 - val_acc: 0.6609Epoch 2/1000537/537 [==============================] - 0s 88us/step - loss: 3.4709 - acc: 0.6425 - val_loss: 3.2140 - val_acc: 0.6522Epoch 3/1000537/537 [==============================] - 0s 81us/step - loss: 3.7243 - acc: 0.5940 - val_loss: 3.0675 - val_acc: 0.6696Epoch 4/1000.......537/537 [==============================] - 0s 91us/step - loss: 0.5624 - acc: 0.7207 - val_loss: 0.5805 - val_acc: 0.7304Epoch 999/1000537/537 [==============================] - 0s 97us/step - loss: 0.5566 - acc: 0.7169 - val_loss: 0.5870 - val_acc: 0.7391Epoch 1000/1000537/537 [==============================] - 0s 91us/step - loss: 0.5356 - acc: 0.7449 - val_loss: 0.5801 - val_acc: 0.7391</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 모델 평가하기</span></span><br><span class="line">train_accuracy = model.evaluate(X_train, y_train)</span><br><span class="line">test_accuracy = model.evaluate(X_test, y_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Train Acc:"</span>, train_accuracy)</span><br><span class="line">print(<span class="string">"Test Acc:"</span>, test_accuracy)</span><br></pre></td></tr></table></figure><pre><code>537/537 [==============================] - 0s 21us/step116/116 [==============================] - 0s 27us/stepTrain Acc: [0.5100221896970738, 0.7541899434681045]Test Acc: [0.725729592915239, 0.6724137972141134]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'acc'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_acc'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>,<span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>,<span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/output_11_0.png" style="width: 80%    ; height: 350px;"></div><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/output_11_1.png" style="width: 80%    ; height: 350px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 저장하기/불러오기</span></span><br><span class="line">model.save(<span class="string">'my_model.h5'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line">model = load_model(<span class="string">'my_model.h5'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>참조<br><a href="https://ydseo.tistory.com/41" target="_blank" rel="external nofollow noopener noreferrer">https://ydseo.tistory.com/41</a><br><a href="http://research.sualab.com/introduction/2017/10/10/what-is-deep-learning-1.html" target="_blank" rel="external nofollow noopener noreferrer">http://research.sualab.com/introduction/2017/10/10/what-is-deep-learning-1.html</a><br><a href="https://blog.naver.com/minsu_jj/221607901559" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/minsu_jj/221607901559</a><br><a href="https://hobbang143.blog.me/221469060596" target="_blank" rel="external nofollow noopener noreferrer">https://hobbang143.blog.me/221469060596</a><br><a href="https://gomguard.tistory.com/187" target="_blank" rel="external nofollow noopener noreferrer">https://gomguard.tistory.com/187</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번주에 한이음에서 주최한 머신러닝 ICT멘토링 AI머신러닝(기초) 교육에 이어 이번에는 AI딥러닝 교육에 참가하게 되었다. 이번주도 토일 10:00 ~ 18:00까지 진행되는데 첫째 날은 딥러닝 이론, 케라스, Azure Cloud 설정, ML
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://kyu9341.github.io/categories/MachineLearning/"/>
    
    
  </entry>
  
</feed>

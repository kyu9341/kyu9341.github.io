<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2020-04-04T16:36:17.592Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 14428번 수열과 쿼리 16</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/05/algorithm14428/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/05/algorithm14428/</id>
    <published>2020-04-04T16:31:12.000Z</published>
    <updated>2020-04-04T16:36:17.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14428"><a href="#Problem-14428" class="headerlink" title="Problem 14428"></a>Problem 14428</h1><h2 id="수열과-쿼리-16"><a href="#수열과-쿼리-16" class="headerlink" title="수열과 쿼리 16"></a>수열과 쿼리 16</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>1 i v : Ai를 v로 바꾼다.</li><li>2 i j : Ai, Ai+1, …, Aj에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다.<br>수열의 인덱스는 1부터 시작한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p><p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14428" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14428</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 4 3 2 1<br>6<br>2 1 3<br>2 1 4<br>1 5 3<br>2 3 5<br>1 4 3<br>2 3 5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3<br>4<br>4<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>수열과 쿼리 15문제와 아주 유사하다. 2번 쿼리 시 범위가 주어지는 것이 다르다.</li><li>세그먼트 트리를 이용하여 각 노드에 더 자식 노드 중 더 작은 값의 인덱스를 저장한다.<ul><li>minIndex라는 함수를 생성하여 두 인덱스를 받아 더 작은 값을 가지는 인덱스를 리턴한다.</li><li>이 때, 두 값이 같은 경우 더 작은 인덱스를 리턴한다.</li></ul></li><li>2번 쿼리를 수행하는 경우 query함수에서 지정해준 범위를 벗어나면 -1을 리턴하고, 완전히 현재 구간이 지정해준 범위 내에 들어온다면 현재 노드의 값(하위 노드 중 최솟값을 가지는 인덱스)을 리턴한다.</li><li>1번 쿼리의 경우 update함수에서 minIndex함수를 사용해서 수정된 노드와 이어지는 노드들을 모두 수정한다.<ul><li>범위를 벗어나거나 리프 노드에서 수정할 인덱스를 찾았다면 현재 노드의 값(a의 인덱스)를 리턴</li><li>왼쪽, 오른쪽 자식 노드로 나누어 재귀를 수행하며 더 작은 값을 가지는 인덱스를 현재 노드에 저장(수정)</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIndex</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 더 작은 값의 인덱스를 반환하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 유효하지 않은 경우</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">// 같은 경우 더 작은 인덱스 리턴</span></span><br><span class="line"><span class="keyword">if</span> (a[x] == a[y]) <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a[x] &lt;= a[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = start;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(init(start, mid, node * <span class="number">2</span>), init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// index를 찾았거나 범위를 벗어난 경우 현재 노드 리턴</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; index || <span class="built_in">end</span> &lt; index) <span class="keyword">return</span> tree[node];</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값을 가지는 인덱스로 update</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(update(start, mid, node * <span class="number">2</span>, index), update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 구간을 벗어나는 경우</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 완전히 구간 안에 들어온 경우</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값을 가지는 인덱스 리턴</span></span><br><span class="line"><span class="keyword">return</span> minIndex(query(start, mid, node * <span class="number">2</span>, left, right), query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">init(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q, index, v, left, right;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; index &gt;&gt; v;</span><br><span class="line">a[index] = v;</span><br><span class="line">update(<span class="number">1</span>, n, <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, n, <span class="number">1</span>, left, right) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14428&quot;&gt;&lt;a href=&quot;#Problem-14428&quot; class=&quot;headerlink&quot; title=&quot;Problem 14428&quot;&gt;&lt;/a&gt;Problem 14428&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-16&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 13537번 수열과 쿼리 1</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/04/algorithm13537/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/04/algorithm13537/</id>
    <published>2020-04-04T04:11:12.000Z</published>
    <updated>2020-04-04T04:17:59.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-13537"><a href="#Problem-13537" class="headerlink" title="Problem 13537"></a>Problem 13537</h1><h2 id="수열과-쿼리-1"><a href="#수열과-쿼리-1" class="headerlink" title="수열과 쿼리 1"></a>수열과 쿼리 1</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>i j k: Ai, Ai+1, …, Aj로 이루어진 부분 수열 중에서 k보다 큰 원소의 개수를 출력한다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)이 주어진다.</p><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.</p><p>넷째 줄부터 M개의 줄에는 쿼리 i, j, k가 한 줄에 하나씩 주어진다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ 109)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/13537" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/13537</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 1 2 3 4<br>3<br>2 4 1<br>4 4 4<br>1 5 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2<br>0<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 리프 노드가 아닌 각 노드에 자식 노드들을 원소로 가지는 벡터를 저장한다.<ul><li>원소를 하나씩 입력받을 때마다 트리에 추가하며 알맞은 index를 찾아가며 지나는 노드에 현재 원소를 추가한다.</li><li>머지 소트의 모습과 유사하게 트리가 구성된다.</li></ul></li><li>트리가 완성되면 각 트리의 노드를 정렬한다.</li><li>쿼리가 입력되면 query함수에서 k보다 큰 값의 개수를 리턴해준다.<ul><li>범위를 완전히 벗어난 경우 0을 리턴하고</li><li>현재 노드에서 범위 안에 완벽하게 들어온 경우에 현재 노드의 벡터의 end()에서 upper_bound를 사용하여 k보다 큰 첫 번째 인덱스를 빼주어 k보다 큰 값의 개수를 구해 리턴한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 원소를 하나씩 추가하며 세그먼트 트리 구성</span></span><br><span class="line"><span class="comment">// 리프 노드가 아닌 각 노드에 자식 노드들을 원소로 가지는 벡터를 저장</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; index || <span class="built_in">end</span> &lt; index) <span class="keyword">return</span>;</span><br><span class="line">tree[node].push_back(x);</span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">update(start, mid, node * <span class="number">2</span>, index, x);</span><br><span class="line">update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; right || <span class="built_in">end</span> &lt; left) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 범위 안에 들어온 경우 더 큰 값들의 개수를 리턴</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; <span class="built_in">end</span> &lt;= right) <span class="keyword">return</span> tree[node].<span class="built_in">end</span>() - upper_bound(tree[node].<span class="built_in">begin</span>(), tree[node].<span class="built_in">end</span>(), k);</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 큰 값들의 개수를 더해 리턴</span></span><br><span class="line"><span class="keyword">return</span> query(start, mid, node * <span class="number">2</span>, left, right, k) + query(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">update(<span class="number">1</span>, n, <span class="number">1</span>, i, a[i]); <span class="comment">// 트리 구성</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX * <span class="number">4</span>; i++) <span class="comment">// 모든 노드 정렬</span></span><br><span class="line">sort(tree[i].<span class="built_in">begin</span>(), tree[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> left, right, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(<span class="number">1</span>, n, <span class="number">1</span>, left, right, k) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-13537&quot;&gt;&lt;a href=&quot;#Problem-13537&quot; class=&quot;headerlink&quot; title=&quot;Problem 13537&quot;&gt;&lt;/a&gt;Problem 13537&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-1&quot;&gt;&lt;a href=&quot;#수
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14427번 수열과 쿼리 15</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/04/algorithm14427/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/04/algorithm14427/</id>
    <published>2020-04-03T16:51:12.000Z</published>
    <updated>2020-04-03T16:56:32.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14427"><a href="#Problem-14427" class="headerlink" title="Problem 14427"></a>Problem 14427</h1><h2 id="수열과-쿼리-15"><a href="#수열과-쿼리-15" class="headerlink" title="수열과 쿼리 15"></a>수열과 쿼리 15</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.</p><ul><li>1 i v : Ai를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 109)</li><li>2 : 수열에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다.<br>수열의 인덱스는 1부터 시작한다.<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3>첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)</li></ul><p>둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)</p><p>셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)</p><p>넷째 줄부터 M개의 줄에는 쿼리가 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14427" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14427</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5<br>5 4 3 2 1<br>5<br>2<br>1 5 3<br>2<br>1 4 3<br>2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>5<br>4<br>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 각 노드에 더 자식 노드 중 더 작은 값의 인덱스를 저장한다.<ul><li>minIndex라는 함수를 생성하여 두 인덱스를 받아 더 작은 값을 가지는 인덱스를 리턴한다.</li><li>이 때, 두 값이 같은 경우 더 작은 인덱스를 리턴한다.</li></ul></li><li>2번 쿼리를 수행하는 경우 세그먼트 트리의 1번 노드에 최솟값의 인덱스가 저장되어 있으므로 tree[1] + 1을 출력한다.(인덱스는 0부터 저장했음)</li><li>1번 쿼리의 경우 update함수에서 minIndex함수를 사용해서 수정된 노드와 이어지는 노드들을 모두 수정한다.<ul><li>범위를 벗어나거나 리프 노드에서 수정할 인덱스를 찾았다면 현재 노드의 값(a의 인덱스)를 리턴</li><li>왼쪽, 오른쪽 자식 노드로 나누어 재귀를 수행하며 더 작은 값을 가지는 인덱스를 현재 노드에 저장(수정)</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tree[MAX * <span class="number">4</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minIndex</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 두 인덱스를 받아 더 작은 값을 가지는 인덱스를 리턴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] == a[y]) <span class="keyword">return</span> x &lt; y ? x : y; <span class="comment">// 같은 경우 더 작은 인덱스를 리턴</span></span><br><span class="line"><span class="keyword">return</span> a[x] &lt; a[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 자식 노드 중 작은 값의 인덱스를 부모 노드에 저장하는 세그먼트 트리</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = start;</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값의 인덱스를 각 노드에 저장</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(init(start, mid, node * <span class="number">2</span>), init(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 범위를 벗어나거나 수정할 인덱스를 찾았다면 현재 노드 리턴</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; start || index &gt; <span class="built_in">end</span> || start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 더 작은 값을 가지는 인덱스를 현재 노드에 저장</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = minIndex(update(start, mid, node * <span class="number">2</span>, index), update(mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">init(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 세그먼트 트리 생성</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q, index, value;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 수정하는 경우</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; index &gt;&gt; value;</span><br><span class="line">index--;</span><br><span class="line">a[index] = value;</span><br><span class="line">update(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="number">2</span>)</span><br><span class="line">&#123; <span class="comment">// 트리의 1번 노드가 최소값의 인덱스</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tree[<span class="number">1</span>] + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14427&quot;&gt;&lt;a href=&quot;#Problem-14427&quot; class=&quot;headerlink&quot; title=&quot;Problem 14427&quot;&gt;&lt;/a&gt;Problem 14427&lt;/h1&gt;&lt;h2 id=&quot;수열과-쿼리-15&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2042번 구간 합 구하기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/03/algorithm2042/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/03/algorithm2042/</id>
    <published>2020-04-03T04:51:12.000Z</published>
    <updated>2020-04-03T16:56:47.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2042"><a href="#Problem-2042" class="headerlink" title="Problem 2042"></a>Problem 2042</h1><h2 id="구간-합-구하기"><a href="#구간-합-구하기" class="headerlink" title="구간 합 구하기"></a>구간 합 구하기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b번째 수를 c로 바꾸고 a가 2인 경우에는 b번째 수부터 c번째 수까지의 합을 구하여 출력하면 된다.</p><p>입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -2^63보다 크거나 같고, 2^63-1보다 작거나 같은 정수이다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2042" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2042</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 2 2<br>1<br>2<br>3<br>4<br>5<br>1 3 6<br>2 2 5<br>1 5 2<br>2 3 5</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>17<br>12</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>세그먼트 트리를 이용하여 구간 합을 구하는 문제이다.</li><li>트리의 각 노드에 모든 하위 노드의 합을 저장하여 구간합을 구한다.</li><li>자세한 설명은 주석에 있다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">init</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt; &amp;a, <span class="built_in">vector</span>&lt;ll&gt; &amp;tree, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 세그먼트 트리 생성</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> tree[node] = a[start]; <span class="comment">// 리프 노드에 도달한 경우</span></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 재귀적으로 두 부분을 나누어 그 합을 자기 자신으로 한다.</span></span><br><span class="line"><span class="keyword">return</span> tree[node] = init(a, tree, start, mid, node * <span class="number">2</span>) + init(a, tree, mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// left ~ right 까지의 구간합을 구함, start, end : 시작, 끝 인덱스</span></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;&amp; tree, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어난 경우</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; <span class="built_in">end</span> || right &lt; start) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 범위 내에 포함된 경우 현재 트리의 값 리턴(구간합)</span></span><br><span class="line"><span class="keyword">if</span> (left &lt;= start &amp;&amp; right &gt;= <span class="built_in">end</span>) <span class="keyword">return</span> tree[node];</span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> sum(tree, start, mid, node * <span class="number">2</span>, left, right) + sum(tree, mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index : 수정할 노드의 인덱스, dif : 노드의 차이값</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;&amp; tree, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> node, <span class="keyword">int</span> index, ll dif)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 범위를 벗어난 경우</span></span><br><span class="line"><span class="keyword">if</span> (index &lt; start || index &gt; <span class="built_in">end</span>) <span class="keyword">return</span>;</span><br><span class="line">tree[node] += dif; <span class="comment">// 수정할 노드가 포함된 노드들의 값을 수정</span></span><br><span class="line"><span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span>; <span class="comment">// 수정할 노드를 찾은 경우</span></span><br><span class="line"><span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">update(tree, start, mid, node * <span class="number">2</span>, index, dif);</span><br><span class="line">update(tree, mid + <span class="number">1</span>, <span class="built_in">end</span>, node * <span class="number">2</span> + <span class="number">1</span>, index, dif);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; a(n);</span><br><span class="line"><span class="keyword">int</span> h = (<span class="keyword">int</span>)<span class="built_in">ceil</span>(log2(n)); <span class="comment">// 트리의 높이</span></span><br><span class="line"><span class="keyword">int</span> tree_size = (<span class="number">1</span> &lt;&lt; (h + <span class="number">1</span>)); <span class="comment">// 세그먼트 트리의 크기</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; tree(tree_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">init(a, tree, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 세그먼트 트리 생성</span></span><br><span class="line">k += m; <span class="comment">// m + k번 반복</span></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t1, t2, t3;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;</span><br><span class="line"><span class="keyword">if</span> (t1 == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t2--; <span class="comment">// 인덱스로 맞춤</span></span><br><span class="line">ll dif = (ll)(t3 - a[t2]); <span class="comment">// 차이값 저장</span></span><br><span class="line">a[t2] = t3; <span class="comment">// a[t2] 값 변경</span></span><br><span class="line">update(tree, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, t2, dif);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t1 == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum(tree, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>, t2 - <span class="number">1</span>, t3 - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2042&quot;&gt;&lt;a href=&quot;#Problem-2042&quot; class=&quot;headerlink&quot; title=&quot;Problem 2042&quot;&gt;&lt;/a&gt;Problem 2042&lt;/h1&gt;&lt;h2 id=&quot;구간-합-구하기&quot;&gt;&lt;a href=&quot;#구간-합-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 12970번 AB</title>
    <link href="https://kyu9341.github.io/algorithm/2020/04/03/algorithm12970/"/>
    <id>https://kyu9341.github.io/algorithm/2020/04/03/algorithm12970/</id>
    <published>2020-04-02T18:11:12.000Z</published>
    <updated>2020-04-02T18:15:51.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-12970"><a href="#Problem-12970" class="headerlink" title="Problem 12970"></a>Problem 12970</h1><h2 id="AB"><a href="#AB" class="headerlink" title="AB"></a>AB</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>정수 N과 K가 주어졌을 때, 다음 두 조건을 만족하는 문자열 S를 찾는 프로그램을 작성하시오.</p><ul><li>문자열 S의 길이는 N이고, ‘A’, ‘B’로 이루어져 있다.</li><li>문자열 S에는 0 ≤ i &lt; j &lt; N 이면서 s[i] == ‘A’ &amp;&amp; s[j] == ‘B’를 만족하는 (i, j) 쌍이 K개가 있다.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N과 K가 주어진다. (2 ≤ N ≤ 50, 0 ≤ K ≤ N(N-1)/2)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 조건을 만족하는 문자열 S를 출력한다. 가능한 S가 여러 가지라면, 아무거나 출력한다. 만약, 그러한 S가 존재하지 않는 경우에는 -1을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/12970" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/12970</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>ABB</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>2 0</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>BA</p><h3 id="예제-입력-2-1"><a href="#예제-입력-2-1" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>5 8</p><h3 id="예제-출력-2-1"><a href="#예제-출력-2-1" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>-1</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>10 12</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>BAABBABAAB</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>A와 B의 개수를 각각 a, b라고 했을때, 만족하는 쌍의 개수는 0 ~ a * b개가 된다.</li><li>여기서 주어진 k개 만큼 쌍을 가지도록 문자열을 만들기 위해서는 먼저 주어진 문자열의 크기만큼 모두 B로 채우고,</li><li>k가 a * b보다 작거나 같을 때까지 a, b를 조정한다.</li><li>작거나 같아진다면 앞에서부터 a - 1개까지 A로 채운다.<ul><li>예를 들어, 입력이 7 11 이라면 a = 3, b = 4 일때 만족하므로</li><li>AABBBBB와 같은 상태로 문자열을 만든다.</li><li>여기서 맨 마지막 문자를 A로 바꾼다면 AABBBBA가 될 것이다.</li><li>이 상태에서 쌍의 개수는 (a - 1) * b개가 되고 이 값을 k에서 빼면 남은 필요한 쌍의 개수가 된다.<ul><li>(이 값을 r이라고 한다.)</li></ul></li><li>AABBBBA에서 마지막 A를 한 칸씩 왼쪽으로 이동시킬 때마다 필요한 쌍의 개수가 1씩 증가한다.</li><li>즉, 마지막 A를 왼쪽으로 r만큼 이동시키면 k개의 쌍을 구할 수 있다.</li></ul></li><li>위와 같이 그리디 방식으로 문제를 해결하였다.</li></ul><hr><ul><li>조건을 만족하는 문자열이 있으려면 최대 (n/2 * (n - n/2)) 보다 작아야 한다.<ul><li>가장 많은 쌍을 가지는 경우가 A와 B가 절반 씩 있는 경우이다.</li></ul></li><li>먼저 주어진 문자열의 크기만큼 모두 B로 채운다.</li><li>k가 0인 경우 예외처리를 해준다. (그냥 맨 마지막 문자를 A로 바꿔서 처리했다.)</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countAB</span><span class="params">(<span class="built_in">string</span> ab)</span> <span class="comment">// 디버깅용 AB개수 체크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ab.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ab[i] == <span class="string">'A'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; ab.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ab[j] == <span class="string">'B'</span>)</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k &gt; m * (n - m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ab = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// B로 모두 채운다.</span></span><br><span class="line">ab += <span class="string">'B'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">0</span>) <span class="comment">// 0일 때 예외 처리</span></span><br><span class="line">&#123;</span><br><span class="line">ab[n - <span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ab &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = n; <span class="comment">// A, B의 개수 초기화</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a * b &gt;= k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a - <span class="number">1</span>; i++) <span class="comment">// 앞에서부터 A의 개수 - 1 개를 A로 채운다.</span></span><br><span class="line">ab[i] = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = (a - <span class="number">1</span>) * b; <span class="comment">// A의 개수 - 1 * B의 개수를 저장 (마지막에 들어갈 A를 제외한 개수)</span></span><br><span class="line"><span class="keyword">int</span> r = k - c; <span class="comment">// 마지막 A를 이용하여 채워야할 쌍의 개수</span></span><br><span class="line">ab[(n - <span class="number">1</span>) - r] = <span class="string">'A'</span>; <span class="comment">// 마지막 인덱스에서 r개 앞에 A를 넣는다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b--; <span class="comment">// A, B의 개수 조정</span></span><br><span class="line">a++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ab &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-12970&quot;&gt;&lt;a href=&quot;#Problem-12970&quot; class=&quot;headerlink&quot; title=&quot;Problem 12970&quot;&gt;&lt;/a&gt;Problem 12970&lt;/h1&gt;&lt;h2 id=&quot;AB&quot;&gt;&lt;a href=&quot;#AB&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14267번 내리 갈굼</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/31/algorithm14267/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/31/algorithm14267/</id>
    <published>2020-03-30T16:41:12.000Z</published>
    <updated>2020-03-30T16:46:34.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14267"><a href="#Problem-14267" class="headerlink" title="Problem 14267"></a>Problem 14267</h1><h2 id="내리-갈굼"><a href="#내리-갈굼" class="headerlink" title="내리 갈굼"></a>내리 갈굼</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>영선회사에는 치명적인 악습이 있는데, 바로 상사가 직속 부하를 갈구면 그 부하가 부하의 직속 부하를 연쇄적으로 갈구는 내리 갈굼이 있다. 즉, 상사가 한 직속 부하를 갈구면 그 부하의 모든 부하들이 갈굼을 당한다.</p><p>갈굼에 대해 정도에 대한 수치가 주어지는데, 이 수치 또한 부하들에게 똑같이 갈궈진다.</p><p>직속 상사와 직속 부하관계에 대해 주어지고, 갈굼에 대한 정보가 주어질 때, 각자 얼마의 갈굼을 당했는지 출력하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에는 회사의 직원 수 n명, 최초의 갈굼 횟수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)</p><p>둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.</p><p>다음 m줄에는 직속 상사로부터 갈굼을 당한 직원 번호 i,갈굼의 수치 w가 주어진다.(2 ≤ i ≤ n, 1 ≤ w ≤ 1,000) 사장은 상사가 없으므로 갈굼을 당하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>1번부터 n번의 직원까지 갈굼을 당한 정도를 출력하시오.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14267" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14267</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 3<br>-1 1 2 3 4<br>2 2<br>3 4<br>5 6</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0 2 6 6 12</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>dfs로 갈굼 정도를 누적하여 부하에게 물려주면 된다.</li><li>n제한이 10만이기 때문에 갈굼의 정도를 모두 저장 후 한번만 순회하면서 모두 물려주도록 한다.</li><li>같은 부하에게 여러번 갈구는 경우를 생각하지 않아서 계속 틀렸던 거였다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cost[MAX + <span class="number">1</span>]; <span class="comment">// 갈굼 횟수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[now].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> next = v[now][i];</span><br><span class="line">cost[next] += cost[now]; <span class="comment">// 갈굼 수치 누적</span></span><br><span class="line">go(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// -1은 건너뜀</span></span><br><span class="line">v[k].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">cost[u] += v;<span class="comment">// 갈굼 정도 저장</span></span><br><span class="line">&#125;</span><br><span class="line">go(<span class="number">1</span>); <span class="comment">// 1번부터 dfs</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cost[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14267&quot;&gt;&lt;a href=&quot;#Problem-14267&quot; class=&quot;headerlink&quot; title=&quot;Problem 14267&quot;&gt;&lt;/a&gt;Problem 14267&lt;/h1&gt;&lt;h2 id=&quot;내리-갈굼&quot;&gt;&lt;a href=&quot;#내리-갈
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>JDBC 마리아 DB 연동 - 이클립스</title>
    <link href="https://kyu9341.github.io/java/2020/03/30/java_jdbc/"/>
    <id>https://kyu9341.github.io/java/2020/03/30/java_jdbc/</id>
    <published>2020-03-30T06:12:28.000Z</published>
    <updated>2020-03-30T11:32:38.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC-마리아-DB-연동-with-이클립스"><a href="#JDBC-마리아-DB-연동-with-이클립스" class="headerlink" title="JDBC 마리아 DB 연동 with 이클립스"></a>JDBC 마리아 DB 연동 with 이클립스</h2><h3 id="MariaDB-JDBC-드라이버-설치"><a href="#MariaDB-JDBC-드라이버-설치" class="headerlink" title="MariaDB JDBC 드라이버 설치"></a>MariaDB JDBC 드라이버 설치</h3><p>JDBC를 사용하여 데이터베이스와 연결하기 위해서는 각 DBMS에 맞는 JDBC드라이버가 필요하다.</p><p>먼저 마리아 db가 설치를 한 뒤 다음 사이트로 이동한다.</p><p><a href="https://downloads.mariadb.org/connector-java/" target="_blank" rel="external nofollow noopener noreferrer">https://downloads.mariadb.org/connector-java/</a></p><p>이동하여 아래의 다운로드 버튼을 선택한다.</p><div style="width: 700px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc0.png" style="width: 700px    ; height: 400px;"></div><p>(MariaDB Connector/J .jar files) 을 선택한다.</p><div style="width: 600px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc01.png" style="width: 600px    ; height: 400px;"></div><p>그럼 다음 화면으로 넘어가는데, 아래 화면에 표시된 jar파일을 선택하여 다운로드 받는다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc02.png" style="width: 400px    ; height: 400px;"></div><h3 id="이클립스-연동"><a href="#이클립스-연동" class="headerlink" title="이클립스 연동"></a>이클립스 연동</h3><p>이제 이클립스로 넘어가서 연동시킬 프로젝트에서 우클릭을 하여 Build Path를 선택하고 <strong>Configure Build Path</strong> 를 선택한다.</p><div style="width: 600px; height: 610px;">    <img src="https://kyu9341.github.io/img/jdbc1.png" style="width: 600px    ; height: 600px;"></div><p>다음과 같은 창이 뜨면 아래 표시된 대로 Java Build Path =&gt; Libraries =&gt; Add External JARs… 을 선택한다.</p><div style="width: 700px; height: 510px;">    <img src="https://kyu9341.github.io/img/jdbc2.png" style="width: 700px    ; height: 500px;"></div><p>위에서 다운받았던 폴더로 이동하여 다운로드된 jar파일을 선택한다.</p><div style="width: 700px; height: 80px;">    <img src="https://kyu9341.github.io/img/jdbc3.png" style="width: 700px    ; height: 50px;"></div><p>아래와 같이 선택이 되었다면 Apply버튼을 눌러 적용을 하고 닫아준다.</p><div style="width: 700px; height: 500px;">    <img src="https://kyu9341.github.io/img/jdbc4.png" style="width: 700px    ; height: 500px;"></div><p>그럼 Referenced Libraries아래에 jar파일이 추가된 것을 확인할 수 있다.<br>아래와 같이 선택이 되었다면 Apply버튼을 눌러 적용을 하고 닫아준다.</p><div style="width: 250px; height: 400px;">    <img src="https://kyu9341.github.io/img/jdbc5.png" style="width: 250px    ; height: 400px;"></div><h3 id="MariaDB-연동-예제-코드"><a href="#MariaDB-연동-예제-코드" class="headerlink" title="MariaDB 연동 예제 코드"></a>MariaDB 연동 예제 코드</h3><ul><li>간단하게 데이터베이스와 연동하여 원하는 컬럼의 값을 가져오는 예제이다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Thread.State;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">String url = <span class="string">"jdbc:mariadb://127.0.0.1:3307/dbName"</span>;</span><br><span class="line">String sql = <span class="string">"SELECT * FROM tableName"</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 클래스를 객체화, 드라이버를 로드</span></span><br><span class="line">Class.forName(<span class="string">"org.mariadb.jdbc.Driver"</span>);</span><br><span class="line">                <span class="comment">// 실행 도구 생성</span></span><br><span class="line">Connection con = DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"asas1207"</span>);</span><br><span class="line">                <span class="comment">// 연결 객체를 얻음</span></span><br><span class="line">Statement st = con.createStatement();</span><br><span class="line">                <span class="comment">// 쿼리를 실행하여 결과 집합을 얻어온다.</span></span><br><span class="line">ResultSet rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rs.next()) &#123; <span class="comment">// 다음 값을 가져옴 Bof ~ Eof</span></span><br><span class="line">String ex1 = rs.getString(<span class="string">"columnName"</span>);</span><br><span class="line">System.out.println(ex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs.close();</span><br><span class="line">st.close();</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDBC-마리아-DB-연동-with-이클립스&quot;&gt;&lt;a href=&quot;#JDBC-마리아-DB-연동-with-이클립스&quot; class=&quot;headerlink&quot; title=&quot;JDBC 마리아 DB 연동 with 이클립스&quot;&gt;&lt;/a&gt;JDBC 마리아 DB 연동
      
    
    </summary>
    
    
      <category term="java" scheme="https://kyu9341.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 13548번 시험 감독</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/27/algorithm13458/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/27/algorithm13458/</id>
    <published>2020-03-27T07:01:01.000Z</published>
    <updated>2020-03-27T07:01:56.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-13548"><a href="#Problem-13548" class="headerlink" title="Problem 13548"></a>Problem 13548</h1><h2 id="시험-감독"><a href="#시험-감독" class="headerlink" title="시험 감독"></a>시험 감독</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다.</p><p>감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다.</p><p>각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다.</p><p>각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 시험장의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다.</p><p>둘째 줄에는 각 시험장에 있는 응시자의 수 Ai (1 ≤ Ai ≤ 1,000,000)가 주어진다.</p><p>셋째 줄에는 B와 C가 주어진다. (1 ≤ B, C ≤ 1,000,000)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>각 시험장마다 응시생을 모두 감독하기 위해 필요한 감독관의 최소 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/13548" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/13548</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>1<br>1<br>1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3<br>3 4 5<br>2 2</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>7</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>5<br>1000000 1000000 1000000 1000000 1000000<br>5 7</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>714290</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>5<br>10 9 10 9 10<br>7 20</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>10</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>총 감독관은 최소 1명씩 필요하므로 ans를 n으로 초기화한다.</li><li>각 시험장의 인원 수에서 총 감독관이 감시가능한 인원을 빼고, 나머지 인원을 부 감독관이 감시가능한 인원으로 나눈다.<ul><li>이 때, 나눈 몫이 필요한 부 감독관의 인원 수인데, 나머지가 0이면 나눈 몫을 넣고 0이 아니면 1명이 더 필요하므로 1을 더하여 누적한다.</li><li>또한 총 감독관만으로 모든 인원을 감시할 수 있는 경우에는 위 연산을 수행하지 않고 넘어간다.</li></ul></li><li>주의할 점은 100만 * 100만이 최대이므로 long long형으로 구해야 한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, b, c; <span class="comment">// 100만 * 100만이 최대이므로 long long</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = n; <span class="comment">// 총 감독관은 무조건 1명씩</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] -= b;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 총 감독관 1명으로 모두 감시 가능한 경우</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s = a[i] / c;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r = a[i] % c;</span><br><span class="line"></span><br><span class="line">ans += r == <span class="number">0</span> ? s : s + <span class="number">1</span>; <span class="comment">// 나머지가 0이 아니면 1명 추가</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-13548&quot;&gt;&lt;a href=&quot;#Problem-13548&quot; class=&quot;headerlink&quot; title=&quot;Problem 13548&quot;&gt;&lt;/a&gt;Problem 13548&lt;/h1&gt;&lt;h2 id=&quot;시험-감독&quot;&gt;&lt;a href=&quot;#시험-감
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 18808번 스티커 붙이기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/27/algorithm18808/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/27/algorithm18808/</id>
    <published>2020-03-26T16:10:12.000Z</published>
    <updated>2020-03-26T16:15:08.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-18808"><a href="#Problem-18808" class="headerlink" title="Problem 18808"></a>Problem 18808</h1><h2 id="스티커-붙이기"><a href="#스티커-붙이기" class="headerlink" title="스티커 붙이기"></a>스티커 붙이기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>R혜윤이는 최근에 다양한 대회를 참여하면서 노트북에 붙일 수 있는 스티커들을 많이 받았다. 스티커는 아래와 같이 사각 모눈종이 위에 인쇄되어 있으며, 스티커의 각 칸은 상하좌우로 모두 연결되어 있다. 또한 모눈종이의 크기는 스티커의 크기에 꼭 맞아서, 상하좌우에 스티커가 포함되지 않는 불필요한 행이나 열이 존재하지 않는다.</p><p>아래는 올바른 모눈종이의 예시이다. 주황색 칸은 스티커가 붙은 칸을, 하얀색 칸은 스티커가 붙지 않은 칸을 나타낸다.</p><p>반면 아래는 올바르지 않은 모눈종이의 예시이다. 첫 번째는 윗쪽에 불필요한 행이 있고, 두 번째는 왼쪽에 불필요한 열이 있다. 그리고 세 번째는 스티커의 각 칸이 상하좌우로 모두 연결되어 있지 않다.</p><p>혜윤이는 자신의 노트북에 이 스티커들을 붙이기로 했다. 혜윤이의 노트북은 마침 직사각형 모양이고, 스티커가 인쇄된 모눈종이와 같은 간격으로 격자가 그려져 있다. 혜윤이는 스티커들을 먼저 받았던 것부터 차례대로 격자에 맞춰서 붙이려고 한다.</p><p>혜윤이가 스티커를 붙이는 방법은 다음과 같다.</p><ol><li>스티커를 회전시키지 않고 모눈종이에서 떼어낸다.</li><li>다른 스티커와 겹치거나 노트북을 벗어나지 않으면서 스티커를 붙일 수 있는 위치를 찾는다. 혜윤이는 노트북의 위쪽부터 스티커를 채워 나가려고 해서, 스티커를 붙일 수 있는 위치가 여러 곳 있다면 가장 위쪽의 위치를 선택한다. 가장 위쪽에 해당하는 위치도 여러 곳이 있다면 그중에서 가장 왼쪽의 위치를 선택한다.</li><li>선택한 위치에 스티커를 붙인다. 만약 스티커를 붙일 수 있는 위치가 전혀 없어서 스티커를 붙이지 못했다면, 스티커를 시계 방향으로 90도 회전한 뒤 2번 과정을 반복한다.</li><li>위의 과정을 네 번 반복해서 스티커를 0도, 90도, 180도, 270도 회전시켜 봤음에도 스티커를 붙이지 못했다면 해당 스티커를 붙이지 않고 버린다.</li></ol><p>아래의 예시를 통해 스티커를 붙이는 과정을 이해해보자. 노트북은 세로 5칸, 가로 4칸 크기이고, 혜윤이가 가지고 있는 스티커들은 아래와 같다. 왼쪽에서 오른쪽 순으로 스티커를 붙일 것이다.</p><p>첫 번째 스티커는 회전 없이 온전히 붙일 수 있는 공간이 아래와 같이 6곳이 있다.</p><p>이 중에서 가장 위쪽의 위치, 가능한 가장 위쪽의 위치가 여러 개이면 그 중에서 가장 왼쪽의 위치는 첫 번째이다. 스티커를 붙인 후 노트북의 모양은 아래와 같다.</p><p>두 번째 스티커는 회전 없이 온전히 붙일 수 있는 공간이 없다. 그러나 시계 방향으로 90도 회전한 후에는 붙일 수 있는 공간이 1개 생긴다. 해당 공간에 스티커를 붙인 후 노트북의 모양은 아래와 같다.</p><p>세 번째 스티커는 스티커를 시계방향으로 0, 90, 180, 270도 회전시킨 모양에 대해 전부 확인을 해도 스티커를 붙일 수 있는 공간이 없다. 그러므로 해당 스티커를 붙이지 않고 버린다.</p><p>네 번째 스티커는 스티커를 시계방향으로 0, 90, 180도 회전 시킨 모양에 대해 온전히 붙일 수 있는 공간이 없다. 그러나 시계 방향으로 270도 회전한 후에는 공간이 1개 생긴다. 스티커를 붙인 후 노트북의 모양은 아래와 같다. 최종적으로 노트북의 18칸이 스티커로 채워졌다.</p><p>혜윤이는 스티커를 다 붙인 후의 노트북의 모습이 궁금해졌다. 노트북의 크기와 스티커들이 주어졌을 때 스티커들을 차례대로 붙이고 난 후 노트북에서 몇 개의 칸이 채워졌는지 구해보자.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 노트북의 세로와 가로 길이를 나타내는 N(1 ≤ N ≤ 40)과 M(1 ≤ M ≤ 40), 그리고 스티커의 개수 K(1 ≤ K ≤ 100)이 한 칸의 빈칸을 사이에 두고 주어진다.</p><p>그 다음 줄부터는 K개의 스티커들에 대한 정보가 주어진다. 각 스티커는 아래와 같은 형식으로 주어진다.</p><p>먼저 i번째 스티커가 인쇄된 모눈종이의 행의 개수와 열의 개수를 나타내는 Ri(1 ≤ Ri ≤ 10)와 Ci(1 ≤ Ci ≤ 10)가 한 칸의 빈칸을 사이에 두고 주어진다.</p><p>다음 Ri개의 줄에는 각 줄마다 모눈종이의 각 행을 나타내는 Ci개의 정수가 한 개의 빈칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0, 1이다. 0은 스티커가 붙지 않은 칸을, 1은 스티커가 붙은 칸을 의미한다.</p><p>문제에서 설명한 것과 같이 스티커는 모두 올바른 모눈종이에 인쇄되어 있다. 구체적으로 스티커의 각 칸은 상하좌우로 모두 연결되어 있고, 모눈종이의 크기는 스티커의 크기에 꼭 맞아서 상하좌우에 스티커에 전혀 포함되지 않는 불필요한 행이나 열이 존재하지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 주어진 스티커들을 차례대로 붙였을 때 노트북에서 스티커가 붙은 칸의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/18808" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/18808</a></p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ol><li>스티커를 회전시키지 않고 모눈종이에서 떼어낸다.</li><li>다른 스티커와 겹치거나 노트북을 벗어나지 않으면서 스티커를 붙일 수 있는 위치를 찾는다. 혜윤이는 노트북의 위쪽부터 스티커를 채워 나가려고 해서, 스티커를 붙일 수 있는 위치가 여러 곳 있다면 가장 위쪽의 위치를 선택한다. 가장 위쪽에 해당하는 위치도 여러 곳이 있다면 그중에서 가장 왼쪽의 위치를 선택한다.</li><li>선택한 위치에 스티커를 붙인다. 만약 스티커를 붙일 수 있는 위치가 전혀 없어서 스티커를 붙이지 못했다면, 스티커를 시계 방향으로 90도 회전한 뒤 2번 과정을 반복한다.</li><li>위의 과정을 네 번 반복해서 스티커를 0도, 90도, 180도, 270도 회전시켜 봤음에도 스티커를 붙이지 못했다면 해당 스티커를 붙이지 않고 버린다.</li></ol><hr><ul><li><p>위의 1~4번 과정을 그대로 구현하면 된다.</p></li><li><p>먼저, 스티커를 노트북에 붙이는 함수(attach)와 스티커를 90도 회전시키는 함수(rotate)를 만들었다.</p><ul><li>attach함수는 현재 위치부터 스티커의 범위까지 a[x][y]가 0(스티커가 없는 경우)인 경우에만 스티커를 붙였다.</li><li>rotate함수는 임시 배열에 현재 스티커 배열을 복사하고 스티커 배열을 0으로 초기화 한다.</li><li>90도를 회전하는 것이므로 행과 열이 뒤바뀌게 된다. 회전하기 전 행, 열의 크기를 row-1, col-1이라 한다면<ul><li>(0, 0) -&gt; (0, row - 1)로, (0, 1) -&gt; (1, row - 1), (0, 2) -&gt; (2, row - 1) …</li><li>(1, 0) -&gt; (0, row - 1 -1), (2, 0) -&gt; (0, row - 1 - 2) …</li></ul></li><li>와 같이 이동한다. 즉, 열은 숫자 그대로 행으로 이동하고, 행은 row - 1부터 줄어들며 열로 이동한다.</li></ul></li><li><p>재귀함수를 이용하여 현재 스티커의 모양으로 왼쪽 위부터 스티커를 노트북에 붙일 수 있는지 확인한다.</p><ul><li>노트북의 범위를 돌며 현재 위치부터 스티커의 범위를 확인하여 스티커가 붙은 곳에 스티커를 붙이는 경우 불가능하다고 판별하도록 하였다.</li><li>불가능한 경우 break로 빠져나왔고, 현재 위치부터 스티커의 범위 모두 가능한 경우라면 attach함수로 현재 위치에 스티커를 붙이고 true 를 리턴했다.</li></ul></li><li><p>현재 모양으로 붙일 수 없는 경우 rotate함수로 90도 회전시킨 후, row와 col을 뒤집어 재귀를 수행한다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> sticker[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> <span class="comment">// 스티커를 노트북에 붙이는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &lt; i + row; x++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = j; y &lt; j + col; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x][y] == <span class="number">0</span>)</span><br><span class="line">a[x][y] = sticker[x - i][y - j]; <span class="comment">// 노트북의 현재 위치에 붙임</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> <span class="comment">// 90도 회전시키는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">tmp[i][j] = sticker[i][j]; <span class="comment">// 임시 배열에 복사</span></span><br><span class="line"><span class="built_in">memset</span>(sticker, <span class="number">0</span>, <span class="keyword">sizeof</span>(sticker)); <span class="comment">// 스티커 초기화</span></span><br><span class="line"><span class="comment">// 행과 열을 뒤집는다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)</span><br><span class="line">&#123;</span><br><span class="line">sticker[i][j] = tmp[row - <span class="number">1</span> - j][i]; <span class="comment">// 90도 회전</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">attempt</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 모든 방향 확인 후 붙일 수 없다면 false리턴</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> possible = <span class="literal">false</span>; <span class="comment">// 붙일 수 있는지 확인</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= row &amp;&amp; m &gt;= col) <span class="comment">// 노트북 범위에 맞을때만 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">possible = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i + row &lt;= n &amp;&amp; j + col &lt;= m) <span class="comment">// 범위 내에서</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; row; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; col; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sticker[x][y] == <span class="number">1</span> &amp;&amp; a[i + x][j + y] == <span class="number">1</span>) <span class="comment">// 스티커가 붙은 곳에 스티커를 붙이는 경우 불가능</span></span><br><span class="line">&#123; <span class="comment">// 붙일 수 없는 경우</span></span><br><span class="line">possible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!possible) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> possible = <span class="literal">false</span>; <span class="comment">// 범위를 벗어나면 불가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (possible) <span class="comment">// 붙일 수 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">attach</span>(i, j, row, col); <span class="comment">// 노트북에 붙이고 true리턴</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!possible) <span class="comment">// 현재 모양으로 붙일 수 없는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">rotate(row, col); <span class="comment">// 90도 회전</span></span><br><span class="line"><span class="keyword">if</span> (attempt(col, row, cnt + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 회전하면 row, col이 바뀌므로 바꿔서 재귀</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sticker[i][j];</span><br><span class="line"></span><br><span class="line">attempt(row, col, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">1</span>) ans++; <span class="comment">// 스티커 붙은 칸 카운트</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-18808&quot;&gt;&lt;a href=&quot;#Problem-18808&quot; class=&quot;headerlink&quot; title=&quot;Problem 18808&quot;&gt;&lt;/a&gt;Problem 18808&lt;/h1&gt;&lt;h2 id=&quot;스티커-붙이기&quot;&gt;&lt;a href=&quot;#스티
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14890번 경사로</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/26/algorithm14890/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/26/algorithm14890/</id>
    <published>2020-03-25T17:40:01.000Z</published>
    <updated>2020-03-25T17:42:02.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14890"><a href="#Problem-14890" class="headerlink" title="Problem 14890"></a>Problem 14890</h1><h2 id="경사로"><a href="#경사로" class="headerlink" title="경사로"></a>경사로</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.</p><p>오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.</p><p>다음과 같은 N=6인 경우 지도를 살펴보자.</p><p>이때, 길은 총 2N개가 있으며, 아래와 같다.</p><p>길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.</p><p>경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.<br>낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.<br>경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.<br>아래와 같은 경우에는 경사로를 놓을 수 없다.</p><p>경사로를 놓은 곳에 또 경사로를 놓는 경우<br>낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우<br>낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우<br>경사로를 놓다가 범위를 벗어나는 경우<br>L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.</p><p>경사로를 놓을 수 없는 경우는 아래와 같다.</p><p>위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.</p><p>가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.</p><p>지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14890" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14890</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>6 2<br>3 3 3 3 3 3<br>2 3 3 3 3 3<br>2 2 2 3 2 3<br>1 1 1 2 2 2<br>1 1 1 3 3 1<br>1 1 2 3 3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 2<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>7</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 3<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>3</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6 1<br>3 2 1 1 2 3<br>3 2 2 1 2 3<br>3 2 2 2 3 3<br>3 3 3 3 3 3<br>3 3 3 3 2 2<br>3 3 3 3 2 2</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>11</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>check_row, check_col 배열에 행, 열 별로 지나갈 수 있는 길인지 여부를 저장한다.<ul><li>초기값을 true로 지정하여 불가능한 경우가 나오면 false로 변경하고 다음 길을 확인하는 방식으로 구현하였다.</li></ul></li><li>높이의 차가 2 이상인 경우는 불가능한 경우이므로 제외시킨다.</li><li>다음 좌표와의 높이 차를 구해 같은 높이인 경우, 높이가 낮아지는 경우, 높아지는 경우를 각각 처리했다.</li><li>cnt에 같은 높이로 이어지는 블록의 수를 기록하여 경사로의 길이와 비교 후 경사로를 놓을 수 있는지 판별하였다.<ul><li>이 때, 내려가는 경사로인 경우에는 높이가 낮아진 이후 같은 높이의 블록 수를 계산해야 하므로 check_d라는 변수에 내려가는 경사로를 거친 상태라면 true로 두어 판별하였다.</li></ul></li><li>경사로의 길이가 1로 입력된 경우 예외가 많아서 처리하기 힘들었다.</li><li>1인 경우의 예외는 코드에 주석으로 설명을 해두었다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> check_row[MAX];</span><br><span class="line"><span class="keyword">bool</span> check_col[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 평지의 수</span></span><br><span class="line">check_row[i] = <span class="literal">true</span>; <span class="comment">// 초기값 true (지나갈 수 있는 상태)</span></span><br><span class="line"><span class="keyword">bool</span> check_d = <span class="literal">false</span>; <span class="comment">// 내려가는 경사로를 거친 상태라면 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[i][j + <span class="number">1</span>] - a[i][j];</span><br><span class="line"><span class="keyword">if</span> (gap &gt; <span class="number">1</span> || gap &lt; <span class="number">-1</span>) <span class="comment">// 높이차가 2 이상이면 불가능한 경우</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gap == <span class="number">0</span>) <span class="comment">// 같은 높이인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++; <span class="comment">// 같은 높이의 개수</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt;= l) <span class="comment">// 내려가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line">&#123;  <span class="comment">// 경사로의 길이가 1인 경우는 예외</span></span><br><span class="line">check_d = <span class="literal">false</span>; <span class="comment">// 평지로 인식</span></span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">1</span>) <span class="comment">// 높이가 높아진 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 경사로가 내려가다가 바로 올라가는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt == <span class="number">1</span>)</span><br><span class="line">&#123;  <span class="comment">// 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능</span></span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">// l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt; <span class="number">1</span>) check_d = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; l) <span class="comment">// 올라가는 경사로를 놓을 수 없는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">1</span>; <span class="comment">// 높이가 바뀌었으므로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">-1</span>) <span class="comment">// 높이가 낮아졌다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 연속으로 내려가는 경사로를 두 번 놓을 수 없음</span></span><br><span class="line">&#123; <span class="comment">// 1은 예외</span></span><br><span class="line">check_row[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">check_d = <span class="literal">true</span>; <span class="comment">// 다음 높이에서 경사로의 길이를 체크</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; j == n - <span class="number">2</span> &amp;&amp; check_d) check_row[i] = <span class="literal">false</span>; <span class="comment">// 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 평지의 수</span></span><br><span class="line">check_col[j] = <span class="literal">true</span>; <span class="comment">// 초기값 true (지나갈 수 있는 상태)</span></span><br><span class="line"><span class="keyword">bool</span> check_d = <span class="literal">false</span>; <span class="comment">// 내려가는 경사로를 거친 상태라면 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[i + <span class="number">1</span>][j] - a[i][j];</span><br><span class="line"><span class="keyword">if</span> (gap &gt; <span class="number">1</span> || gap &lt; <span class="number">-1</span>) <span class="comment">// 높이차가 2 이상이면 불가능한 경우</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (gap == <span class="number">0</span>) <span class="comment">// 같은 높이인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">cnt++; <span class="comment">// 같은 높이의 개수</span></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt;= l)  <span class="comment">// 내려가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line">&#123; <span class="comment">// 경사로의 길이가 1인 경우는 예외</span></span><br><span class="line">check_d = <span class="literal">false</span>; <span class="comment">// 다시 평지로 인식</span></span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">1</span>) <span class="comment">// 높이가 높아진 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d)  <span class="comment">// 경사로가 내려가다가 바로 올라가는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt == <span class="number">1</span>)</span><br><span class="line">&#123; <span class="comment">// 경사로의 길이가 1일 때, 내려가다가 바로 올라오는 경우 불가능</span></span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">//l = 1일 때, 내려가는 경사로를 놓고 다시 올라가는 경사로를 놓을 수 있는 경우</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (l == <span class="number">1</span> &amp;&amp; check_d &amp;&amp; cnt &gt; <span class="number">1</span>) check_d = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; l) <span class="comment">// 올라가는 경사로를 놓을 수 없는 경우 불가능</span></span><br><span class="line">&#123;</span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">1</span>; <span class="comment">// 높이가 바뀌었으므로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (gap == <span class="number">-1</span>) <span class="comment">// 높이가 낮아졌다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; check_d) <span class="comment">// 연속으로 내려가는 경사로를 두 번 놓을 수 없음</span></span><br><span class="line">&#123; <span class="comment">// 1은 예외</span></span><br><span class="line">check_col[j] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">check_d = <span class="literal">true</span>; <span class="comment">// 다음 높이에서 경사로의 길이를 체크</span></span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l != <span class="number">1</span> &amp;&amp; i == n - <span class="number">2</span> &amp;&amp; check_d) check_col[j] = <span class="literal">false</span>; <span class="comment">// 마지막 지점에서 내려갈 때 경사로를 만들지 못하는 경우</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 각 행, 열 별로 지나갈 수 있는 길의 수 체크</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check_row[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "row : " &lt;&lt; i &lt;&lt; '\n'; // 디버깅용</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check_col[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "col : " &lt;&lt; i &lt;&lt; '\n'; // 디버깅용</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14890&quot;&gt;&lt;a href=&quot;#Problem-14890&quot; class=&quot;headerlink&quot; title=&quot;Problem 14890&quot;&gt;&lt;/a&gt;Problem 14890&lt;/h1&gt;&lt;h2 id=&quot;경사로&quot;&gt;&lt;a href=&quot;#경사로&quot; c
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 15683번 감시</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/25/algorithm15683/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/25/algorithm15683/</id>
    <published>2020-03-24T17:10:12.000Z</published>
    <updated>2020-03-24T17:18:00.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-15683"><a href="#Problem-15683" class="headerlink" title="Problem 15683"></a>Problem 15683</h1><h2 id="감시"><a href="#감시" class="headerlink" title="감시"></a>감시</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.</p><p>1번    2번    3번    4번    5번<br>1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.</p><p>CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.</p><p>CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 ‘#’로 나타내면 아래와 같다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> # <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"># # <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>→    ←    ↑    ↓<br>CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 벽을 감시할 수 없다.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 # # # #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="comment"># # 2 #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># # # # # 5</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 # # # #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment"># #</span></span><br><span class="line"><span class="comment"># # # # # 5</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> # # <span class="number">2</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"># # # # # <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> #</span><br><span class="line"><span class="number">0</span> # <span class="number">0</span> <span class="number">0</span> <span class="number">6</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> #</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> # #</span><br><span class="line"># # # # # <span class="number">5</span></span><br></pre></td></tr></table></figure><p>왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔    왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕    왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔    왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕<br>CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">6</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">6</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 2 # 3</span></span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="comment"># 0 #</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">6</span> <span class="number">6</span> <span class="comment">#</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure><p>사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.</p><p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)</p><p>둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.</p><p>CCTV의 최대 개수는 8개를 넘지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 사각 지대의 최소 크기를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/15683" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/15683</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 6<br>0 0 0 0 0 0<br>0 0 0 0 0 0<br>0 0 1 0 6 0<br>0 0 0 0 0 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>20</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>6 6<br>0 0 0 0 0 0<br>0 2 0 0 0 0<br>0 0 0 0 6 0<br>0 6 0 0 2 0<br>0 0 0 0 0 0<br>0 0 0 0 0 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>15</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>6 6<br>1 0 0 0 0 0<br>0 1 0 0 0 0<br>0 0 1 0 0 0<br>0 0 0 1 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>6</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6 6<br>1 0 0 0 0 0<br>0 1 0 0 0 0<br>0 0 1 5 0 0<br>0 0 5 1 0 0<br>0 0 0 0 1 0<br>0 0 0 0 0 1</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>2</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>1 7<br>0 1 2 3 4 5 6</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>0</p><h3 id="예제-입력-6"><a href="#예제-입력-6" class="headerlink" title="예제 입력 6"></a>예제 입력 6</h3><p>3 7<br>4 0 0 0 0 0 0<br>0 0 0 2 0 0 0<br>0 0 0 0 0 0 4</p><h3 id="예제-출력-6"><a href="#예제-출력-6" class="headerlink" title="예제 출력 6"></a>예제 출력 6</h3><p>0</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>부르트 포스 문제로 모든 경우를 다 확인해 최솟값을 구하면 된다.</li><li>나는 see라는 함수를 만들어서 현재 좌표에서 현재 방향으로 감시가능한 구역 체크하도록 했다.<ul><li>인자로 좌표, 방향, flag, num 을 받는다.</li><li>flag는 1인 경우 감시 구역을 체크하고 아니라면 체크된 감시 구역을 해제한다.</li><li>여기서 감시구역을 num으로 체크하는데, num은 7부터 감시카메라의 개수만큼 증가한다.</li><li>이렇게 num을 준 이유는 1~6번은 사용중이고, 다른 감시카메라와의 중복 감시구역을 파악하기 위해서다.</li><li>flag가 1이 아니라면, 현재 방향의 num으로 체크된 구역만 0으로 바꾸어 체크를 해제한다.</li></ul></li><li>이후 재귀함수로 입력받은 감시카메라의 개수만큼, 각 감시카메라의 종류가 볼 수 있는 방향을 모두 체크한다.</li><li>모든 감시카메라 확인 후 0인 구역의 개수가 사각지대의 개수이다. 이것의 최솟값을 구한다.</li></ul><hr><ul><li>3번 감시카메라를 착각해서 감시 방향을 3번만 확인하면 된다고 생각하여 이것을 찾아내는데 시간을 많이 썻다.</li><li>3번 감시카메라도 네 방향을 모두 보아야 한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">see</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dir, <span class="keyword">int</span> flag, <span class="keyword">int</span> num)</span> <span class="comment">// 현재 좌표에서 현재 방향으로 감시가능한 구역 체크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="comment">// 감시 구역 체크</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">max</span>(n, m); i++) <span class="comment">// 현재 방향으로 벽이 아닌 모든 구역 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir] * i;</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir] * i;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) a[nx][ny] = num; <span class="comment">// 0인 경우 인자로 받은 num으로 넣어서 구분</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 감시 구역 해제</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">max</span>(n, m); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir] * i;</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir] * i;</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">6</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(a[nx][ny] == num) a[nx][ny] = <span class="number">0</span>; <span class="comment">// num 체크 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">// 확인용 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="built_in">size</span>) <span class="comment">// 모든 감시카메라 확인 후</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">0</span>)</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt &lt; ans) ans = cnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = v[index].first.first;</span><br><span class="line"><span class="keyword">int</span> y = v[index].first.second;</span><br><span class="line"><span class="keyword">int</span> type = v[index].second;</span><br><span class="line"><span class="keyword">int</span> num = index + <span class="number">7</span>; <span class="comment">// 1~6은 사용중</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>) <span class="comment">// 1번 경우 네 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 감시구역 체크</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num); <span class="comment">// 체크 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">// 2번 경우 양 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 현재 방향 체크</span></span><br><span class="line">see(x, y, k + <span class="number">2</span>, <span class="number">1</span>, num); <span class="comment">// 한칸 건너 뛰고 반대방향 체크</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">see(x, y, k + <span class="number">2</span>, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">3</span>) <span class="comment">// 3번 경우 직각 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num); <span class="comment">// 현재 방향 체크</span></span><br><span class="line">see(x, y, k + <span class="number">1</span> &gt; <span class="number">3</span> ? <span class="number">0</span> : k + <span class="number">1</span>, <span class="number">1</span>, num); <span class="comment">// 현재 방향과 직각을 이루는 방향 확인</span></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">see(x, y, k + <span class="number">1</span> &gt; <span class="number">3</span> ? <span class="number">0</span> : k + <span class="number">1</span>, <span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">4</span>) <span class="comment">// 4번 경우 세 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l == k) <span class="keyword">continue</span>; <span class="comment">// 현재 방향 빼고 나머지 세 방향 확인</span></span><br><span class="line">see(x, y, l, <span class="number">1</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">4</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l == k) <span class="keyword">continue</span>;</span><br><span class="line">see(x, y, l, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">5</span>) <span class="comment">// 5번 경우 전 방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">see(x, y, k, <span class="number">1</span>, num);</span><br><span class="line"></span><br><span class="line">go(index + <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">see(x, y, k, <span class="number">0</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] &gt;= <span class="number">1</span> &amp;&amp; a[i][j] &lt;= <span class="number">5</span>)</span><br><span class="line">&#123; <span class="comment">// 감시카메라의 위치 , 종류 저장</span></span><br><span class="line">v.push_back(make_pair(make_pair(i, j), a[i][j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>, v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-15683&quot;&gt;&lt;a href=&quot;#Problem-15683&quot; class=&quot;headerlink&quot; title=&quot;Problem 15683&quot;&gt;&lt;/a&gt;Problem 15683&lt;/h1&gt;&lt;h2 id=&quot;감시&quot;&gt;&lt;a href=&quot;#감시&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14500번 테트로미노</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/24/algorithm14500/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/24/algorithm14500/</id>
    <published>2020-03-23T15:12:12.000Z</published>
    <updated>2020-03-25T05:34:58.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14500"><a href="#Problem-14500" class="headerlink" title="Problem 14500"></a>Problem 14500</h1><h2 id="테트로미노"><a href="#테트로미노" class="headerlink" title="테트로미노"></a>테트로미노</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.</p><p>정사각형은 서로 겹치면 안 된다.<br>도형은 모두 연결되어 있어야 한다.<br>정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.<br>정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.</p><p>아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.</p><p>테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.</p><p>테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)</p><p>둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14500" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14500</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>5 5<br>1 2 3 4 5<br>5 4 3 2 1<br>2 3 4 5 6<br>6 5 4 3 2<br>1 2 1 2 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>19</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>4 5<br>1 2 3 4 5<br>1 2 3 4 5<br>1 2 3 4 5<br>1 2 3 4 5</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>20</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4 10<br>1 2 1 2 1 2 1 2 1 2<br>2 1 2 1 2 1 2 1 2 1<br>1 2 1 2 1 2 1 2 1 2<br>2 1 2 1 2 1 2 1 2 1</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>7</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>5가지의 경우 중 ㅜ 모양을 제외한 4가지 경우는 한 점에서 시작하여 3개의 칸을 연속해서 방문하는 형태이므로 dfs를 통해 구할 수 있다.<ul><li>dfs를 사용하여 네 칸을 연속해서 방문하는 경우 네 칸의 최댓값을 구한다.</li></ul></li><li>나머지 ㅜ 모양은 3개의 칸을 연속해서 방문하지 않으므로 경우 dfs로는 구할 수 없다.<ul><li>따라서 반복문에 직접 구현하였다.</li><li>ㅗ, ㅜ 모양인 경우 j + 2 &lt; m 일 때를 기준으로 처리하였고,</li><li>ㅓ, ㅏ 모양인 경우 i + 2 &lt; n 일 때를 기준으로 처리하였다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> check[MAX + <span class="number">1</span>][MAX + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> <span class="comment">// 한 점에서 시작하여 3개의 칸을 연속해서 확인하는 경우 모두 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">check[x][y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; ans) ans = sum; <span class="comment">// 네 칸의 합의 최댓값</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[nx][ny] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, sum + a[x][y], index + <span class="number">1</span>);</span><br><span class="line">check[nx][ny] = <span class="literal">false</span>; <span class="comment">// 방문 처리 해제</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">check[x][y] = <span class="literal">false</span>; <span class="comment">// 시작점 방문 처리 해제</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i, j, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// dfs로 구할 수 없는 한 가지 경우 처리</span></span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">2</span> &lt; m) <span class="comment">//  ㅗ, ㅜ 모양 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = a[i][j] + a[i][j + <span class="number">1</span>] + a[i][j + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">2</span> &lt; n) <span class="comment">// ㅓ, ㅏ 모양 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp1 = a[i][j] + a[i + <span class="number">1</span>][j] + a[i + <span class="number">2</span>][j];</span><br><span class="line"><span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp1 + a[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (ans &lt; tmp2) ans = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14500&quot;&gt;&lt;a href=&quot;#Problem-14500&quot; class=&quot;headerlink&quot; title=&quot;Problem 14500&quot;&gt;&lt;/a&gt;Problem 14500&lt;/h1&gt;&lt;h2 id=&quot;테트로미노&quot;&gt;&lt;a href=&quot;#테트로미
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16234번 인구 이동</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/23/algorithm16234/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/23/algorithm16234/</id>
    <published>2020-03-22T17:31:12.000Z</published>
    <updated>2020-03-22T17:38:39.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16234"><a href="#Problem-16234" class="headerlink" title="Problem 16234"></a>Problem 16234</h1><h2 id="인구-이동"><a href="#인구-이동" class="headerlink" title="인구 이동"></a>인구 이동</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.</p><p>오늘부터 인구 이동이 시작되는 날이다.</p><p>인구 이동은 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.</p><ul><li>국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루동안 연다.</li><li>위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.</li><li>국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.</li><li>연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.</li><li>연합을 해체하고, 모든 국경선을 닫는다.<br>각 나라의 인구수가 주어졌을 때, 인구 이동이 몇 번 발생하는지 구하는 프로그램을 작성하시오.</li></ul><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)</p><p>둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)</p><p>인구 이동이 발생하는 횟수가 2,000번 보다 작거나 같은 입력만 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>인구 이동이 몇 번 발생하는지 첫째 줄에 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16234" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16234</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>2 20 50<br>50 30<br>20 40</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>2 40 50<br>50 30<br>20 40</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>0</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>2 20 50<br>50 30<br>30 40</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>1</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>3 5 10<br>10 15 20<br>20 30 25<br>40 22 10</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>2</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>4 10 50<br>10 100 20 90<br>80 100 60 70<br>70 20 30 40<br>50 20 100 10</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>dfs를 통해 현재 국경을 공유하는 나라를 하나의 그룹으로 연합의 그룹번호를 매긴다.</li><li>이후 각 그룹에 속하는 나라의 수를 cnt에 카운트하고, 각 그룹의 속하는 나라의 인구수의 합을 sum에 저장한다.</li><li>또한 벡터v에 같은 그룹에 해당하는 나라끼리 좌표를 저장한다.</li><li>cnt[k]가 2이상이라면 k그룹에 속한 나라끼리 국경을 공유했다는 뜻이 된다.<ul><li>따라서, cnt[k]가 2이상인 경우 v[k]에 저장된 각 나라의 좌표에 접근하여 (sum[k] / cnt[k])를 통해 인구 이동을 계산한다.</li><li>이때, 계산 후에 벡터를 초기화한다.</li></ul></li><li>반복문이 1회 반복될 때마다 인구 이동 횟수를 카운트한다.</li><li>국경을 공유하는 나라가 더 이상 없다면 반복문을 빠져나가고 종료한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> group[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[MAX + <span class="number">1</span>]; <span class="comment">// 각 그룹에 속하는 나라의 수</span></span><br><span class="line"><span class="keyword">int</span> sum[MAX + <span class="number">1</span>]; <span class="comment">// 각 그룹의 속하는 나라의 인구수의 합</span></span><br><span class="line"><span class="keyword">int</span> n, l, r;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> , <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v[MAX + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> <span class="comment">// dfs를 통해 연합의 그룹번호를 매긴다.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (group[x][y] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">group[x][y] = num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> gap = a[x][y] - a[nx][ny];</span><br><span class="line"><span class="keyword">if</span> (gap &lt; <span class="number">0</span>) gap = -gap;</span><br><span class="line"><span class="keyword">if</span> (gap &gt;= l &amp;&amp; gap &lt;= r) <span class="comment">//  나라의 인구 차이가 L명 이상, R명 이하라면</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(nx, ny, num); <span class="comment">// 같은 그룹으로 묶는다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(group, <span class="number">0</span>, <span class="keyword">sizeof</span>(group)); <span class="comment">// 그룹 번호 초기화</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (group[i][j] == <span class="number">0</span>) <span class="comment">// 그룹에 속하지 않는 나라인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">dfs(i, j, ++num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt)); <span class="comment">// 각 그룹에 속하는 나라의 수 초기화</span></span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum)); <span class="comment">// 각 그룹의 속하는 나라의 인구수의 합 초기화</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cnt[group[i][j]]++;</span><br><span class="line">sum[group[i][j]] += a[i][j];</span><br><span class="line">v[group[i][j]].push_back(make_pair(i, j)); <span class="comment">// 같은 그룹에 해당하는 나라의 좌표를 저장</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> check = <span class="literal">true</span>; <span class="comment">// 국경선을 공유하는 나라가 있는지 판별</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= MAX; k++) <span class="comment">// 경우는 1부터 10000까지</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt[k] &gt;= <span class="number">2</span>) <span class="comment">// 그룹에 속한 나라의 수가 2이상이면 국경을 공유한 것.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[k].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = v[k][i].first;</span><br><span class="line"><span class="keyword">int</span> y = v[k][i].second;</span><br><span class="line"></span><br><span class="line">a[x][y] = sum[k] / cnt[k]; <span class="comment">// 인구 이동 계산</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">check = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">v[k].<span class="built_in">clear</span>(); <span class="comment">// 벡터 초기화</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (check) <span class="keyword">break</span>; <span class="comment">// 국경을 공유하는 나라가 없다면 종료</span></span><br><span class="line">ans++; <span class="comment">// 인구 이동 횟수 카운트</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16234&quot;&gt;&lt;a href=&quot;#Problem-16234&quot; class=&quot;headerlink&quot; title=&quot;Problem 16234&quot;&gt;&lt;/a&gt;Problem 16234&lt;/h1&gt;&lt;h2 id=&quot;인구-이동&quot;&gt;&lt;a href=&quot;#인구-이
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14503번 로봇 청소기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/21/algorithm14503/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/21/algorithm14503/</id>
    <published>2020-03-20T17:05:12.000Z</published>
    <updated>2020-03-20T17:08:33.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14503"><a href="#Problem-14503" class="headerlink" title="Problem 14503"></a>Problem 14503</h1><h2 id="로봇-청소기"><a href="#로봇-청소기" class="headerlink" title="로봇 청소기"></a>로봇 청소기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.</p><p>로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.</p><p>로봇 청소기는 다음과 같이 작동한다.</p><ol><li>현재 위치를 청소한다.</li><li>현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.<ol><li>왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.</li><li>왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.</li><li>네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.</li><li>네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.</li></ol></li></ol><p>로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)</p><p>둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.</p><p>셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.</p><p>로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>로봇 청소기가 청소하는 칸의 개수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14503" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14503</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3 3<br>1 1 0<br>1 1 1<br>1 0 1<br>1 1 1</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>11 10<br>7 4 0<br>1 1 1 1 1 1 1 1 1 1<br>1 0 0 0 0 0 0 0 0 1<br>1 0 0 0 1 1 1 1 0 1<br>1 0 0 1 1 0 0 0 0 1<br>1 0 1 1 0 0 0 0 0 1<br>1 0 0 0 0 0 0 0 0 1<br>1 0 0 0 0 0 0 1 0 1<br>1 0 0 0 0 0 1 1 0 1<br>1 0 0 0 0 0 1 1 0 1<br>1 0 0 0 0 0 0 0 0 1<br>1 1 1 1 1 1 1 1 1 1</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>57</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>재귀 함수를 통해 문제의 조건을 그대로 구현해야 한다.</li><li>청소를 완료한 구역은 2를 저장하여 구분하였고, 0, 1, 2, 3이 북, 서, 남, 동이므로 dx, dy에 순서를 맞춰주었다.</li><li>먼저 청소하지 않은 구역이면 청소를 하고 방의 개수를 카운트한다.</li><li>calc_dir이라는 0, 1, 2, 3 다음 다시 0이 되도록 계산을 해주는 함수를 구현하여<ul><li>왼쪽부터 4방향을 확인하는데, 왼쪽으로 회전하는 것은 현재 방향에서 -1을 해주면 된다.</li><li>바라보는 방향의 방이 청소가 안된 빈칸이라면 재귀를 수행하여 다음 칸으로 이동하고, 이후 나머지 방향은 추가로 검사하지 않는다.</li></ul></li><li>위의 과정이 끝나 네 방향 모두 청소가 되었거나 벽이라면<ul><li>현재 방향에서 -2를 해주어 후진 방향을 설정하고 후진할 방향이 벽이라면 정답을 출력 후 종료,</li><li>벽이 아니라면 후진을 한다. 이 때, 원래의 방향을 유지하며 후진을 수행한다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;; <span class="comment">// 0  : 북, 1 : 서, 2 : 남, 3 : 동</span></span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc_dir</span><span class="params">(<span class="keyword">int</span> dir, <span class="keyword">int</span> rotation)</span> <span class="comment">// 청소기의 회전</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = dir + rotation;</span><br><span class="line"><span class="keyword">if</span> (res &gt; <span class="number">3</span>) res -= <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span>(res &lt; <span class="number">0</span>) res += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>) <span class="comment">// 청소하지 않았다면</span></span><br><span class="line">&#123;</span><br><span class="line">a[x][y] = <span class="number">2</span>; <span class="comment">// 청소</span></span><br><span class="line">ans++; <span class="comment">// 카운트</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span> (cnt--) <span class="comment">// 4방향 확인</span></span><br><span class="line">&#123;</span><br><span class="line">dir = calc_dir(dir, <span class="number">-1</span>); <span class="comment">// 왼쪽으로 회전</span></span><br><span class="line"><span class="keyword">int</span> nx = x + dx[dir];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[dir];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) <span class="comment">// 빈칸이라면 청소</span></span><br><span class="line">&#123;</span><br><span class="line">go(nx, ny, dir);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 다음 칸으로 넘어간 이후 나머지 방향은 검사 x</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">// 검사 끝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네 방향 모두 청소가 이미 되어있거나 벽인 경우</span></span><br><span class="line"><span class="keyword">int</span> rear = calc_dir(dir, <span class="number">-2</span>); <span class="comment">// 후진 방향 설정</span></span><br><span class="line"><span class="keyword">int</span> nx = x + dx[rear];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[rear];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">1</span>) <span class="comment">// 후진도 못한다면</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 출력 후 종료</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 후진한다</span></span><br><span class="line">&#123;</span><br><span class="line">go(nx, ny, dir); <span class="comment">// 방향은 유지</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sx, sy, dir;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; dir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">go(sx, sy, dir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14503&quot;&gt;&lt;a href=&quot;#Problem-14503&quot; class=&quot;headerlink&quot; title=&quot;Problem 14503&quot;&gt;&lt;/a&gt;Problem 14503&lt;/h1&gt;&lt;h2 id=&quot;로봇-청소기&quot;&gt;&lt;a href=&quot;#로봇-
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2580번 스도쿠</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/19/algorithm2580/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/19/algorithm2580/</id>
    <published>2020-03-19T01:30:12.000Z</published>
    <updated>2020-03-19T01:39:02.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2580"><a href="#Problem-2580" class="headerlink" title="Problem 2580"></a>Problem 2580</h1><h2 id="스도쿠"><a href="#스도쿠" class="headerlink" title="스도쿠"></a>스도쿠</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 몇 몇 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.</p><p>0 3 5 4 6 9 2 7 8<br>7 8 2 1 0 5 6 0 9<br>0 6 0 2 7 8 1 3 5<br>3 2 1 0 4 6 8 9 7<br>8 0 4 9 1 3 5 0 6<br>5 9 6 8 2 0 4 1 3<br>9 1 7 6 5 2 0 8 0<br>6 0 3 7 0 1 9 5 2<br>2 5 8 3 9 4 7 6 0</p><p>나머지 빈 칸을 채우는 방식은 다음과 같다.</p><ol><li>각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li><li>굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.</li></ol><p>위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.</p><p><strong>1</strong> 3 5 4 6 9 2 7 8</p><p>또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.</p><p>4 6 9<br>1 <strong>3</strong> 5<br>2 7 8</p><p>이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.</p><p>1 3 5 4 6 9 2 7 8<br>7 8 2 1 3 5 6 4 9<br>4 6 9 2 7 8 1 3 5<br>3 2 1 5 4 6 8 9 7<br>8 7 4 9 1 3 5 2 6<br>5 9 6 8 2 7 4 1 3<br>9 1 7 6 5 2 3 8 4<br>6 4 3 7 8 1 9 5 2<br>2 5 8 3 9 4 7 6 1</p><p>게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.</p><p>스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2580" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2580</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>0 3 5 4 6 9 2 7 8<br>7 8 2 1 0 5 6 0 9<br>0 6 0 2 7 8 1 3 5<br>3 2 1 0 4 6 8 9 7<br>8 0 4 9 1 3 5 0 6<br>5 9 6 8 2 0 4 1 3<br>9 1 7 6 5 2 0 8 0<br>6 0 3 7 0 1 9 5 2<br>2 5 8 3 9 4 7 6 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>1 3 5 4 6 9 2 7 8<br>7 8 2 1 3 5 6 4 9<br>4 6 9 2 7 8 1 3 5<br>3 2 1 5 4 6 8 9 7<br>8 7 4 9 1 3 5 2 6<br>5 9 6 8 2 7 4 1 3<br>9 1 7 6 5 2 3 8 4<br>6 4 3 7 8 1 9 5 2<br>2 5 8 3 9 4 7 6 1</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>각각의 동일한 행, 열, 3 * 3 사각형에 중복되는 수가 들어가지 않도록 하여 백트래킹을 하면 된다.</li><li>입력을 받으며 각 행에 존재하는 수를 check배열에 행과 열을 구분하여 체크한다.<ul><li>이 때, 사각형에 존재하는 수를 체크하는 방법은 3x3 사각형을 순서대로 0 ~ 8번이라고 정의하고</li><li>현재 행, 열에 대해 (행 / 3) * 3 + (열 / 3)을 수행하면 현재 몇 번째 사각형인지 얻을 수 있다.</li></ul></li><li>이제 재귀 함수를 통해 백트래킹을 구현한다.</li><li>9행 9열을 0 ~ 80까지로 표현하여 현재 행은 (행 / 9), 현재 열은 (열 % 9)로 구할 수 있다.</li><li>현재 입력 배열의 수가 0인 경우(빈칸) 같은 행, 열, 사각형에 없는 수만 선택하여 수를 채우고 재귀를 수행한다.</li><li>index가 81이 되었다면 답을 구한 것이므로 출력 후 프로그램을 종료한다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">bool</span> check_row[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check_col[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check_square[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x / <span class="number">3</span>) * <span class="number">3</span> + (y / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">81</span>) <span class="comment">// 답을 구했으면 출력 후 프로그램 종료</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = index / <span class="number">9</span>; <span class="comment">// 0 ~ 80 을 행, 열로 변환</span></span><br><span class="line"><span class="keyword">int</span> y = index % <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (a[x][y] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!check_row[x][i] &amp;&amp; !check_col[i][y] &amp;&amp; !check_square[square(x, y)][i]) <span class="comment">// 같은 행, 열, 사각형에 없는 수만 확인</span></span><br><span class="line">&#123;</span><br><span class="line">check_row[x][i] = check_col[i][y] = check_square[square(x, y)][i] = <span class="literal">true</span>; <span class="comment">// 수를 넣었으므로 체크</span></span><br><span class="line">a[x][y] = i;</span><br><span class="line">go(index + <span class="number">1</span>); <span class="comment">// 수를 넣고 넘어감</span></span><br><span class="line">a[x][y] = <span class="number">0</span>; <span class="comment">// 확인 후 초기화</span></span><br><span class="line">check_row[x][i] = check_col[i][y] = check_square[square(x, y)][i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">go(index + <span class="number">1</span>); <span class="comment">// 0이 아니라면 계속 진행</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">check_row[i][a[i][j]] = <span class="literal">true</span>; <span class="comment">// i번째 행에 존재하는 수 체크</span></span><br><span class="line">check_col[a[i][j]][j] = <span class="literal">true</span>; <span class="comment">// j번째 열에 존재하는 수 체크</span></span><br><span class="line">check_square[square(i, j)][a[i][j]] = <span class="literal">true</span>; <span class="comment">// n번째 사각형에 존재하는 수 체크</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2580&quot;&gt;&lt;a href=&quot;#Problem-2580&quot; class=&quot;headerlink&quot; title=&quot;Problem 2580&quot;&gt;&lt;/a&gt;Problem 2580&lt;/h1&gt;&lt;h2 id=&quot;스도쿠&quot;&gt;&lt;a href=&quot;#스도쿠&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 1201번 NMK</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/18/algorithm1201/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/18/algorithm1201/</id>
    <published>2020-03-18T05:01:12.000Z</published>
    <updated>2020-03-18T05:07:08.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-1201"><a href="#Problem-1201" class="headerlink" title="Problem 1201"></a>Problem 1201</h1><h2 id="NMK"><a href="#NMK" class="headerlink" title="NMK"></a>NMK</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>1부터 N까지의 수를 한 번씩 이용해서 최대 부분 증가 수열의 길이가 M이고, 최대 부분 감소 수열의 길이가 K인 수열을 출력한다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N M K가 주어진다. N은 500보다 작거나 같은 자연수, M과 K는 N보다 작거나 같은 자연수이다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 문제의 정답을 출력한다. 정답이 없다면-1을 출력한다</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/1201" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1201</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>2 1 4 3</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li><p>적어도 m개는 증가수열에 포함되어야 하고 적어도 k개는 감소수열에 포함되어야 한다. 두 수열은 최대 1개의 정수를 공유 가능</p><ul><li>[ex) m = 3, k = 2 -&gt; 1 2 4 3 과 같이 3개가 증가하고 이어서 4를 공유하여 2개가 감소하는 경우 최소 길이]</li><li>따라서 n &gt;= m + k -1 를 만족해야 한다.</li></ul></li><li><p>예를 들어, 1 2 3 4 5 6 7 8 9를 4개씩 묶는다고 생각해보자.</p><ul><li>(1 2 3 4)(5 6 7 8)(9) 와 같이 묶고, 각 구간을 뒤집는다.</li><li>(4 3 2 1)(8 7 6 5)(9) 가 될 것이다. 이 경우, 각 구간 내에서는 증가하는 부분이 없으므로 구간의 개수가 증가하는 최대 부분수열의 개수가 된다. 또한 구간의 최대 길이가 감소한는 부분 수열의 최대 길이가 될 것이다.</li></ul></li><li><p>감소하는 부분 수열의 길이를 k가 되도록 하기 위해 오름차순으로 정렬된 k개의 수에 대해 앞에서부터 한번은 최대 k개가 되도록 묶어 뒤집어 준다.</p></li><li><p>또한 m개의 증가 수열을 만들어 주기 위해 뒤집힌 묶음의 개수가 m개가 되어야 한다.</p></li><li><p>즉, m개의 구간을 묶을 때, 적어도 한 번은 k개가 되도록 수를 묶어 모든 구간을 뒤집어 주면 정답을 구할 수 있다.</p></li><li><p>이때, n이 m * k보다 커지게 된다면, m개의 구간을 k개씩 묶고 나서도 1개 이상의 수가 남기 때문에 이 경우 정답을 구할 수 없다.</p></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n &lt; m + k - <span class="number">1</span> || n &gt; m * k) <span class="comment">// 불가능한 범위 처리</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">a[i] = i + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 구간을 나눌 지점을 저장할 벡터</span></span><br><span class="line">s.push_back(<span class="number">0</span>); <span class="comment">// 첫 구간의 시작</span></span><br><span class="line">s.push_back(k); <span class="comment">// 첫 구간의 끝</span></span><br><span class="line">n -= k; <span class="comment">// 남은 수의 개수</span></span><br><span class="line">m--; <span class="comment">// 남은 구간 수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q = m == <span class="number">0</span> ? <span class="number">1</span> : n / m; <span class="comment">// 남은 구간이 없다면 1</span></span><br><span class="line"><span class="keyword">int</span> r = m == <span class="number">0</span> ? <span class="number">0</span> : n % m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 남은 구간 수 만큼</span></span><br><span class="line">&#123; <span class="comment">// r(나머지)가 0이 될때까지 각 구간에 1씩 추가한다.</span></span><br><span class="line">s.push_back(s.back() + q + (r &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));  <span class="comment">// 마지막 원소에 나눌 구간 크기만큼 더하여 추가</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0</span>) r--; <span class="comment">// 나머지 감소</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">reverse(a.<span class="built_in">begin</span>() + s[i], a.<span class="built_in">begin</span>() + s[i + <span class="number">1</span>]); <span class="comment">// s에 저장된 구간으로 나누어 뒤집음</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-1201&quot;&gt;&lt;a href=&quot;#Problem-1201&quot; class=&quot;headerlink&quot; title=&quot;Problem 1201&quot;&gt;&lt;/a&gt;Problem 1201&lt;/h1&gt;&lt;h2 id=&quot;NMK&quot;&gt;&lt;a href=&quot;#NMK&quot; class
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 14499번 주사위 굴리기</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/17/algorithm14499/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/17/algorithm14499/</id>
    <published>2020-03-17T14:40:12.000Z</published>
    <updated>2020-03-17T14:41:23.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-14499"><a href="#Problem-14499" class="headerlink" title="Problem 14499"></a>Problem 14499</h1><h2 id="주사위-굴리기"><a href="#주사위-굴리기" class="headerlink" title="주사위 굴리기"></a>주사위 굴리기</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line">  <span class="number">5</span></span><br><span class="line">  <span class="number">6</span></span><br></pre></td></tr></table></figure><p>주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.</p><p>지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.</p><p>주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.</p><p>주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.</p><p>둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10을 넘지 않는 자연수 또는 0이다.</p><p>마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>이동할 때마다 주사위의 윗 면에 쓰여 있는 수를 출력한다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/14499" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/14499</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>4 2 0 0 8<br>0 2<br>3 4<br>5 6<br>7 8<br>4 4 4 1 3 3 3 2</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0<br>0<br>3<br>0<br>0<br>8<br>6<br>3</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3 3 1 1 9<br>1 2 3<br>4 0 5<br>6 7 8<br>1 3 2 2 4 4 1 1 3</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>0<br>0<br>0<br>3<br>0<br>1<br>0<br>6<br>0</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>2 2 0 0 16<br>0 2<br>3 4<br>4 4 4 4 1 1 1 1 3 3 3 3 2 2 2 2</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>0<br>0<br>0<br>0</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>3 3 0 0 16<br>0 1 2<br>3 4 5<br>6 7 8<br>4 4 1 1 3 3 2 2 4 4 1 1 3 3 2 2</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>0<br>0<br>0<br>6<br>0<br>8<br>0<br>2<br>0<br>8<br>0<br>2<br>0<br>8<br>0<br>2</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>각 주사위의 면의 변화를 기록하여 좌표의 값에 따른 동작을 잘 구현하면 된다.</li><li>벡터에 명령을 저장했고, 명령에 따른 주사위의 이동을 주사위의 각 면에 해당하는 변수를 만들어 구현하였다.</li><li>예를 들어, 명령 1을 받아 동쪽으로 이동하는 경우를 살펴보자.<ul><li>다음 좌표가 지도의 범위 내에 있는지 확인하여 지도의 범위가 아니라면 해당 명령을 무시하고 다음 명령을 수행한다.</li><li>지도의 범위라면 동쪽으로 이동하므로 바닥면은 동쪽을 보게 되고, 동쪽을 보던 면은 윗면, 윗면은 서쪽 면, 서쪽 면은 바닥면으로 이동하게 된다.</li><li>이 때, 지도의 칸이 0이라면 주사위의 바닥면을 복사하고, 아니라면 지도의 칸을 주사위의 바닥면으로 복사한다.</li><li>이후 x, y를 갱신하여 반복을 이어간다.</li></ul></li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> dice[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// 현재 x,y가 범위에 속하는지 확인</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; m)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cmd(k); <span class="comment">// 명령어 저장</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cmd[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주사위의 6면</span></span><br><span class="line"><span class="keyword">int</span> bottom = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> north = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> south = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> east = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> west = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx, ny;</span><br><span class="line"><span class="keyword">switch</span> (cmd[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 동쪽으로 이동하는 경우</span></span><br><span class="line">nx = x; <span class="comment">// 다음 좌표</span></span><br><span class="line">ny = y + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123; <span class="comment">// 주사위의 각 면 이동</span></span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = east;</span><br><span class="line">east = top;</span><br><span class="line">top = west;</span><br><span class="line">west = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>) <span class="comment">// 지도의 칸이 0인 경우</span></span><br><span class="line">a[nx][ny] = bottom; <span class="comment">// 주사위의 바닥면이 복사</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny]; <span class="comment">// 0이 아니면 주사위의 바닥면으로 복사</span></span><br><span class="line">a[nx][ny] = <span class="number">0</span>; <span class="comment">// 지도의 칸은 0으로 변경</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>; <span class="comment">// 범위를 벗어난 경우 해당 명령 무시</span></span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 서쪽으로 이동하는 경우</span></span><br><span class="line">nx = x;</span><br><span class="line">ny = y - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = west;</span><br><span class="line">west = top;</span><br><span class="line">top = east;</span><br><span class="line">east = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>)</span><br><span class="line">a[nx][ny] = bottom;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny];</span><br><span class="line">a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 북쪽으로 이동하는 경우</span></span><br><span class="line">nx = x - <span class="number">1</span>;</span><br><span class="line">ny = y;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = north;</span><br><span class="line">north = top;</span><br><span class="line">top = south;</span><br><span class="line">south = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>)</span><br><span class="line">a[nx][ny] = bottom;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny];</span><br><span class="line">a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// 남쪽으로 이동하는 경우</span></span><br><span class="line">nx = x + <span class="number">1</span>;</span><br><span class="line">ny = y;</span><br><span class="line"><span class="keyword">if</span> (check(nx, ny))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = bottom;</span><br><span class="line">bottom = south;</span><br><span class="line">south = top;</span><br><span class="line">top = north;</span><br><span class="line">north = temp;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span>)</span><br><span class="line">a[nx][ny] = bottom;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bottom = a[nx][ny];</span><br><span class="line">a[nx][ny] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">x = nx;</span><br><span class="line">y = ny;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; top &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 윗면 출력</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-14499&quot;&gt;&lt;a href=&quot;#Problem-14499&quot; class=&quot;headerlink&quot; title=&quot;Problem 14499&quot;&gt;&lt;/a&gt;Problem 14499&lt;/h1&gt;&lt;h2 id=&quot;주사위-굴리기&quot;&gt;&lt;a href=&quot;#주사
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 16236번 아기 상어</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/17/algorithm16236/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/17/algorithm16236/</id>
    <published>2020-03-17T04:51:12.000Z</published>
    <updated>2020-03-17T04:59:25.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-16236"><a href="#Problem-16236" class="headerlink" title="Problem 16236"></a>Problem 16236</h1><h2 id="아기-상어"><a href="#아기-상어" class="headerlink" title="아기 상어"></a>아기 상어</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.</p><p>아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다.</p><p>아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.</p><p>아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다.</p><ul><li>더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.</li><li>먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.</li><li>먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.<ul><li>거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.</li><li>거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.</li></ul></li></ul><p>아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.</p><p>아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.</p><p>공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.</p><p>둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.</p><ul><li>0: 빈 칸</li><li>1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기</li><li>9: 아기 상어의 위치</li></ul><p>아기 상어는 공간에 한 마리 있다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/16236" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/16236</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>3<br>0 0 0<br>0 0 0<br>0 9 0</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>0</p><h3 id="예제-입력-2"><a href="#예제-입력-2" class="headerlink" title="예제 입력 2"></a>예제 입력 2</h3><p>3<br>0 0 1<br>0 0 0<br>0 9 0</p><h3 id="예제-출력-2"><a href="#예제-출력-2" class="headerlink" title="예제 출력 2"></a>예제 출력 2</h3><p>3</p><h3 id="예제-입력-3"><a href="#예제-입력-3" class="headerlink" title="예제 입력 3"></a>예제 입력 3</h3><p>4<br>4 3 2 1<br>0 0 0 0<br>0 0 9 0<br>1 2 3 4</p><h3 id="예제-출력-3"><a href="#예제-출력-3" class="headerlink" title="예제 출력 3"></a>예제 출력 3</h3><p>12</p><h3 id="예제-입력-4"><a href="#예제-입력-4" class="headerlink" title="예제 입력 4"></a>예제 입력 4</h3><p>6<br>5 4 3 2 3 4<br>4 3 2 3 4 5<br>3 2 9 5 6 6<br>2 1 2 3 4 5<br>3 2 1 6 5 4<br>6 6 6 6 6 6</p><h3 id="예제-출력-4"><a href="#예제-출력-4" class="headerlink" title="예제 출력 4"></a>예제 출력 4</h3><p>60</p><h3 id="예제-입력-5"><a href="#예제-입력-5" class="headerlink" title="예제 입력 5"></a>예제 입력 5</h3><p>6<br>6 0 6 0 6 1<br>0 0 0 0 0 2<br>2 3 4 5 6 6<br>0 0 0 0 0 2<br>0 2 0 0 0 0<br>3 9 3 0 0 1</p><h3 id="예제-출력-5"><a href="#예제-출력-5" class="headerlink" title="예제 출력 5"></a>예제 출력 5</h3><p>48</p><h3 id="예제-입력-6"><a href="#예제-입력-6" class="headerlink" title="예제 입력 6"></a>예제 입력 6</h3><p>6<br>1 1 1 1 1 1<br>2 2 6 2 2 3<br>2 2 5 2 2 3<br>2 2 2 4 6 3<br>0 0 0 0 0 6<br>0 0 0 0 0 9</p><h3 id="예제-출력-6"><a href="#예제-출력-6" class="headerlink" title="예제 출력 6"></a>예제 출력 6</h3><p>39</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>현재 상어의 위치를 기준으로 bfs를 통해 가장 가까운 위치의 먹을 수 있는 물고기를 찾는다.<ul><li>이 때, bfs에서 먹을 수 있는 물고기가 여러마리라면 문제의 조건대로 가장 가깝고, 가장 위, 가장 왼쪽의 물고기가 우선순위가 되도록 하기 위해</li><li>먹을 수 있는 물고기의 위치를 tuple을 사용하여 거리가 같다면 가장 위, 다음 가장 왼쪽 (거리, 행, 열)순서로 오름차순 정렬을 하여 0번째 인덱스의 튜플을 리턴한다.<ul><li>먹을 수 있는 물고기가 없다면 -1을 리턴</li></ul></li></ul></li><li>가장 가까운 물고기의 위치로 상어의 위치를 갱신하고 먹은 자리를 0으로 초기화한다.</li><li>이번 차례의 물고기를 먹기 위해 이동한 거리를 누적하고 물고기의 경험치를 1추가하여 자기의 크기와 같아진다면 크기를 1증가시키고 경험치를 0으로 초기화한다.</li><li>더 이상 먹을 수 있는 물고기가 없어 -1을 리턴받았다면 반복문을 빠져나간다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; bfs(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">q.push(make_pair(x, y));</span><br><span class="line">d[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">tie(x, y) = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; d[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> eat = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] == <span class="number">0</span> || a[nx][ny] == <span class="built_in">size</span>) ok = <span class="literal">true</span>; <span class="comment">// 이동 가능 여부</span></span><br><span class="line"><span class="keyword">if</span> (a[nx][ny] != <span class="number">0</span> &amp;&amp; a[nx][ny] &lt; <span class="built_in">size</span>)  <span class="comment">// 먹을 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">ok = <span class="literal">true</span>; <span class="comment">// 이동 가능하고</span></span><br><span class="line">eat = <span class="literal">true</span>; <span class="comment">// 먹을 수 있다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ok) <span class="comment">// 이동이 가능한 상태라면</span></span><br><span class="line">&#123;</span><br><span class="line">q.push(make_pair(nx, ny)); <span class="comment">// 다음 위치</span></span><br><span class="line">d[nx][ny] = d[x][y] + <span class="number">1</span>; <span class="comment">// 거리 1증가</span></span><br><span class="line"><span class="keyword">if</span> (eat) <span class="comment">// 먹을 수 있는 물고기를 만난 경우</span></span><br><span class="line">ans.push_back(make_tuple(d[nx][ny], nx, ny)); <span class="comment">// 먹을 수 있는 물고기가 여러마리라면 위, 왼쪽이 우선</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans.empty()) <span class="comment">// 먹을 수 있는 물고기가 없는 경우</span></span><br><span class="line">ans.push_back(make_tuple(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)); <span class="comment">// -1리턴</span></span><br><span class="line"></span><br><span class="line">sort(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>()); <span class="comment">// 가장 가까운 물고기부터</span></span><br><span class="line"><span class="comment">// 거리가 같다면 가장 위, 다음 가장 왼쪽 (거리, 행, 열)순서로 오름차순 정렬</span></span><br><span class="line"><span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="number">9</span>) <span class="comment">// 상어의 위치</span></span><br><span class="line">&#123;</span><br><span class="line">x = i;</span><br><span class="line">y = j;</span><br><span class="line">a[i][j] = <span class="number">0</span>; <span class="comment">// 0으로 초기화</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">2</span>; <span class="comment">// 크기</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>; <span class="comment">// 경험치</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> dist;</span><br><span class="line">tie(dist, x, y) = bfs(x, y, <span class="built_in">size</span>); <span class="comment">// 상어의 위치 갱신(가장 가까운 물고기의 위치)</span></span><br><span class="line"><span class="keyword">if</span> (dist == <span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">// 더 이상 먹을 수 있는 물고기가 없다면</span></span><br><span class="line">a[x][y] = <span class="number">0</span>; <span class="comment">// 물고기를 먹은 자리는 0으로 초기화</span></span><br><span class="line">ans += dist; <span class="comment">// 이동 거리 추가(초)</span></span><br><span class="line"><span class="built_in">exp</span>++; <span class="comment">// 물고기 경험치</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="built_in">exp</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">size</span>++;</span><br><span class="line"><span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-16236&quot;&gt;&lt;a href=&quot;#Problem-16236&quot; class=&quot;headerlink&quot; title=&quot;Problem 16236&quot;&gt;&lt;/a&gt;Problem 16236&lt;/h1&gt;&lt;h2 id=&quot;아기-상어&quot;&gt;&lt;a href=&quot;#아기-상
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 9663번 N-Queen</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/16/algorithm9663/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/16/algorithm9663/</id>
    <published>2020-03-16T05:15:12.000Z</published>
    <updated>2020-03-16T05:16:32.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-9663"><a href="#Problem-9663" class="headerlink" title="Problem 9663"></a>Problem 9663</h1><h2 id="N-Queen"><a href="#N-Queen" class="headerlink" title="N-Queen"></a>N-Queen</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p><p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/9663" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/9663</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>8</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>92</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>퀸은 같은 행, 열, 대각선의 모든 칸으로 이동이 가능하므로 동일 행, 열, 대각선에 두 개 이상의 퀸을 놓을 수 없다.</li><li>n * n에 n개를 놓는 경우이므로 한 행에는 한개의 퀸만이 놓일 수 있다.<ul><li>이를 기준으로 재귀를 수행하며 check[row][col]에 퀸을 놓은 위치를 기록한다.</li><li>possible함수로 현재 위치에  퀸을 놓을 수 있는지 판별하여 가능하다면 퀸을 놓고 재귀를 수행한다.<ul><li>possible함수 : 첫 번째 행부터 차례로 퀸을 놓아 내려가고 있으므로 이전 행의 같은 열, 좌측 위 대각선, 우측 위 대각선을 확인하며 퀸이 놓였는지 확인한다.</li></ul></li></ul></li><li>row가 n과 같아졌다면 한 행에 하나의 퀸을 모두 놓은 경우이므로 방법의 수를 1증가시킨다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possible</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="comment">// (x, y)에 퀸을 놓을 수 있는지 판별하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>, j = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (check[i][y]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 같은 열에 놓인 퀸이 있는지 확인</span></span><br><span class="line"><span class="keyword">if</span> (y - j &gt;= <span class="number">0</span> &amp;&amp; check[i][y - j]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 좌측 위 대각선 확인</span></span><br><span class="line"><span class="keyword">if</span> (y + j &lt; n &amp;&amp; check[i][y + j]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 우측 위 대각선 확인</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == n) <span class="comment">// 놓을 수 있는 경우</span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (possible(row, col)) <span class="comment">// 현재 (row, col)에 퀸을 놓을 수 있는지 확인</span></span><br><span class="line">&#123;</span><br><span class="line">check[row][col] = <span class="literal">true</span>; <span class="comment">// 놓은 것을 표시</span></span><br><span class="line">go(row + <span class="number">1</span>);</span><br><span class="line">check[row][col] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">go(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-9663&quot;&gt;&lt;a href=&quot;#Problem-9663&quot; class=&quot;headerlink&quot; title=&quot;Problem 9663&quot;&gt;&lt;/a&gt;Problem 9663&lt;/h1&gt;&lt;h2 id=&quot;N-Queen&quot;&gt;&lt;a href=&quot;#N-Quee
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>백준 2109번 순회강연</title>
    <link href="https://kyu9341.github.io/algorithm/2020/03/15/algorithm2109/"/>
    <id>https://kyu9341.github.io/algorithm/2020/03/15/algorithm2109/</id>
    <published>2020-03-15T10:51:12.000Z</published>
    <updated>2020-04-02T15:21:07.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-2109"><a href="#Problem-2109" class="headerlink" title="Problem 2109"></a>Problem 2109</h1><h2 id="순회강연"><a href="#순회강연" class="headerlink" title="순회강연"></a>순회강연</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>한 저명한 학자에게 n(0≤n≤10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1≤d≤10,000)일 안에 와서 강연을 해 주면 p(1≤p≤10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.</p><p>예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.</p><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 최대로 벌 수 있는 돈을 출력한다.</p><h3 id="문제-링크"><a href="#문제-링크" class="headerlink" title="문제 링크"></a>문제 링크</h3><p><a href="https://www.acmicpc.net/problem/2109" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/2109</a></p><h3 id="예제-입력-1"><a href="#예제-입력-1" class="headerlink" title="예제 입력 1"></a>예제 입력 1</h3><p>7<br>20 1<br>2 1<br>10 3<br>100 2<br>8 2<br>5 20<br>50 10</p><h3 id="예제-출력-1"><a href="#예제-출력-1" class="headerlink" title="예제 출력 1"></a>예제 출력 1</h3><p>185</p><h3 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h3><ul><li>이 문제도 보석 도둑 문제와 비슷하게 그리디 알고리즘으로 해결이 가능하다.</li><li>제한 날짜가 현재 날짜 이상인 경우 강연 가능한 호부 중 가장 비용의 큰 것을 누적시키면 된다.</li><li>우선순위 큐를 사용하여 최대 날짜인 10000일 부터 역으로 내려오며 제한 날짜가 현재 날짜 이상인 모든 강연을 우선순위 큐에 push한다.<ul><li>예를 들어, 강연이 (20,1),(2,1),(10,3),(100,2),(25,2) 와 같이 있다면</li><li>(10,3),3,(100,2),(25,2),2,(20,1),(2,1),1 처럼 각 날짜 이상인 강의가 후보가 된다.</li></ul></li><li>최대 힙을 이용하였으므로 가장 큰 비용을 가지는 강연이 top()에 있으므로 최대 날짜부터 내려오며 top()의 비용을 누적하면 된다.</li></ul><h3 id="코드-설명"><a href="#코드-설명" class="headerlink" title="코드 설명"></a>코드 설명</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">// 대학의 개수</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; uni(n); <span class="comment">// first : day, second : pay</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; uni[i].second &gt;&gt; uni[i].first;</span><br><span class="line"></span><br><span class="line">sort(uni.<span class="built_in">begin</span>(), uni.<span class="built_in">end</span>(), [&amp;](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;); <span class="comment">// day기준 내림차순</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> uniIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10000</span>; i &gt;= <span class="number">1</span>; i--) <span class="comment">// 최대 날짜부터</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (uniIdx &lt; n &amp;&amp; i &lt;= uni[uniIdx].first) <span class="comment">// 제한 날짜가 현재 날짜 이상인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">pq.push(uni[uniIdx++].second); <span class="comment">// 우선순위 큐에 삽입</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pq.empty())</span><br><span class="line">&#123;</span><br><span class="line">ans += pq.top(); <span class="comment">// 강연 가능한 후보들 중 가장 비용이 큰 것을 누적</span></span><br><span class="line">pq.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Problem-2109&quot;&gt;&lt;a href=&quot;#Problem-2109&quot; class=&quot;headerlink&quot; title=&quot;Problem 2109&quot;&gt;&lt;/a&gt;Problem 2109&lt;/h1&gt;&lt;h2 id=&quot;순회강연&quot;&gt;&lt;a href=&quot;#순회강연&quot; cla
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
</feed>

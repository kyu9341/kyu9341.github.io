<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kwon&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5594e9f17b4feb6e10a6bc1e7107ab0b</icon>
  <subtitle>개발 블로그</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kyu9341.github.io/"/>
  <updated>2019-12-31T07:36:26.636Z</updated>
  <id>https://kyu9341.github.io/</id>
  
  <author>
    <name>kwon</name>
    <email>kyu9341@naver.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>힙 정렬(Heap Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/28/algorithmHeapSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/28/algorithmHeapSort/</id>
    <published>2019-12-28T09:53:12.000Z</published>
    <updated>2019-12-31T07:36:26.636Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>힙 정렬(Heap Sort)</strong> 에 대해 알아보겠다. 힙 정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 또한 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기 때문에 반드시 알고 넘어가야 하는 정렬 알고리즘이라고 한다. 힙 정렬은 힙 트리 구조(Heap Tree Structure)를 이용하는 정렬 방법이다.</p><h2 id="힙-정렬-Heap-Sort"><a href="#힙-정렬-Heap-Sort" class="headerlink" title="힙 정렬(Heap Sort)"></a>힙 정렬(Heap Sort)</h2><blockquote><p>힙 정렬(Heapsort)이란 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법으로서, 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다. 최대 힙을 구성하여 정렬하는 방법은 아래 예와 같다.</p><ol><li>n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다.</li><li>최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다.</li><li>가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다.</li><li>2와 3을 반복한다.<br>출처 - 위키백과</li></ol></blockquote><p>우선 힙(Heap)이 무엇인지 알아야 한다. 그리고 힙을 알기 전에 이진 트리(Binary Tree)에 대해 알아야 한다. 이진 트리란 컴퓨터 안에서 데이터를 표현할 때 데이터를 각 노드(Node)에 담은 뒤에 노드를 두 개씩 이어 붙이눈 구조이다. 이 때 트리 구조에 맞게 부모 노드에서 자식 노드로 가지가 뻗힌다. 이진 트리는 모든 노드의 자식 노드가 2개 이하인 노드이다.</p><div style="width: 500px; height: 300px;">    <img src="https://kyu9341.github.io/img/binarytree.png" style="width: 500px    ; height: 300px;"></div><p>흔히 위와 같은 구조를 이진 트리라고 한다. <strong>여기서 트리(Tree)</strong> 라는 것은 말 그대로 가지를 뻗어나가는 것처럼 데이터가 서로 연결되어 있다는 것이다. 트리는 그 형태에 따라 종류가 다양한데 여기서는 위와 같은 이진 트리만 알면 된다. 이제 <strong>완전 이진 트리(Complete Binary Tree)</strong> 에 대해 알아보자.</p><p>완전 이진 트리는 데이터가 루트(Root)노드부터 시작하여 자식 노드가 왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가는 구조의 이진 트리이다. 즉, 완전 이진 트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽히 가득 찬 구조이다.</p><div style="width: 400px; height: 300px;">    <img src="https://kyu9341.github.io/img/cbt.png" style="width: 400px    ; height: 300px;"></div><p>이제 <strong>힙(Geap)</strong> 에 대해 알아보자. 힙은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다. 힙에는 최대 힙과 최소 힙이 존재하는데 최대 힙은 부모 노드가 자식 노드보다 큰 힙이며 최소 힙은 부모 노드가 자식 노드보다 작은 힙이다.</p><div style="width: 600px; height: 250px;">    <img src="https://kyu9341.github.io/img/heap.png" style="width: 600px    ; height: 250px;"></div><p>힙은 위와 같은 구조이며 일단 힙 정렬을 하기 위해서는 정해진 데이터를 힙 구조를 가지도록 만들어야 한다.</p><div style="width: 600px; height: 400px;">    <img src="https://kyu9341.github.io/img/heap1.png" style="width: 600px    ; height: 400px;"></div><p>힙 정렬을 수행하기 위해서는 <strong>힙 생성 알고리즘(Heapify Algorithm)</strong> 을 사용한다. 힙 생성 알고리즘은 특정한 하나의 노드에 대해서 수행하는 것이다. 또한 ‘하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태를 가정한다는 특징’이 있다. 위의 트리에서 5만 최대 힙 정렬을 수행해주면 전체 트리가 최대 힙 구조로 형성되는 상태이다.</p><p>힙 생성 알고리즘은 <strong>특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘</strong> 이다. 또한 위치를 바꾼 뒤에도 여전히 자식이 존재하는 경우 자식이 더이상 존재하지 않을때 까지 자식 중에서 더 큰 자식과 자신의 위치를 바꾸어야 한다. 즉, 위에서 5의 자식인 7과 4 중에서 더 큰 자식인 7과 5의 위치를 바꾸어 주면 된다. 바꾼 결과는 아래와 같다.</p><div style="width: 600px; height: 400px;">    <img src="https://kyu9341.github.io/img/heap2.png" style="width: 600px    ; height: 400px;"></div><p>위와 같이 힙 생성 알고리즘은 전체 트리를 힙 구조를 가지도록 만든다는 점에서 굉장히 중요한 알고리즘이다. 이러한 힙 생성 알고리즘의 시간 복잡도는 몇일까? 한 번 자식 노드로 내려갈 때마다 노드의 갯수가 2배씩 증가한다는 점에서 O(logN)이다. 예를 들어 데이터의 갯수가 1024개라면 10번 정도만 내려가도 된다는 뜻이다.</p><p>이제 예시를 보며 실제 힙 정렬 과정을 수행해보자.</p><p>7 6 5 8 3 5 9 1 6</p><p>위의 데이터를 오름차순으로 정렬한다고 해보자. 기본적으로 이진 트리를 표현하는 가장 쉬운 방법은 배열에 그대로 삽입하는 것이다. 현재 정렬할 데이터의 갯수가 9개이기 때문에 인덱스 0붙터 8까지 차례로 담아주면 된다.</p><table><thead><tr><th align="center"><center>0</center></th><th align="center"><center>1</center></th><th align="center"><center>2</center></th><th align="center"><center>3</center></th><th align="center"><center>4</center></th><th align="center"><center>5</center></th><th align="center"><center>6</center></th><th align="center"><center>7</center></th><th align="center"><center>8</center></th></tr></thead><tbody><tr><td align="center">7</td><td align="center">6</td><td align="center">5</td><td align="center">8</td><td align="center">3</td><td align="center">5</td><td align="center">9</td><td align="center">1</td><td align="center">6</td></tr></tbody></table><p>다시 말해 완전 이진 트리에 삽입이 되는 순서대로 인덱스를 붙여주는 것이다. 위 배열을 완전 이진 트리 형태로 출력하면 다음과 같다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/bt.png" style="width: 400px    ; height: 400px;"></div><p>말 그대로 배열에 있는 인덱스가 그대로 차례대로 트리로 표현된 것이다. 위와 같은 상황에서 힙 생성 알고리즘을 적용하여 전체 트리를 힙 구조로 만들면 된다. 이 때 데이터의 갯수가 N개 이므로 전체 트리를 힙 구조로 만드는 복잡도는 O(N*logN)이다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/bt1.png" style="width: 400px    ; height: 400px;"></div><p>그래서 결과적으로는 위와 같이 최대 힙이 구성된다. 이제부터 실제로 우리가 원하던 정렬을 직관적으로 수행할 수 있다. 루트(Root)에 있는 값을 가장 뒤쪽으로 보내면서 힙 트리의 크기를 1씩 빼주는 것이다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/bt2.png" style="width: 400px    ; height: 400px;"></div><p>위와 같이 9와 6을 바꾼 뒤에 9는 정렬이 완료된 것이므로 빨간색으로 표현한다. 이제 9를 제외하고 나머지 8개 원소를 기준으로 또 힙 생성 알고리즘(Heapify)를 수행한다. 결과는 다음과 같다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/bt3.png" style="width: 400px    ; height: 400px;"></div><p>이제 다시 가장 큰 숫자인 8이 루트에 존재한다. 이것을 가장 뒤쪽의 원소와 서로 바꾼다.</p><div style="width: 400px; height: 400px;">    <img src="https://kyu9341.github.io/img/bt4.png" style="width: 400px    ; height: 400px;"></div><p>그럼 위와 같이 8과 9가 가장 뒤에 배열되어 정렬된 것을 볼 수 있다. 이제 이 과정을 반복하면 된다. 힙 생성 알고리즘의 시간 복잡도는 O(logN)이고 전체 데이터의 갯수가 N개이므로 결과적으로 힙 정렬의 시간 복잡도는 O(N*logN)이라고 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> heap[number] = &#123; <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">printArray(heap, number);</span><br><span class="line"><span class="comment">// 전체 트리 구조를 최대 힙 구조로 바꾼다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; number; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c = i;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> root = (c - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 자기 자신의 부모를 의미</span></span><br><span class="line"><span class="keyword">if</span> (heap[root] &lt; heap[c]) <span class="comment">// 부모보다 자식이 크다면 위치를 바꿈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">c = root; <span class="comment">// 부모의 인덱스로 변환하여 0이 될때까지 올라감</span></span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">printArray(heap, number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 크기를 줄여가며 반복적으로 힙을 구성</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = number - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 마지막 인덱스부터 시작</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 가장 큰 값을 맨 뒤로 보냄</span></span><br><span class="line"><span class="keyword">int</span> temp = heap[<span class="number">0</span>];</span><br><span class="line">heap[<span class="number">0</span>] = heap[i];</span><br><span class="line">heap[i] = temp;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 자식 중에 더 큰 값 찾기</span></span><br><span class="line"><span class="comment">// 옆의 값과 비교하여 더 큰 값의 인덱스를 c에 지정</span></span><br><span class="line"><span class="keyword">if</span> (heap[c] &lt; heap[c + <span class="number">1</span>] &amp;&amp; c &lt; i - <span class="number">1</span>) <span class="comment">// 범위를 넘지 않는 한에서</span></span><br><span class="line">c++;</span><br><span class="line"><span class="comment">// 루트보다 자식이 더 크다면 교환</span></span><br><span class="line"><span class="keyword">if</span> (heap[root] &lt; heap[c] &amp;&amp; c &lt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">root = c;</span><br><span class="line">&#125; <span class="keyword">while</span> (c &lt; i);</span><br><span class="line">printArray(heap, number);</span><br><span class="line">&#125;</span><br><span class="line">printArray(heap, number);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최대 힙을 이용하여 위와 같이 힙 정렬을 작성할 수 있으며 진행 과정은 다음과 같다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/heapsort.png" style="width: 250px    ; height: 200px;"></div><p>힙 정렬은 병합 정렬과 다르게 별도로 추가적인 배열이 필요하지 않다는 점에서 메모리 측면에서 매우 효율적이다. 또한 항상 O(N*logN)을 보장할 수 있다는 점에서 아주 강력한 알고리즘이다. 하지만 단순히 속도만 놓고 비교하면 퀵 정렬이 평균적으로 더 빠르기 때문에 힙 정렬이 일반적으로 많이 사용되지는 않는다고 한다. </p><p>참조 : <a href="https://blog.naver.com/ndb796/221228342808" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221228342808</a></p><p><a href="https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC</a></p><p><a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/05/10/algorithm-heap-sort.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;힙 정렬(Heap Sort)&lt;/strong&gt; 에 대해 알아보겠다. 힙 정렬은 병합 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 또한 고급 프로그래밍 기법으로 갈수록 힙(Heap)의 개념이 자주 등장하기 때문에 반드
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>병합 정렬(Merge Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/27/algorithmMergeSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/27/algorithmMergeSort/</id>
    <published>2019-12-27T11:44:19.000Z</published>
    <updated>2019-12-28T07:21:34.530Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스팅에서는 <strong>병합 정렬(Merge Sort)</strong> 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 ‘분할 정복’방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.</p><p>퀵 정렬은 피벗 값에 따라서 편향되게 분할할 가능성이 있다는 점에서 최악의 경우 O(N^2)의 시간 복잡도를 가지지만 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(N*logN)을 보장한다.</p><h2 id="병합-정렬-Merge-Sort"><a href="#병합-정렬-Merge-Sort" class="headerlink" title="병합 정렬(Merge Sort)"></a>병합 정렬(Merge Sort)</h2><blockquote><p>합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다. 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다. 존 폰 노이만이 1945년에 개발했다. 하향식 합병 정렬에 대한 자세한 설명과 분석은 1948년 초 헤르만 골드스타인과 폰 노이만의 보고서에 등장하였다.<br>합병 정렬은 다음과 같이 작동한다.</p><ol><li>리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는</li><li>분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.</li><li>정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.</li><li>결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.</li><li>복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.</li></ol><p>출처 - 위키백과</p></blockquote><p>병합 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할한 뒤에 각자계산하고 나중에 합치는 방법을 채택한다. 즉, 기본 아이디어는 일단 정확히 반으로 나누고 나중에 정렬하는 것이다.</p><div style="width: 750px; height: 500px;">    <img src="https://kyu9341.github.io/img/mergeSort.png" style="width: 750px    ; height: 500px;"></div><p>위의 그림처럼 초기 상태의 배열에서 각각 절반씩 계속해서 나누어 크기가 1인 배열로 나눈다. 이후 다시 크기가 1인 배열 두 개씩 병합하며 정렬을 수행한다.(1단계) 그럼 크기가 2인 배열 4개가 되었을 것이고, 4개의 배열은 정렬이 되어있다. 다시 4개의 배열을 두 개씩 병합하여 크기가 4인 배열 2개가 되고, 이 과정에서 정렬이 수행된다.(2단계) 마지막으로 크기가 4인 배열 2개를 병합하여 크기가 8인 배열로 돌아가며 정렬이 된다.(3단계) 이러한 과정으로 진행이 되는데 이때 병합되는 과정은 3단계로 이루어진다. 그 이유는 초기 배열의 크기가 8이기 때문에 log(2)8 = 3 단계가 필요한 것이다.</p><p>따라서, 크기가 N인 배열을 정렬한다면 단계는 log(2)N을 유지하게 된다. 또한 데이터의 갯수만큼만 연산하면 되기 때문에 정렬 자체에 필요한 수행시간은 N이다. 결과적으로 총 시간 복잡도는 O(N*logN)이 된다.</p><p>위에서 병합이 되는 순간 정렬이 같이 된다고 했다. 그 과정을 한번 살펴보자.</p><p>1단계에서는 배열의 크기가 1이기 때문에 두 수만 비교하여 작은 수를 앞에 두면 된다.</p><p>2단계에서는 크기가 2인 배열 두 개를 병합하게 되므로 우선 각 배열에서 가장 작은 값을 비교한다. 이때, 각 배열은 정렬되어있는 상태이기 때문에 두 배열의 가장 앞에 있는 값을 서로 비교한다. 위의 그림을 예로 들면 [10, 21]과 [12, 20]에서 먼저 10과 12를 비교하게 되는 것이다. 10이 더 작으므로 10을 새로 만들어질 배열의 맨 앞에 둔다.</p><p> 그럼 [10, 21]이 있던 배열은 21만 남아있는 상태일 것이다. 그럼 21이 가장 작은 원소이므로 21과 [12, 20]이 들어있는 배열의 최솟값 12와 비교를 하여 12가 더 작으므로 새로 만들어질 배열의 두번째 자리에 12가 들어간다. [10, 12, - , - ] 와 같은 상태일 것이며 이제 남은 [ - , 21] 과 [ - , 20]를 비교하여 더 작은 20이 먼저 들어가 [10, 12, 20, 21]과 같이 정렬이 수행된다.</p><p> 3단계에서도 2단계와 마찬가지로 두 배열의 최솟값 부터 비교하게 되며 이 과정이 반복되어 정렬이 완료된다.</p><p> 이러한 과정을 잘 보면 각 부분 집합은 이미 정렬이 된 상태이므로 이미 정렬된 두 배열을 합치는 것은 N번의 연산만 수행하면 된다. 즉 시간 복잡도 O(N)이면 되는 것이다. 즉, 가로축은 N 세로축은 logN이므로 총 시간 복잡도가 O(N*logN)인 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> sorted[number]; <span class="comment">// 정렬 배열은 반드시 전역 변수로 사용(추가적인 배열)</span></span><br><span class="line"><span class="comment">// 정렬을 수행할 때 추가적인 배열이 필요, 필요할 때마다 배열을 생성한다면 비효율적임</span></span><br><span class="line"><span class="comment">// 전역변수로 모든 함수가 공통적으로 사용하도록 하여 메모리 소모를 최소화</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> middle, <span class="keyword">int</span> n)</span> <span class="comment">// 두 개의 정렬된 부분 배열을 이용해 새롭게 정렬된 배열을 생성하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// m : 시작점 , middle : 중간점, n : 끝점</span></span><br><span class="line"><span class="keyword">int</span> i = m; <span class="comment">// 좌측 부분 배열의 시작점</span></span><br><span class="line"><span class="keyword">int</span> j = middle + <span class="number">1</span>; <span class="comment">// 우측 부분 배열의 시작점</span></span><br><span class="line"><span class="keyword">int</span> k = m; <span class="comment">// 새로운 배열의 시작점</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 작은 순서대로 배열에 삽입</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 남은 데이터 삽입</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; middle) <span class="comment">// 왼쪽 배열이 먼저 모두 삽입된 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = j; t &lt;= n; t++) <span class="comment">// 오른쪽 배열을 순서대로 삽입</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 오른쪽 배열이 먼저 모두 삽입된 경우, (j &gt; n)인 경우</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = i; t &lt;= middle; t++) <span class="comment">// 왼쪽 배열을 순서대로 삽입</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 정렬된 배열을 실제 배열에 삽입</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = m; t &lt;= n; t++)</span><br><span class="line">a[t] = sorted[t];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> middle;</span><br><span class="line"><span class="comment">// 크기가 1보다 큰 경우</span></span><br><span class="line"><span class="keyword">if</span> (m &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">middle = (m + n) / <span class="number">2</span>;</span><br><span class="line">mergeSort(a, m, middle);</span><br><span class="line">mergeSort(a, middle + <span class="number">1</span>, n);</span><br><span class="line">merge(a, m, middle, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> <span class="comment">// 배열 출력 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[number] = &#123; <span class="number">21</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">22</span> &#125;;</span><br><span class="line">printArray(arr, number);</span><br><span class="line">mergeSort(arr, <span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line">printArray(arr, number);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/merge.png" style="width: 250px    ; height: 200px;"></div><p>진행 과정을 출력해보면 위와 같은 과정으로 진행이 되는 것을 확인할 수 있다.</p><p>병합 정렬을 구현할 때 신경써야 할 부분은 정렬에 사용되는 배열은 전역 변수로 선언해야 한다는 것이다. 만약 함수 안에서 배열을 선언하면 매 번 배열을 선언해야하기 때문에 메모리 낭비가 크다. 이와 같이 병합 정렬은 기존의 데이터를 담을 추가적인 배열 공간이 필요하다는 점에서 메모리 활용이 비효율적인 단점이 있다.</p><p>병합 정렬은 일반적인 경우 퀵 정렬보다 느리지만 어떠한 상황에서도 O(N*logN)을 보장한다는 점에서 아주 효율적인 알고리즘이다.</p><p>참조 : <a href="https://blog.naver.com/ndb796/221242106787" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221242106787</a></p><p><a href="https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC</a></p><p><a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html" target="_blank" rel="external nofollow noopener noreferrer">https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 포스팅에서는 &lt;strong&gt;병합 정렬(Merge Sort)&lt;/strong&gt; 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 ‘분할 정복’방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>삽입 정렬(Insertion Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/22/algorithmInsertionSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/22/algorithmInsertionSort/</id>
    <published>2019-12-22T02:44:19.000Z</published>
    <updated>2019-12-31T05:33:37.741Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 삽입 정렬에 대해 알아보겠다. 앞서 다루었던 정렬 알고리즘과 같은 시간복잡도인 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속한다.</p><h2 id="삽입-정렬-Selection-Sort"><a href="#삽입-정렬-Selection-Sort" class="headerlink" title="삽입 정렬(Selection Sort)"></a>삽입 정렬(Selection Sort)</h2><blockquote><p>삽입 정렬(揷入整列, insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.</p><p>출처 - 위키백과</p></blockquote><p>삽입 정렬은 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결한다. 다른 정렬 방식들은 무조건 위치를 바꾸는 방식이었다면 삽입 정렬은 필요할 때만 위치를 바꾸게 된다. 이와 같은 특성 때문에 선택 정렬이나 버블 정렬보다 빠르며 특정한 경우에서는 아주 빠르게 동작하기도 한다.</p><p>삽입 정렬은 현재 위치의 숫자가 앞의 숫자들의 어느 위치에 들어갈지 찾아 적절한 위치에 삽입되는 방식이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, index, temp;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">j = i;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = temp;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>삽입 정렬은 위와 같이 구현할 수 있으며 진행 과정은 아래와 같다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/insertsort.png" style="width: 250px    ; height: 200px;"></div><p>중간 과정에도 앞부분은 계속해서 정렬이 되어있는 것을 확인할 수 있다. 삽입 정렬은 앞서 말했듯이 선택 정렬과 버블 정렬보다는 뛰어나지만 최악의 경우는 앞의 정렬 방식과 같은 수만큼 연산이 일어난다. (O(N^2)) 하지만 2 3 4 5 6 7 8 9 10 1 과 같이 거의 정렬이 된 상태의 경우에는 아주 빠른 속도로 정렬이 가능하다.</p><p>참조 : <a href="https://blog.naver.com/ndb796/221226806398" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226806398</a></p><p><a href="https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 삽입 정렬에 대해 알아보겠다. 앞서 다루었던 정렬 알고리즘과 같은 시간복잡도인 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속한다.&lt;/p&gt;
&lt;h2 id=&quot;삽입-정렬-Selection-Sort&quot;&gt;&lt;a href=&quot;#삽입-정렬-Sele
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>퀵 정렬(Quick Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/22/algorithmQuickSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/22/algorithmQuickSort/</id>
    <published>2019-12-22T02:44:19.000Z</published>
    <updated>2019-12-30T08:59:17.594Z</updated>
    
    <content type="html"><![CDATA[<p>이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 그 대표적인 빠른 알고리즘이 <strong>퀵 정렬</strong> 알고리즘이다.</p><h2 id="퀵-정렬-Quick-Sort"><a href="#퀵-정렬-Quick-Sort" class="headerlink" title="퀵 정렬(Quick Sort)"></a>퀵 정렬(Quick Sort)</h2><blockquote><p>퀵 정렬은 분할 정복(divide and conquer) 방법을 통해 리스트를 정렬한다.</p><ol><li><p>리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗이라고 한다.</p></li><li><p>피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.</p></li><li><p>분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.</p></li></ol><p>재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.</p><p>출처 - 위키백과</p></blockquote><p>퀵 정렬은 대표적인 ‘분할 정복’ 알고리즘으로 평균 속도가 O(N*logN)이다. 이때 logN은 사실상 거의 상수라고 해도 무방할 만큼 작은 수이다.</p><p>예를 들어, 2^10 이 약 1,000 이고 2^20이 약 1,000,000 이므로 N이 1,000,000이라 하더라도</p><div style="width: 100px; height: 20px;">    <img src="http://chart.apis.google.com/chart?cht=tx&chl= log_2N = 20" style="width: 100px; height: 20px;"></div><p>밖에 되지 않는다. 즉, 굉장히 빠르다는 것을 알 수 있다.</p><p>퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬한다. 더 쉽게 말하자면 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눈다.</p><p>일반적으로 퀵 정렬 같은 경우는 피벗 값을 설정할 때 가장 앞에 있는 수를 피벗 값으로 설정한다.</p><p><strong>3</strong> <strong>7</strong> 8 1 5 9 6 10 <strong>2</strong> 4 에서 시작한다고 하면 피벗 값은 3이다.</p><p>이후 <strong>왼쪽에서 오른쪽으로 이동하며 피벗 값보다 큰 값</strong> 을 찾고 <strong>오른쪽부터 왼쪽으로 이동하며 피벗 값보다 작은 값</strong> 을 찾는다. 찾으면 두 값의 위치를 바꾸어준다.</p><p><strong>3</strong> 2 <strong>8 1</strong> 5 9 6 10 7 4</p><p>피벗 값은 3으로 유지하고 같은 방식으로 왼쪽에서 큰 값(8)과 오른쪽에서 작은 값(1)을 구해 바꿔주면</p><p><strong>3</strong> 2 <strong>8 1</strong> 5 9 6 10 7 4</p><p>이 되며 한 번 더 수행하면 마찬가지로 8과 1 인데 엇갈린 상태가 된다. 즉, 작은 값의 인덱스가 큰 값의 인덱스보다 작아지게 되면 엇갈린 상태인 것이다. 이때는 왼쪽에 있는 값(더 작은값)과 피벗 값인 3과 바꿔주면 된다.</p><p>1 2 <strong>3</strong> 8 5 9 6 10 7 4</p><p>여기까지 된다면 3은 정렬이 된 것이고 한 번 분할이 완료된 것이다. 3보다 왼쪽에 있는 수들은 모두 3보다 작고, 3보다 오른쪽에 있는 수들은 모두 3보다 큰 특징을 가진다.</p><p>이제 왼쪽 집합과 오른쪽 집합으로 나누어 피벗 값을 각각 설정하고 다시 퀵 정렬을 수행하게 된다. 왼쪽 집합에서는 1이 피벗 값이고 오른쪽 집합에서는 8이 피벗 값이 된다. 먼저 왼쪽부터 보면 1보다 큰 값은 오른쪽에 있고 작은 값은 없지만 왼쪽에 있다고 가정하고 1이 정렬이 된다.</p><p><strong>1</strong> 2 <strong>3</strong> <strong>8</strong> 5 9 6 10 7 4</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 9 6 10 7 4</p><p>마찬가지로 2도 정렬이 되며 오른쪽 부분을 보면 왼쪽에서부터 8보다 큰 값인 9를 찾고 오른쪽에서부터 8보다 작은 4를 찾게된다. 지금은 엇갈리지 않았으므로 9와 4를 바꿔준다.</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 4 6 10 7 9</p><p>마찬가지로 10과 7을 선택하게 되고 바꿔준다.</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> <strong>8</strong> 5 4 6 7 10 9</p><p>여기서 한번 더 수행하면 7과 10이 엇갈린 상태이므로 7과 8의 위치가 바뀌어</p><p><strong>1</strong> <strong>2</strong> <strong>3</strong> 7 5 4 6 <strong>8</strong> 10 9</p><p>위와 같이 다시 8을 기준으로 왼쪽 집합과 오른쪽 집합으로 나뉘어 왼쪽은 8보다 작은 값들만, 오른쪽은 8보다 큰 값들만 모이게 된다.</p><p>이러한 과정을 계속해서 반복하면 모두 정렬이 수행된다.</p><p>퀵 정렬처럼 분할을 하여 연산을 하면 빠른 이유에 대해 조금 더 살펴보면</p><p>1 2 3 4 5 6 7 8 9 10 이 있을 때</p><p>N^2 = 10 * 10 = 100 인 반면</p><p>1 2 3 4 5 -&gt; 5 * 5 = 25</p><p>6 7 8 9 10 -&gt; 5 * 5 = 25</p><p>가 되므로 분할하여 구한 후 더하면 50이 되며 100보다 훨씬 작은 횟수의 연산으로 정렬을 수행할 수 있다. 이것이 분할 정복이 강력한 이유이다.</p><p>이때 2씩 계속해서 나누어지는 과정을 log_(2) N 으로 표현하게 된다.</p><p>즉, 데이터의 개수가 N이고 반씩 쪼개 들어가기 때문에 O(N*log_(2) N)이라고 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> <span class="comment">// start, end -&gt; 부분집합의 시작과 끝 인덱스</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt;= <span class="built_in">end</span>) <span class="keyword">return</span>; <span class="comment">// 원소가 1개인 경우</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> key = start; <span class="comment">// 피벗 값 첫번째 원소의 인덱스</span></span><br><span class="line"><span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) <span class="comment">// 엇갈릴 때까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (data[i] &lt;= data[key]) <span class="comment">// 키 값보다 큰 값을 만날 때까지 이동</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (data[j] &gt;= data[key] &amp;&amp; j &gt; start) <span class="comment">// 키 값보다 작은 값을 만날 때까지 이동</span></span><br><span class="line">&#123; <span class="comment">// 범위를 넘어가지 않도록 j &gt; start를 걸어줌</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i &gt; j) <span class="comment">// 현재 엇갈린 상태면 작은 값(j)을 키 값과 교체</span></span><br><span class="line">&#123;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j] = data[key];</span><br><span class="line">data[key] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 엇갈리지 않은 상태라면 i와 j를 교체</span></span><br><span class="line">&#123;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j] = data[i];</span><br><span class="line">data[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">quickSort(data, start, j - <span class="number">1</span>);</span><br><span class="line">quickSort(data, j + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data[number] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line">quickSort(data, <span class="number">0</span>, number - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 : "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 재귀함수를 이용하여 작성할 수 있고 아래와 같이 정렬이 진행된다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/quicksort.png" style="width: 250px    ; height: 200px;"></div><p>퀵 정렬은 평균 시간 복잡도는 O(N*logN)이지만 최악의 경우 시간 복잡도는 O(N^2)이 되기도 한다. 이미 정렬이 되어있는 경우나 거의 정렬이 되어있는 경우에는 퀵 정렬의 효율이 매우 떨어진다. 반면 삽입 정렬은 이런 경우를 빠르게 해결할 수 있다. 즉, 정렬할 데이터의 특성에 따라 적절한 정렬 알고리즘을 사용하는 것이 중요하다.</p><p>참조 : <a href="https://blog.naver.com/ndb796/221226813382" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226813382</a></p><p><a href="https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>버블정렬(Bubble Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/21/algorithmBubbleSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/21/algorithmBubbleSort/</id>
    <published>2019-12-21T08:31:15.000Z</published>
    <updated>2019-12-31T05:33:19.293Z</updated>
    
    <content type="html"><![CDATA[<p>저번 포스팅에서는 선택정렬에 대해 공부해보았고 이번에는 버블 정렬에 대해 알아보겠다. 마찬가지로 일련의 숫자들을 오름차순으로 정렬하는 문제이다.</p><h2 id="버블-정렬"><a href="#버블-정렬" class="headerlink" title="버블 정렬"></a>버블 정렬</h2><blockquote><p>거품 정렬(Bubble sort)은 두 인접한 원소를 검사하여 정렬하는 방법이다. 시간 복잡도가 O(n^2)로 상당히 느리지만, 코드가 단순하기 때문에 자주 사용된다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다.</p><p>출처 - 위키백과</p></blockquote><p>버블 정렬 또한 선택 정렬과 같이 아주 직관적인 해결방법인데 바로 가까이에 있는 두 숫자끼리 비교를 하여 더 작은 숫자를 앞으로 보내주는 것을 반복하는 것이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, temp;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">9</span> - i; j++) <span class="comment">// 버블정렬은 뒤쪽부터 정렬이 되므로 9-i만큼만 반복하면 된다.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드로 표현할 수 있고 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 버블 정렬은 뒤쪽부터 정렬이 수행되는 것을 확인할 수 있다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/bubblesort.png" style="width: 250px    ; height: 200px;"></div><p>이제 시간복잡도를 확인해 보자. 버블 정렬도 선택 정렬과 마찬가지로 10 + 9 + 8 + 7 + 6 + 5 + .. + 1 만큼 연산을 수행하므로 O(N^2)으로 동일하지만 버블 정렬은 각 싸이클마다 모두 자리를 바꿔주는 연산을 수행하기 때문에 선택 정렬보다 훨씬 비효율적이고 정렬 알고르즘 중에 가장 느린 알고리즘이다.</p><p>참조 : <a href="https://blog.naver.com/ndb796/221226803544" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226803544</a></p><p><a href="https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EA%B1%B0%ED%92%88_%EC%A0%95%EB%A0%AC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번 포스팅에서는 선택정렬에 대해 공부해보았고 이번에는 버블 정렬에 대해 알아보겠다. 마찬가지로 일련의 숫자들을 오름차순으로 정렬하는 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;버블-정렬&quot;&gt;&lt;a href=&quot;#버블-정렬&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>선택정렬(Selection Sort) 알고리즘</title>
    <link href="https://kyu9341.github.io/algorithm/2019/12/21/algorithmSelectionSort/"/>
    <id>https://kyu9341.github.io/algorithm/2019/12/21/algorithmSelectionSort/</id>
    <published>2019-12-21T05:12:42.000Z</published>
    <updated>2019-12-27T06:41:34.830Z</updated>
    
    <content type="html"><![CDATA[<p>이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주기 때문이라고 한다. 그래서 여러가지의 정렬 알고리즘을 먼저 배우고 알고리즘의 시간 복잡도에 대해 단계적으로 이해해 보자.</p><h2 id="선택-정렬-Selection-Sort"><a href="#선택-정렬-Selection-Sort" class="headerlink" title="선택 정렬(Selection Sort)"></a>선택 정렬(Selection Sort)</h2><blockquote><h3 id="선택-정렬"><a href="#선택-정렬" class="headerlink" title="선택 정렬"></a>선택 정렬</h3><p>선택 정렬은 제자리 정렬 알고리즘의 하나로, 다음와 같은 순서로 이루어진다.</p><ol><li>주어진 리스트 중에 최소값을 찾는다</li><li>그 값을 맨 앞에 위치한 값과 교체한다.(패스)</li><li>맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.</li></ol><p>출처 - 위키백과</p></blockquote><p>위의 설명처럼 선택 정렬은 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘이다. 예를 들어, 3 1 2 5 4 라는 순서의 숫자들을 오름차순으로 정렬한다고 생각해보자. 먼저 리스트의 최솟값을 구하여 가장 앞의 숫자와 위치를 바꾸게 되면 1이 최솟값이므로 3과 자리를 바꾸어 1 3 2 5 4 가 된다. 다음 1을 뺀 나머지의 리스트의 최솟값은 2 이므로 3과 자리를 바꾸어 1 2 3 5 4가 되고, 다음은 3이 최솟값이므로 넘어가서 같은 과정을 반복하면 1 2 3 4 5 로 오름차순 정렬이 끝나게 된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, <span class="built_in">min</span>, index, temp; <span class="comment">// min : 최솟값, index : 최솟값의 인덱스</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = <span class="number">9999</span>;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">min</span>) <span class="comment">// 최솟값을 구함</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = <span class="built_in">array</span>[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp = <span class="built_in">array</span>[i]; <span class="comment">// 최솟값과 자리 바꾸기</span></span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">min</span>;</span><br><span class="line"><span class="built_in">array</span>[index] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"결과 :"</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 선택정렬을 작성할 수 있다. 또한 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 선택 정렬은 앞쪽부터 정렬이 수행되는 것을 확인할 수 있다.</p><div style="width: 250px; height: 200px;">    <img src="https://kyu9341.github.io/img/selectionsort.png" style="width: 250px    ; height: 200px;"></div><p>이제 선택 정렬을 수행하는데에 얼마만큼의 시간이 걸리는지를 시간복잡도로 표현할 수 있는데 계산 방법은 다음과 같다.</p><p> 1 2 3 4 5 6 7 8 9 10 의 10개의 수를 정렬한다고 생각하면</p><p> 10 + 9 + 8 + … + 1 의 수 만큼 비교연산을 수행해야 한다. 즉, 10 * (10 + 1) / 2 = 55</p><p> 이것을 등차수열의 식에 의해 표현하면 <strong>N * (N + 1) / 2</strong> 로 표현할 수 있다. 즉, 이 알고리즘의 수행시간을 앞의 수식처럼 표현할 수가 있다는 것이다. 이때 일반적으로 컴퓨터에서는 2로 나눈다거나 1을 더한다거나 하는 것은 N이 매우 커지는 경우에는 무시할 수 있기 때문에 간단하게 더하거나 나누거나 하는 연산들은 모두 무시를 하게 된다.(가장 큰 차수만 보고 판단) 따라서 위의 수식이 <strong>N * N</strong> 으로 표현 할 수 가있다는 것이다.</p><p> 이것을 O(N * N) =&gt; O(N^2)이라고 표시할 수 있는데 이와 같은 표기법은 특정한 알고리즘의 수행시간을 간략하게 표현하는 방법이며 O(Big-O) 표기법이라 한다.</p><p>일반적으로 정렬 알고리즘에서 N^2의 복잡도는 아주 비효율적이고 느린 속도라고 할 수 있다.</p><p>참조 : <a href="https://blog.naver.com/ndb796/221226800661" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/ndb796/221226800661</a></p><p><a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC" target="_blank" rel="external nofollow noopener noreferrer">https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://kyu9341.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 부분 Mosaic</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing6/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing6/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:13.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="논리-연산"><a href="#논리-연산" class="headerlink" title="논리 연산"></a>논리 연산</h2><p>영상을 처리하기 위하여 단순하게 수를 더하거나 빼는 연산만을 수행하는 것이 아니라 영상에 대하여 논리적인 연산을 수행하여 원하는 결과를 얻을 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Circle</span><span class="params">(uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">double</span> diameter)</span> <span class="comment">// 원하는 반지름의 크기로 원 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> tmp, xSquare, ySquare;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Row;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line">ySquare = (<span class="built_in">abs</span>(Row / <span class="number">2</span> - i)) * (<span class="built_in">abs</span>(Row / <span class="number">2</span> - i)); <span class="comment">// (Row/2, Col/2) 는 중심의 좌표</span></span><br><span class="line">xSquare = (<span class="built_in">abs</span>(Col / <span class="number">2</span> - j)) * (<span class="built_in">abs</span>(Col / <span class="number">2</span> - j));</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">sqrt</span>(ySquare + xSquare); <span class="comment">// tmp는 현재 위치의 중심과의 거리 - 피타고라스 정리 x^2 + y^2 = z^2</span></span><br><span class="line"><span class="comment">//sqrt() : 제곱근을 구하는 함수</span></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; diameter) Result[i][j] = <span class="number">255</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">else</span> Result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 반지름의 길이를 매개변수로 받아 원하는 반지름을 가지는 원을 생성해주는 함수이다. 중심과의 거리를 이용하여 반지름보다 큰 범위의 값은 모두 0으로 작은 값은 모두 255로 변환하게 된다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/circle100.png" style="width: 512px    ; height: 512px;"></div><p>위의 이미지는 반지름이 100인 circle image이다. 다음은 두 이미지를 인자로 받아 and 연산과 or 연산을 수행해주는 함수이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaskOr</span><span class="params">(uchar** in1Img, uchar** in2Img, uchar** outImg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// or 연산</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outImg[i][j] = in1Img[i][j] | in2Img[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaskAnd</span><span class="params">(uchar** in1Img, uchar** in2Img, uchar** outImg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// and 연산</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outImg[i][j] = in1Img[i][j] &amp; in2Img[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 함수들을 이용하여 lena영상의 얼굴 부분만을 구할 수 있다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenaface.png" style="width: 512px    ; height: 512px;"></div>위의 이미지는 lena와 circle을 AND연산을 수행하여 얻은 결과이다.(diameter=150)<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenaor.png" style="width: 512px    ; height: 512px;"></div>위의 이미지는 lena와 circle을 OR연산을 수행하여 얻은 결과이다.<p>이를 응용하면 원하는 부분만 모자이크 처리를 수행하는 것이 가능하다. 먼저 lena와 circle이미지를 OR연산을 수행한 뒤 앞서 해보았던 mosaic 함수를 이용하여 모자이크된 lena영상과 AND연산을 수행하면 된다. 하지만 위와 같은 방법을 사용하면 메모리를 여러 개 할당해야하는 불편함과 위치를 원하는 곳으로 지정할 수 없는 불편함 있기 때문에 다음과 같은 함수를 작성하였다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CircleMosaic</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> diameter, <span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, a, b;</span><br><span class="line"><span class="keyword">double</span> tmp, xSquare, ySquare, avg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mtmp, count;</span><br><span class="line"></span><br><span class="line">mosaic(img, outimg, Row, Col, block); <span class="comment">// outimg에 모자이크된 이미지 저장</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line">ySquare = (y - j) * (y - j);</span><br><span class="line">xSquare = (x - i) * (x - i);</span><br><span class="line"></span><br><span class="line">tmp = <span class="built_in">sqrt</span>(ySquare + xSquare); <span class="comment">// 피타고라스 정리 -&gt; 중심과의 거리 찾기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; diameter) outimg[i][j]; <span class="comment">// 현재 픽셀의 위치가 입력받은 반지름보다 작으면 모자이크된 이미지를 유지</span></span><br><span class="line"><span class="keyword">else</span> outimg[i][j] = img[i][j]; <span class="comment">// 그렇지 않으면 원본이미지를 대입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 함수는 원하는 좌표와 반지름을 매개변수로 받아 해당하는 위치에 모자이크 처리를 수행하는 함수이다. mosaic함수는<a href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/12/ImageProcessing2.html">이전 포스팅</a>에서 사용했던 함수이고 circle이미지를 제작할 때 사용했던 방식으로 작성하였다. 위의 함수를 이용하면 다음과 같은 이미지도 출력이 가능하다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/partMosaic.png" style="width: 512px    ; height: 512px;"></div>부분 모자이크(300,350) (diameter=100, block=8)## 응용<p>이번엔 원형이 아닌 사각형 이미지를 생성하는 함수와 그 함수를 응용하여 사각형으로 부분 모자이크를 수행하는 함수이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Square</span><span class="params">(uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">double</span> diameter)</span> <span class="comment">// 사각형 이미지 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> tmp;</span><br><span class="line">diameter = diameter / <span class="number">2</span>; <span class="comment">// 사각형의 한변의 길이를 입력받았으므로 1/2 해줌</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= (Row / <span class="number">2</span>) - diameter &amp;&amp; i &lt;= (Row / <span class="number">2</span>) + diameter &amp;&amp; j &gt;= (Col / <span class="number">2</span>) - diameter &amp;&amp; j &lt;= (Col / <span class="number">2</span>) + diameter)</span><br><span class="line">Result[i][j] = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span> Result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SquareMosaic</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> diameter, <span class="keyword">int</span> block)</span> <span class="comment">// 사각형 부분 모자이크</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">diameter = diameter / <span class="number">2</span>; <span class="comment">// 사각형의 한 변의 길이를 입력받았으므로 1/2 해줌</span></span><br><span class="line"></span><br><span class="line">mosaic(img, outimg, Row, Col, block);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= x - diameter &amp;&amp; i &lt;= x + diameter &amp;&amp; j &gt;= y - diameter &amp;&amp; j &lt;= y + diameter) <span class="comment">// 사각형 범위 지정</span></span><br><span class="line">outimg[i][j]; <span class="comment">// 사각형 내부는 모자이크 이미지 유지</span></span><br><span class="line"><span class="keyword">else</span> outimg[i][j] = img[i][j]; <span class="comment">// 사각형 외부를 원본 대입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사각형의 한 변의 길이를 입력받아 사각형 이미지 및 사각형 부분 모자이크를 수행하며 결과는 다음과 같다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/square.png" style="width: 512px    ; height: 512px;"></div>Square Image (diameter=200)<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenasquare.png" style="width: 512px    ; height: 512px;"></div>사각형 부분 모자이크(300,300) (diameter=150, block=8)<p>위와 같이 사각형 모양으로도 부분 모자이크를 구현할 수 있다. 영상처리에서 논리 연산은 원하는 영상의 모양을 얻거나 제거하기 위한 기법으로 사용되며 얼굴에서 치아나 눈 등 특별히 보고 싶은 부분이 있다면 특정한 영상을 이용하여 원하는 결과 영상을 얻을 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;논리-연산&quot;&gt;&lt;a href=&quot;#논리-연산&quot; class=&quot;headerlink&quot; title=&quot;논리 연산&quot;&gt;&lt;/a&gt;논리 연산&lt;/h2&gt;&lt;p&gt;영상을 처리하기 위하여 단순하게 수를 더하거나 빼는 연산만을 수행하는 것이 아니라 영상에 대하여 논리적인
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - Add Noise</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing5/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing5/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:10.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Add-Noise"><a href="#Add-Noise" class="headerlink" title="Add Noise"></a>Add Noise</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">uniform</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span>((<span class="keyword">double</span>)(rand() &amp; RAND_MAX) / RAND_MAX - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gaussian</span><span class="params">()</span> <span class="comment">// 가우시안 난수 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="built_in">ready</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> gstore;</span><br><span class="line"><span class="keyword">double</span> v1, v2, r, fac, gaus;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">uniform</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ready</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v1 = <span class="number">2.</span> * uniform();</span><br><span class="line">v2 = <span class="number">2.</span> * uniform();</span><br><span class="line">r = v1 * v1 + v2 * v2;</span><br><span class="line">&#125; <span class="keyword">while</span> (r &gt; <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">fac = <span class="built_in">sqrt</span>(<span class="number">-2.</span> * <span class="built_in">log</span>(r) / r);</span><br><span class="line">gstore = v1 * fac;</span><br><span class="line">gaus = v2 * fac;</span><br><span class="line"><span class="built_in">ready</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ready</span> = <span class="number">0</span>;</span><br><span class="line">gaus = gstore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(gaus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddNoise</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// 가우시안 난수를 더해 잡음 생성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"></span><br><span class="line">outimg[i][j] = img[i][j] + gaussian() * <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 가우시안 난수를 생성하는 함수와 그 함수를 이용하여 이미지에 잡음을 더해주는 함수이다. 위의 함수를 사용할 때 메인 함수에 srand(time(NULL)); 를 넣어주어야 랜덤 값이 정상적으로 발생한다. 아래는 가우시안 랜덤 잡음에 lena영상을 더하여 얻은 잡음가산 영상이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lenanoise.png" style="width: 512px    ; height: 512px;"></div><p>영상의 원 값에 화소별로 랜덤 잡음을 더하여 그 결과 값으로 얻은 것으로 잡음이 심한 가우시안 잡음은 제거하는 것이 매우 어렵다. 영상에 더해진 잡음이 가우시안 잡음처럼 평균이 0인 값이라면 잡음 영상을 계속적으로 더해 좋은 결과 영상을 얻을 수 있다.</p><p>다음의 코드를 보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RmNoise</span><span class="params">(uchar** img, <span class="keyword">int</span>** tempimg, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> count)</span> <span class="comment">// 잡음영상을 더해 잡음 제거</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; count; k++) &#123; <span class="comment">// count : 잡음영상 더할 횟수</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">tempimg[i][j] += (img[i][j] + gaussian() * <span class="number">50</span>);</span><br><span class="line"><span class="comment">// unsigned char 는 0~255 의 값만을 지니기 때문에</span></span><br><span class="line"><span class="comment">// int형으로 선언하여 누적시킴</span></span><br><span class="line"><span class="comment">//printf("%lf\n", gaussian() * 50);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">temp = tempimg[i][j] / count; <span class="comment">// 누적 값을 평균내어 temp에 저장</span></span><br><span class="line"><span class="comment">//printf("temp : %d\n", temp);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span>) <span class="comment">// clipping</span></span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="number">0</span>;</span><br><span class="line">outimg[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; <span class="number">255</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="number">255</span>;</span><br><span class="line">outimg[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">outimg[i][j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("outimg[i][j] : %d\n", outimg[i][j]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 잡음 영상을 입력받은 count값만큼 더하여 평균을 낸 영상을 구하는 함수이다. 다음은 위의 함수를 사용하여 각각 잡음 5개, 20개, 50개를 더한 영상이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/noise5.png" style="width: 512px    ; height: 512px;"></div>5개를 더한 결과 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/noise20.png" style="width: 512px    ; height: 512px;"></div>20개를 더한 결과 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/noise50.png" style="width: 512px    ; height: 512px;"></div>50개를 더한 결과 영상<p>위의 영상들과 같이 잡음 영상을 많이 더할수록 잡음을 더 잘 제거하는 모습을 확인할 수 있다. 잡음 영상을 단순한 가산연산으로 처리하는 방식이 좋은 결과를 나타내는 경우가 많이 있는데 그것은 잡음이 원 영상과 상관관계가 없는 경우의 가산 잡음인 경우에 해당된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Add-Noise&quot;&gt;&lt;a href=&quot;#Add-Noise&quot; class=&quot;headerlink&quot; title=&quot;Add Noise&quot;&gt;&lt;/a&gt;Add Noise&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 히스토그램</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing7/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing7/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:18.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="히스토그램"><a href="#히스토그램" class="headerlink" title="히스토그램"></a>히스토그램</h2><p>영상에서의 히스토그램은 그레이레벨 값 k개의 개수가 영상 전체 안에서 몇 개가 존재하는지를 알려주는 값이다. 즉, 그레이레벨 값 0부터 255까지가 영상 전체에서 몇 개씩 존재하는가를 알려주는 지표 값이다. 히스토그램은 영상의 그레이레벨의 프로파일(profile)을 보여주는 기능을 한다고 생각하면 된다. 그러나 영상의 크기가 다양하기 때문에 개수만으로 표현하는 경우 그 개수의 정확성에 문제가 발생할 수 있으므로 영상전체 화소수로 나누어 확률적인 표현으로 나타낸다. 즉, k번째 개수가 Nk개인 경우 Nk/(Row*Col)와 같이 전체 화소수로 나누어 k 의 그레이 레벨이 갖는 개수를 표현한 것을 히스토그램이라 한다.</p><div style="width: 600px; height: 1000px;">    <img src="https://kyu9341.github.io/img/his.png" style="width: 600px    ; height: 1000px;"></div><p>위의 이미지들은 각각 lena.512의 원본과 각각 gamma collection을 통해 gamma값을 3, 0.45로 지정하여 밝고 어둡게 만든 영상들의 히스토그램이다. 원본의 히스토그램을 보면 0부터 255까지의 값이 존재하나 0과 255의 근처에는 값이 거의 없는 것을 볼 수 있으며 전체적으로 고르게 히스토그램이 분포한 것을 확인할 수 있다. 반면, 밝은 영상에서는 밝은 값들이 많기 때문에 우측으로 치우친 것을 확인할 수 있고 어두운 영상에서는 밝은 값들이 적고 상대적으로 어두운 값들이 많기 때문에 주로 좌측으로 분포한 것을 확인할 수 있다.</p><div style="width: 600px; height: 1000px;">    <img src="https://kyu9341.github.io/img/his1.png" style="width: 600px    ; height: 1000px;"></div><p>위의 이미지들은 각각 카메라맨, 페퍼, 페이스 이미지들과 히스토그램이다. 각각의 이미지와 히스토그램을 보면 이미지의 값들에 따른 히스토그램이 나타나는 것을 알 수 있다. Camera Man의 경우에는 밝은 배경과 어두운 사람의 옷 때문에 밝은 부분의 값과 어두운 부분의 값이 각각 많이 분포해 독특하게 나타나는 것을 볼 수 있다. 이런 영상의 경우에는 전체적인 콘트라스트를 개선하는데 어려움이 존재한다. 다음으로 Pepper는 보는 것과 같이 고르게 분포되어 있는 것을 알 수 있고 Face는 전체적으로 밝은 영상이므로 밝은 부분에 몰려있는 것을 확인 할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;히스토그램&quot;&gt;&lt;a href=&quot;#히스토그램&quot; class=&quot;headerlink&quot; title=&quot;히스토그램&quot;&gt;&lt;/a&gt;히스토그램&lt;/h2&gt;&lt;p&gt;영상에서의 히스토그램은 그레이레벨 값 k개의 개수가 영상 전체 안에서 몇 개가 존재하는지를 알려주는 값이
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 공간 필터링</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing9/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing9/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:27.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spatial-Filtering-공간-필터링"><a href="#Spatial-Filtering-공간-필터링" class="headerlink" title="Spatial Filtering (공간 필터링)"></a>Spatial Filtering (공간 필터링)</h2><p>영상처리에서 필터링은 영상 내에서 특별히 원하는 성분을 추출해내는 과정에 대한 용어이다. 필터링은 크게 두 가지로 나뉘는데 하나는 저주파 필터링이고 하나는 고주파 필터링이다. 필터링의 용어는 모두 주파수 영역에서 다루는 용어를 그대로 사용한다. 공간필터링이라는 용어는 영상을 입력으로 하여 출력을 영상으로 내어주는 공간상에서의 결과를 보여주는데 따른 용어이다.</p><h3 id="Spatial-Smoothing-Filtering"><a href="#Spatial-Smoothing-Filtering" class="headerlink" title="Spatial Smoothing Filtering"></a>Spatial Smoothing Filtering</h3><p>공간필터링의 처음은 저주파 필터링의 특징을 보여주는 Smoothing Filtering이라고도 한다. 일반적으로 평균을 취하는 형태로 그 결과를 얻을 수 있으며 주파수 상에서의 처리가 아닌 경우 지정된 필터를 사용하여 영상처리를 수행한다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/gaussainFiltering.png" style="width: 800px    ; height: 400px;"></div><p>위의 영상은 가우시안 스무딩 필터를 적용하여 얻은 결과이다. 스무딩 필터의 특징은 영상 내 잡음제거가 주요한 목적이며 고주파 성분을 제거하여 화면을 부드럽게 만들어주는 것이 특징이다.</p><div style="width: 400px; height: 200px;">    <img src="https://kyu9341.github.io/img/filter.png" style="width: 400px    ; height: 200px;"></div><p>위의 표는 각각 가우시안 필터와 평균 필터인데 평균 필터는 모두 같은 값으로 나누는 반면, 가우시안 필터는 가운데 부분의 값을 좀 더 큰 값으로 할당하여 중심 값을 보존하면서 주변의 값에 대한 평균을 취하는 형태로, 원본 형태가 살아있는 부드러운 결과 영상을 보여준다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/averagelena.png" style="width: 800px    ; height: 400px;"></div><p>위의 영상은 3x3 Average Filter를 사용한 결과 영상이며 3x3 윈도우 내의 평균값에 대한 영상의 결과의 부드러움이 아주 약하게 나타나는 것을 알 수 있다. 윈도우 크기에 따라 스무딩 효과의 차이가 크게 나타나며 이러한 결과는 어떤 필터를 사용하는가에 따라 그 결과가 확연히 달라진다.<br> 영상 필터링을 위한 처리에서 중요한 요소 중의 하나가 외곽 부분에 대한 처리이다. 일반적으로 영상의 외곽 부분에 대한 처리는 크게 3가지로 구분할 수 있다.</p><ol><li>주변에 0을 채워 넣어 영상 외곽 부분의 값을 0이라 가정하고 필터링을 수행<br>(zero padding)</li><li>대칭되는 영상이 계속적으로 존재한다는 가정 하에 영상의 외곽부분을 처리(대칭 기법)</li><li>영상이 회선의 특징을 가지고 반복된다는 가정 하에 영상의 외곽부분을 처리<br>어떤 방법을 사용하던지 영상의 외곽 경계선 영역 몇 칸에 대한 처리이기 때문에 영상의 선명도에는 커다란 영향을 미치지 않는다. 그렇지만 최종적으로 원하는 결과를 얻기 위해서는 어떤 방법을 사용할지에 대해 고민해야 할 것이다.</li></ol><p>다음은 각각 jet image와 livingroom image에 가우시안 필터와 평균 필터를 적용시킨 모습이다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/jetga.png" style="width: 800px    ; height: 400px;"></div><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/livingroomGA.png" style="width: 800px    ; height: 400px;"></div><p>가우시안 필터링과 스무딩 필터링의 차이는 필터 계수의 값에 의한 원본 영상의 영향이라고 생각하면 된다. 기본적으로 스무딩 필터는 원 영상을 뭉개는 효과가 나타나기 때문에 전체적인 모양은 흐릿한 결과를 보여주게 되는데 이러한 특성 때문에 잡음 제거를 위하여 많이 사용한다.</p><p>다음의 코드는 가우시안 필터와 평균 필터를 사용하는 코드이며 그 아래의 코드는 컨볼루션을 수행하는 코드이다. 잠깐 컨볼루션에 대해 알아보겠다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mod == <span class="number">10</span>) <span class="comment">// Average nad Gaussian Filtering</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag = 0 -&gt; Gaussian Filtering\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag = 1 -&gt; Average Filtering\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag : "</span>); <span class="comment">// 0 : Gaussian , 1 : Average</span></span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;flag);</span><br><span class="line"></span><br><span class="line">gaussMask = d_alloc(block_size, block_size);</span><br><span class="line">aveMask = d_alloc(block_size, block_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//gaussian mask 설정</span></span><br><span class="line">gaussMask[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">4</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">2</span> / <span class="number">16.</span>;</span><br><span class="line">gaussMask[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span> / <span class="number">16.</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// average mask 설정</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">aveMask[i][j] = <span class="number">1</span> / <span class="number">9.</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Start Simple Filtering \n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">convolution(gaussMask, block_size, Col, Row, img, outimg);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">convolution(aveMask, block_size, Col, Row, img, outimg);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"flag must be 0 or 1 \n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Finished Simple Filtering \n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convolution</span><span class="params">(<span class="keyword">double</span>** h, <span class="keyword">int</span> F_length, <span class="keyword">int</span> size_x, <span class="keyword">int</span> size_y, uchar** image1, uchar** image2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  컨볼루션 계산은 마스크와 이미지 상에 대응되는 값끼리 곱하여 모두 더하여 구하며, 결과값을 결과 영상의 현재 위치에 기록</span></span><br><span class="line"><span class="keyword">int</span> i, j, x, y;</span><br><span class="line"><span class="keyword">int</span> margin, indexX, indexY;</span><br><span class="line"><span class="keyword">double</span> sum, coeff;</span><br><span class="line"></span><br><span class="line">margin = (<span class="keyword">int</span>)(F_length / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_y; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size_x; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; F_length; y++)</span><br><span class="line">&#123;</span><br><span class="line">indexY = i - margin + y;</span><br><span class="line"><span class="keyword">if</span> (indexY &lt; <span class="number">0</span>) indexY = -indexY;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (indexY &gt;= size_y) indexY = (<span class="number">2</span> * size_y - indexY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; F_length; x++)</span><br><span class="line">&#123;</span><br><span class="line">indexX = j - margin + x;</span><br><span class="line"><span class="keyword">if</span> (indexX &lt; <span class="number">0</span>) indexX = -indexX;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (indexX &gt;= size_x) indexX = (<span class="number">2</span> * size_x - indexX - <span class="number">1</span>); <span class="comment">// 외곽 처리 (대칭 기법(시메트릭)??)</span></span><br><span class="line"></span><br><span class="line">sum += h[y][x] * (<span class="keyword">double</span>)image1[indexY][indexX]; <span class="comment">// 마스크의 각 값을 이미지의 픽셀 값과 곱하여 모두 더해준다.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum += 128; // 양각 효과를 보기 위해 추가 -&gt; 이부분만 다름</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clipping</span></span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0.</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">255</span>) sum = <span class="number">255</span>;</span><br><span class="line">image2[i][j] = (uchar)sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Convolution-합성곱"><a href="#Convolution-합성곱" class="headerlink" title="Convolution (합성곱)"></a>Convolution (합성곱)</h2><p>Convolution은 합성곱이라는 뜻이다. 특정한 크기의 필터를 사용하여 이미지의 각 픽셀을 지나가며 필터의 위치에 해당하는 픽셀과 모두 곱한 후 그 곱한 값을 모두 더하여 현재 중앙 픽셀 값에 넣어주는 것이다.</p><div style="width: 512px; height: 256px;">    <img src="https://kyu9341.github.io/img/convolution1.png" style="width: 512px    ; height: 256px;"></div><p>위의 그림처럼 이미지에서 합성곱이란, 필터를 이동시켜가며 이미지와 곱한 결과를 모두 더하는 것인데, 이러한 필터를 어떤 값을 넣어 사용하느냐에 따라 이미지의 색상, 밝기, 엣지 추출등 여러 가지 기능을 수행할 수 있다. 또한 필터는 주로 커널이라고 부르기도 한다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/splena.png" style="width: 512px    ; height: 512px;"></div><h3 id="Median-Filter-미디안-필터"><a href="#Median-Filter-미디안-필터" class="headerlink" title="Median Filter (미디안 필터)"></a>Median Filter (미디안 필터)</h3><p>미디언 필터링은 비선형 필터로 수학적인 증명이 가능한 필터가 아니다. 수학적으로 증명이 어렵다는 이야기는 그 결과를 예측할 수 없는 이상한 방향으로 갈 수 있다는 뜻이기도 하다. 미디언 필터링이라는 용어는 영상의 중간 값을 결과로 취하기 때문에 붙여진 이름이다. 미디언 필터는 Max Filter, Min Filter와 더불어 영상 내에 존재하는 값을 이용하여 결과를 얻는 대표적인 비선형 필터이다. 영상 내에서 3x3, 혹은 5x5와 같은 윈도우 크기를 정하여 그 크기 안에 있는 영상의 순서를 가장 작은 수부터 큰 수까지 정렬을 수행하여 그 결과의 중간 값을 원하는 결과 값으로 대체하는 필터링 기법이다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/3355lena.png" style="width: 800px    ; height: 400px;"></div><p>미디언 필터링은 salt-and-pepper 잡음에 강한 특성을 가지고 있어서 영상 내 잡음 성분이 salt-and-pepper 잡음 성분인 경우 다른 어떤 필터링 결과보다 우수한 결과를 보여준다.</p><p>위의 영상을 보면 salt-and-pepper 잡음이 있는 lena영상에 대해 미디언 필터링을 수행한 결과 존재하던 잡음이 거의 사라진 것을 볼 수 있으며 5x5의 커널로 미디언 필터링을 수행한 결과를 보면 하얀 점이나 검은 점은 보이지 않으나 영상에 전체적으로 더 많은 스무딩 현상이 발생한 것을 확인할 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(uchar* Sort, uchar* median_value, <span class="keyword">int</span> Mode, <span class="keyword">int</span> filterSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, x;</span><br><span class="line">uchar temp, swap;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; filterSize * filterSize; x++)</span><br><span class="line">&#123;</span><br><span class="line">temp = Sort[x];</span><br><span class="line"><span class="keyword">for</span> (i = x; i &lt; filterSize * filterSize - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt;= Sort[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap = temp;</span><br><span class="line">temp = Sort[i + <span class="number">1</span>];</span><br><span class="line">Sort[i + <span class="number">1</span>] = swap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Sort[x] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Mode == <span class="number">-1</span>)</span><br><span class="line">* median_value = (uchar)Sort[<span class="number">0</span>]; <span class="comment">// median filter의 중앙값을 필터내의 최솟값으로 설정</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Mode == <span class="number">0</span>)</span><br><span class="line">* median_value = (uchar)Sort[filterSize * filterSize / <span class="number">2</span>]; <span class="comment">// median filter의 중앙값을 필터내의 중간값으로 설정</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Mode == <span class="number">1</span>)</span><br><span class="line">* median_value = (uchar)Sort[filterSize * filterSize - <span class="number">1</span>]; <span class="comment">// median filter의 중앙값을 필터내의 최대값으로 설정</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">median</span><span class="params">(uchar** inImg, uchar** outImg, <span class="keyword">int</span> ROW, <span class="keyword">int</span> COL, <span class="keyword">int</span> Mode, <span class="keyword">int</span> filterSize)</span> <span class="comment">// Median Filtering</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, x, y, z, count = <span class="number">0</span>;</span><br><span class="line">uchar median_value; <span class="comment">// 필터의 중앙값</span></span><br><span class="line">uchar* Sort;</span><br><span class="line">Sort = (uchar*)<span class="built_in">malloc</span>(filterSize * filterSize * <span class="keyword">sizeof</span>(uchar)); <span class="comment">// 필터의 마스크값을 정렬해 저장할 포인터 배열 동적할당</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">outImg[i][j] = inImg[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ROW - filterSize; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; COL - filterSize; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; filterSize; x++)</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; filterSize; y++)</span><br><span class="line">Sort[filterSize * x + y] = inImg[i + x][j + y];</span><br><span class="line">Bubble_sort(Sort, &amp;median_value, Mode, filterSize);</span><br><span class="line">outImg[i + <span class="number">1</span>][j + <span class="number">1</span>] = median_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(Sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 미디언 필터링을 수행하는 함수이다. 입력받은 필터사이즈에 따라 메모리를 할당하여 필터를 생성하고 버블 정렬 알고리즘을 통해 정렬을 수행하여 중간 값을 찾아낸다. 또한 Max필터와 Min필터도 구현이 되어있는데 Max, Min 필터는 미디언 필터와 같이 순서에 기반한 필터로 필터 내의 최댓값, 최솟값을 결과로 취하는 필터이다. salt-and-pepper잡음을 가지는 lena영상에 Max, Min 필터를 적용한 결과는 아래와 같다.</p><div style="width: 800px; height: 400px;">    <img src="https://kyu9341.github.io/img/splenamaxmin.png" style="width: 800px    ; height: 400px;"></div><p>위의 필터링 결과를 보면 알 수 있듯이 잘못 사용한 필터는 수용하기 힘든 결과를 나타내기도 한다. Max Min 필터가 성능이 나쁜 것이 아니라 현재 잡음 상태에 적절하지 않은 것이다. 모든 필터링은 그 특성에 맞는 작업을 수행하기에 가장 적합한 필터를 찾는 것이 중요하다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spatial-Filtering-공간-필터링&quot;&gt;&lt;a href=&quot;#Spatial-Filtering-공간-필터링&quot; class=&quot;headerlink&quot; title=&quot;Spatial Filtering (공간 필터링)&quot;&gt;&lt;/a&gt;Spatial Filt
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 콘트라스트 스트레칭(Contrast Streching)</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing8/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/12/01/ImageProcessing8/</id>
    <published>2019-12-01T07:05:53.000Z</published>
    <updated>2019-12-27T06:41:22.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="콘트라스트-스트레칭"><a href="#콘트라스트-스트레칭" class="headerlink" title="콘트라스트 스트레칭"></a>콘트라스트 스트레칭</h2><p>콘트라스트 스트레칭은 히스토그램의 분포가 얼마나 넓게 퍼져 있는가에 따라 인간의 시각 체계가 선명하게 영상을 인식하는 과정에 대한 작업이다. 밝은 화소와 어두운 화소들의 분포가 고르게 퍼져 있어야 인간은 영상을 선명하게 인식하므로 영상의 화소 분포가 좀 더 넓은 영역에 걸쳐서 퍼지도록 스트레칭 시키는 작업이다. 히스토그램 평활화는 히스토그램의 전체적인 분포를 중심으로 동작하나 콘트라스트 스트레칭은 콘트라스트가 너무 높거나 낮은 영상에 대하여 콘트라스트를 넓게 펴주는 작업을 수행하는 히스토그램 평활화의 일종이라고 보면 된다.<br>콘트라스트 스트레칭을 수행하는 수식은 아래와 같이 정의한다.</p><div style="width: 512px; height: 80px;">    <img src="https://kyu9341.github.io/img/contrast.png" style="width: 512px    ; height: 80px;"></div><p>새로운 화소 값은 영상내의 히스토그램을 구한 결과 값에서 가장 큰 값과 가장 작은 값을 구한 후, 기존의 화소 값에서 가장 작은 값을 뺀 결과에 최댓값을 곱해서 구한다. 이 때 최댓값과 최솟값의 범위가 좁을수록 콘트라스트 스트레칭이 잘 일어난다. 콘트라스트 스트레칭은 일반 영상에 적용하는 경우, 즉 최솟값이 0이고 최댓값이 255인 경우 효과를 보기 어려운 기법이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/light.png" style="width: 512px    ; height: 512px;"></div><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lightcontrast.png" style="width: 512px    ; height: 512px;"></div>위의 영상은 밝은 레나 영상에 콘트라스트 스트레칭을 적용한 결과이다. 밝은 레나 영상의 최솟값은 115, 최댓값은 248이다. 최솟값이 큰 값을 가지고 있어 히스토그램이 밝은 영역으로 치우친 영상의 모양으로 콘트라스트 스트레칭 결과 영상이 보기에도 선명하고 좋은 결과를 보여주는 것을 알 수 있다.<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lightcontrasthisto.png" style="width: 512px    ; height: 512px;"></div><p>위의 히스토그램을 보면 알 수 있듯이 최솟값과 최댓값이 스트레칭되어 각각 0과 255를 가지도록 변화한 것을 볼 수 있다.</p><div style="width: 512px; height: 256px;">    <img src="https://kyu9341.github.io/img/cmancontrast.png" style="width: 512px    ; height: 256px;"></div><div style="width: 512px; height: 256px;">    <img src="https://kyu9341.github.io/img/jetcontrast.png" style="width: 512px    ; height: 256px;"></div>위의 영상들은 각각 카메라맨과 제트기 영상에 대하여 콘트라스트 스트레칭을 수행한 결과이다. 카메라맨 영상은 0부터 255까지의 값을 모두 가지고 있어 그 결과가 거의 변한 것이 없으나 제트기 영상은 15부터 231의 값을 가지므로 원 영상보다 선명한 결과를 보여준다. 콘트라스트 스트레칭은 영상이 가지는 그레이 레벨의 값이 0부터 255로 변화되며 영상이 가지는 그레이 레벨 값을 모두 펼쳐주는 역할을 한다.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contrastStreching</span><span class="params">(uchar** img, uchar** outimg, <span class="keyword">int</span> X_Size, <span class="keyword">int</span> Y_Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, histogram[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">255</span>, <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">uchar LUT[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">double</span> scaleFactor, tmp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">histogram[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Y_Size; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; X_Size; j++)</span><br><span class="line">&#123;</span><br><span class="line">histogram[img[i][j]]++; <span class="comment">// 영상의 히스토그램을 구함</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="comment">// 히스토그램의 최솟값을 구함</span></span><br><span class="line"><span class="keyword">if</span> (histogram[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">min</span> = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">255</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 히스토그램의 최댓값을 구함</span></span><br><span class="line"><span class="keyword">if</span> (histogram[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">max</span> = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Low Threshold is %d High Threshold is %d\n"</span>, <span class="built_in">min</span>, <span class="built_in">max</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>; i++)</span><br><span class="line">LUT[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">255</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">LUT[i] = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">scaleFactor = <span class="number">255.0</span> / (<span class="keyword">double</span>)(<span class="built_in">max</span> - <span class="built_in">min</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="built_in">min</span>; i &lt; <span class="built_in">max</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = (i - <span class="built_in">min</span>) * scaleFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; <span class="number">255</span>) tmp = <span class="number">255</span>;</span><br><span class="line">LUT[i] = (uchar)tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Y_Size; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; X_Size; j++)</span><br><span class="line">outimg[i][j] = LUT[img[i][j]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 콘트라스트 스트레칭을 수행하는 함수이며 영상내의 히스토그램을 구해 최솟값과 최댓값을 각각 구해 위의 수식을 적용시키는 구조로 작성되었다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;콘트라스트-스트레칭&quot;&gt;&lt;a href=&quot;#콘트라스트-스트레칭&quot; class=&quot;headerlink&quot; title=&quot;콘트라스트 스트레칭&quot;&gt;&lt;/a&gt;콘트라스트 스트레칭&lt;/h2&gt;&lt;p&gt;콘트라스트 스트레칭은 히스토그램의 분포가 얼마나 넓게 퍼져 있는가에 
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - Bit Plane</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/29/ImageProcessing4/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/29/ImageProcessing4/</id>
    <published>2019-11-29T02:01:22.000Z</published>
    <updated>2019-12-27T06:41:05.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bit-Plane"><a href="#Bit-Plane" class="headerlink" title="Bit Plane"></a>Bit Plane</h2><p>표준 디지털 영상은 8bits로 구성되어 0부터 255까지의 값을 가지고 있는 구조이다. 256레벨의 그레이 스케일 값이라고 표현하기도 하는데 이진영상을 위에서 구성한 것과 같이 각 bit위치에서의 영상을 독립된 영상으로 표현하는 방법을 알아본다. 영상은 8개의 bit plane으로 구성되어 있으며 최상위 비트가 1인 경우 128보다 큰 값을 가지게 되고 바로 하위 비트가 1인 경우는 64보다 큰 값을 갖는 구조를 가지고 있다. 각 위치에서의 비트가 1인 경우 영상 값이 존재하는 표시인 255로 표시하여 화면에 보여주고 0인 경우 0으로 표현하여 이진 영상으로 각 bit plane을 표현한다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitSlicing</span><span class="params">(uchar** img, uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> <span class="built_in">position</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 해당 position 값에 맞는 mask값을 통해 이미지를 구함</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">uchar mask = <span class="number">0x01</span>;</span><br><span class="line">mask &lt;&lt;= <span class="built_in">position</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Row;i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; img[i][j]) == <span class="built_in">pow</span>(<span class="number">2</span>, <span class="built_in">position</span>)) <span class="comment">//pow(2, position) = mask</span></span><br><span class="line">&#123;</span><br><span class="line">Result[i][j] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 position값에 따라 해당하는 bit palne의 이미지를 생성하는 코드이다.</p><div style="width: 700px; height: 800px;">    <img src="https://kyu9341.github.io/img/lenabitplane.png" style="width: 700px    ; height: 800px;"></div><p>위의 이미지는 Bit Plane 8장에 대한 영상결과를 보여준다. 각각의 비트가 1인 경우 255로 표현하여 이진화된 영상을 보여준다.</p><h2 id="ImageCombine"><a href="#ImageCombine" class="headerlink" title="ImageCombine"></a>ImageCombine</h2><p>이진화된 비트 영상은 비트의 정보만으로 영상이 얼마나 많은 정보를 가지고 있는지를 알 수 있다. 이러한 비트 정보를 몇 개를 모아야 사람이 보기에 지장이 없는지 확인해보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageCombine</span><span class="params">(uchar** img, uchar** tmpimg, uchar** outimg, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> <span class="built_in">position</span>, <span class="keyword">int</span> direction)</span> <span class="comment">// 7부터 position까지의 비트이미지를 합성</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line">uchar mask = <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">1</span>) <span class="comment">// 7부터 position까지 합성</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">7</span>; k &gt; <span class="number">7</span> - <span class="built_in">position</span>; k--) <span class="comment">// 7부터 입력받은 장수까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line">mask &lt;&lt;= k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) <span class="comment">// BitSlicing</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; img[i][j]) == mask) <span class="comment">//pow(2, position) = mask</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outimg[i][j] += tmpimg[i][j] &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line">mask = <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br><span class="line">average(outimg, Row, Col);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 비트슬라이싱된 이미지에 해당 mask를 and연산 하는 이유</span></span><br><span class="line"><span class="comment"> 해당 비트값만 255로 변환하고 나머지는 0으로 변환했기 때문에</span></span><br><span class="line"><span class="comment"> 즉 255 : 0b1111111 &amp; 0b1000000 =&gt; 0b1000000</span></span><br><span class="line"><span class="comment">    &amp; 0b0100000 =&gt; 0b0100000</span></span><br><span class="line"><span class="comment">와 같이 변환 후 모두 더해줘야 정상적인 값이 나옴.</span></span><br><span class="line"><span class="comment">\*/</span></span><br><span class="line"><span class="keyword">if</span> (direction == <span class="number">2</span>) <span class="comment">// 1부터 position까지 합성</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= <span class="built_in">position</span>; k++) <span class="comment">// 1부터 입력받은 장수까지 반복</span></span><br><span class="line">&#123;</span><br><span class="line">mask &lt;&lt;= k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) <span class="comment">// BitSlicing</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mask &amp; img[i][j]) == mask) <span class="comment">//pow(2, position) = mask</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tmpimg[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) <span class="comment">// BitMasking, MaskAdd</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">outimg[i][j] += tmpimg[i][j] &amp; mask; <span class="comment">// 비트슬라이싱된 tmpimg를 해당 비트의 마스크 값으로 마스킹 후 누적</span></span><br><span class="line">&#125;</span><br><span class="line">mask = <span class="number">0x01</span>; <span class="comment">// 초기화</span></span><br><span class="line">&#125;</span><br><span class="line">average(outimg, Row, Col);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 입력 받은 direction과 position값에 따라 상위 비트 혹은 하위 비트부터 원하는 장수를 더한 이미지를 생성해주는 함수이다. 일일이 각 비트의 이미지를 생성해 더하지 않도록 하기 위해 위와 같이 mask를 쉬프트 연산을 통해 변경하며 각각의 bit에 해당하는 이미지를 누적시켰다. 아래는 위의 함수를 통해 생성한 이미지를 출력한 결과이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lena876.png" style="width: 512px    ; height: 512px;"></div>8, 7, 6bit 합성 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lena8765.png" style="width: 512px    ; height: 512px;"></div>8, 7, 6, 5bit 합성 영상<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/lena12345.png" style="width: 512px    ; height: 512px;"></div>1, 2, 3, 4, 5bit 합성 영상<p>상위 비트부터 많은 비트를 합성할수록 원 영상과 비슷한 결과를 보여주는 것을 알 수 있다. 또한 하위 비트부터 더하면 높은 값을 가지는 bit가 빠져있으므로 전체적으로 어두운 영상을 보여주게 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bit-Plane&quot;&gt;&lt;a href=&quot;#Bit-Plane&quot; class=&quot;headerlink&quot; title=&quot;Bit Plane&quot;&gt;&lt;/a&gt;Bit Plane&lt;/h2&gt;&lt;p&gt;표준 디지털 영상은 8bits로 구성되어 0부터 255까지의 값을 가지고 있
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>ICT멘토링 딥러닝 교육 2일차</title>
    <link href="https://kyu9341.github.io/MachineLearning/2019/11/24/marchinelearning4/"/>
    <id>https://kyu9341.github.io/MachineLearning/2019/11/24/marchinelearning4/</id>
    <published>2019-11-24T01:01:25.000Z</published>
    <updated>2019-12-27T06:40:58.546Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 둘째 날 배운 내용을 리뷰해보겠다. 둘째 날에는 이미지 분류 이론, Azure Cloud GPU활용, Cifar10 이미지 분류에 대해서 배웠다.</p><h3 id="Convolutional-Neural-Network-CNN"><a href="#Convolutional-Neural-Network-CNN" class="headerlink" title="Convolutional Neural Network(CNN)"></a>Convolutional Neural Network(CNN)</h3><p>딥러닝이나 머신러닝 관련 자료들을 보면 자주 등장하던 CNN이다. 주로 이미지를 학습시킨다고 하면 제일 먼저 떠오르는 단어이다.</p><p>CNN(합성곱 신경망)은 필터링 기법을 인공신경망에 적용함으로써 이미지를 더욱 효과적으로 처리하기 위해 고안되었다. 이미지를 Dense(fully connected) Layer로 처리하려 한다면 feature가 너무 많아져 불필요한 weight가 많아지고 효율이 떨어지게 된다. 또한 Dense Layer는 1차원 데이터만 input으로 받을 수 있기 때문에 3차원 데이터를 평탄화하여 입력해야 한다. 여기서 3차원 데이터의 공간적 정보가 소실되는 문제가 발생한다. 반면 Convolutional Layer에서는 형상을 유지한다. 입/출력 모두 3차원 데이터로 처리하기 때문에 공간적 정보를 유지할 수 있다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/cnn.png" style="width: 100%    ; height: 400px;"></div><h4 id="Convolutional-Layer"><a href="#Convolutional-Layer" class="headerlink" title="Convolutional Layer"></a>Convolutional Layer</h4><p>Convolution은 합성곱이라는 뜻이다. 최근에 영상처리 수업을 들으며 등장했던 단어이기 때문에 이해가 잘 되었다. 특정한 크기의 필터를 사용하여 이미지의 각 픽셀을 지나가며 필터의 위치에 해당하는 픽셀과 모두 곱한 후 그 곱한 값을 모두 더하여 현재 중앙 픽셀 값에 넣어주는 것이다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/convolution.png" style="width: 100%    ; height: 400px;"></div>위의 그림처럼 이미지에서 합성곱이란 필터를 이동시켜가며 이미지와 곱한 결과를 모두 더하는 것인데, 이러한 필터를 어떤 값을 넣어 사용하느냐에 따라 이미지의 색상, 밝기, 엣지 추출등 여러가지 기능을 수행할 수 있다. 또한 필터는 주로 커널이라고 부르기도 한다.<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><p>1만큼 패딩했다고 한다면, 입력 데이터 사방 1픽셀을 특정 값으로 채워 늘리는 것을 말한다. 주로 출력 크기를 조정할 목적으로 사용되는데 이를테면 (5, 5)데이터에 (3, 3)필터를 적용하면 출력이 (3, 3)이 된다. 이처럼 합성곱 연산을 거칠 때 마다 크기가 작아지게 되는데 출력 크기가 너무 줄어드는 것을 막기 위해 패딩을 사용한다. 패딩을 사용하면 그만큼 입력 데이터를 그게 만들어 출력 데이터를 입력 데이터와 동일한 형상으로 조정할 수 있으므로 입력 데이터의 공간적 크기를 고정한 채로 다음 계층에 전달할 수 있다.</p><h4 id="Pooling-layer"><a href="#Pooling-layer" class="headerlink" title="Pooling layer"></a>Pooling layer</h4><p>풀링은 가로/세로 방향의 공간을 줄이는 연산이다. 풀링의 종류로는 Max Pooling과 Average Pooling이 있는데 이미지 인식 분야에서는 주로 Max Pooling을 사용한다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/pooling.png" style="width: 100%    ; height: 400px;"></div><ul><li><p>Average pooling : 지정된 구역의 평균값을 가져와 대체함</p></li><li><p>Max pooling layer: 지정된 구역의 가장 큰 값을 가져와 대체함(사소한 정보 차이는 무시)</p><p>    이미지가 가지는 큰 특징을 유지하며 사이즈를 줄임 (특징 일반화 가능)</p><p>    예를 들어 강아지의 종이 다른 경우에도 큰 특징만 가지고 커버가능</p><p>    데이터가 지역적으로 학습되지 않도록 함</p></li></ul><h2 id="실습1"><a href="#실습1" class="headerlink" title="실습1"></a>실습1</h2><p>첫번째는 간단하게 이미지만 불러와서 확인하는 과정이다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN"><a href="#2019-11-24-딥-러닝-과정-CNN" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="준비-실습-Image-살펴보기"><a href="#준비-실습-Image-살펴보기" class="headerlink" title="준비 실습. Image 살펴보기"></a>준비 실습. Image 살펴보기</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. package 가져오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 가져오기</span></span><br><span class="line"></span><br><span class="line">image_gray = Image.open(<span class="string">'01image.png'</span>)</span><br><span class="line">image_color = Image.open(<span class="string">'02image.png'</span>)</span><br><span class="line">image_jet = Image.open(<span class="string">'jet.png'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(image_gray.size)</span><br><span class="line">print(image_gray)</span><br><span class="line"><span class="comment"># print(image_jet)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(image_color.size) <span class="comment"># size만 뽑으면 가로 세로만 나옴</span></span><br><span class="line">print(image_gray.size)</span><br><span class="line"><span class="comment"># print(image_jet.size)</span></span><br></pre></td></tr></table></figure><pre><code>(28, 28)&lt;PIL.PngImagePlugin.PngImageFile image mode=L size=28x28 at 0x1405C55AE08&gt;(32, 32)(28, 28)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 이미지 array로 변환하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image_array = np.array(image_gray)</span><br><span class="line">image_array_color = np.array(image_color)</span><br><span class="line"><span class="comment"># image_array_jet = np.array(image_jet)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(image_array.shape) <span class="comment"># 학습 시킬때 항상 numpy data로 변환하며 shape를 확인해야함</span></span><br><span class="line">print(image_array_color.shape) <span class="comment"># numpy array로 변환하여 출력하면 (32, 32, 3)처럼 뎁스도 출력 가능</span></span><br><span class="line"><span class="comment"># 3차원 데이터여야만 CNN에 넣어서 학습이 가능 따라서 gray scale은 reshape해줘야함</span></span><br><span class="line"><span class="comment"># print(image_array_jet.shape)</span></span><br><span class="line">reshpaed_1d = image_array.reshape(<span class="number">28</span>*<span class="number">28</span>) <span class="comment"># gray image -&gt;reshape</span></span><br><span class="line">reshaped_3d = image_array.reshape(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>) <span class="comment"># gray image -&gt; 3d로 변경하여 cnn이 가능하도록 함</span></span><br><span class="line"></span><br><span class="line">print(reshpaed_1d.shape)</span><br><span class="line">print(reshaped_3d.shape)</span><br></pre></td></tr></table></figure><pre><code>(28, 28)(32, 32, 3)(784,)(28, 28, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. 이미지 살펴보기</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(image_array)</span></span><br><span class="line">print(image_array_color)</span><br><span class="line"><span class="comment"># print(image_array_jet)</span></span><br><span class="line"><span class="comment"># print(reshaped_3d)</span></span><br></pre></td></tr></table></figure><pre><code>[[[125 125 116]  [110 101  91]  [102  90  83]  ...  [202 207 214]  [200 205 212]  [202 208 214]]  ...  [143 117  82]  [143 116  84]  [144 116  86]]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 이미지 시각화</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.imshow(image_array, cmap=plt.cm.gray) <span class="comment"># gray scale를 정상적으로 띄우려면 color map 을 지정해야함</span></span><br><span class="line">plt.imshow(image_array_color)</span><br><span class="line"><span class="comment"># plt.imshow(image_array_jet)</span></span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x1405c59de48&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_6_1.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습2"><a href="#실습2" class="headerlink" title="실습2"></a>실습2</h2><p>두번째 실습은 CNN모델을 적용하기 전에 MLT만 사용하여 이미지를 학습시켜보았다. MLT는 1차원 데이터만 input으로 받을 수 있기 때문에 gray scale의 2차원 데이터는 1차원으로 reshape을 해주어야 학습이 가능하다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-1"><a href="#2019-11-24-딥-러닝-과정-CNN-1" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="첫번째-실습-Keras-모델-생성-학습-MNIST-MLP"><a href="#첫번째-실습-Keras-모델-생성-학습-MNIST-MLP" class="headerlink" title="첫번째 실습. Keras 모델 생성/학습 - MNIST : MLP"></a>첫번째 실습. Keras 모델 생성/학습 - MNIST : MLP</h3><p><a href="https://keras.io/ko/datasets/#mnist" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist  <span class="comment"># 많이 쓰이는 데이터 케라스에서 제공</span></span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(60000, 28, 28)(60000,)(10000, 28, 28)(10000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap=plt.cm.gray)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x12a2b101c48&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X_train.shape) <span class="comment"># 28*28 이미지 (2차원) 6만개 -&gt; 1차원 6만개</span></span><br></pre></td></tr></table></figure><pre><code>(60000, 28, 28)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. 이미지 데이터 전처리 : 2차원-&gt;1차원 🌟🌟🌟</span></span><br><span class="line"></span><br><span class="line">X_train = X_train.reshape((<span class="number">60000</span>, <span class="number">28</span> * <span class="number">28</span>)) <span class="comment"># -&gt; 1차원 6만개로 변환</span></span><br><span class="line">X_test = X_test.reshape((<span class="number">10000</span>, <span class="number">28</span> * <span class="number">28</span>))</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line"></span><br><span class="line">print(X_train)</span><br></pre></td></tr></table></figure><pre><code>(60000, 784)(10000, 784)[[0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] ... [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. 이미지 데이터 전처리 : Normalzation</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">print(X_train[<span class="number">9</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label 전처리 (one-hot encoding)</span></span><br><span class="line">print(y_train[:<span class="number">10</span>]) <span class="comment"># 앞에서 10개, label : 숫자가 어떤 숫자인지</span></span><br></pre></td></tr></table></figure><pre><code>[5 0 4 1 9 2 1 3 1 4]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label 전처리 (one-hot encoding)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[[0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4-1 Validation 셋 나누기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                    test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                    random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line"></span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 784)(48000, 10)(12000, 784)(12000, 10)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : MLP</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">512</span>, input_dim=<span class="number">784</span>, activation=<span class="string">'relu'</span>)) <span class="comment"># 다음 노드의 수 : 512(inputdata가 784이므로 적당히 크게)</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)) <span class="comment"># 출력 층 10개중 어떤건지 알기 위해 10으로 지정</span></span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_6&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_9 (Dense)              (None, 512)               401920    _________________________________________________________________dense_10 (Dense)             (None, 10)                5130      =================================================================Total params: 407,050Trainable params: 407,050Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size=<span class="number">128</span></span><br><span class="line">epochs=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">         epochs=epochs,</span><br><span class="line">         batch_size=batch_size,</span><br><span class="line">         validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">         verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 48000 samples, validate on 12000 samplesEpoch 1/1048000/48000 [==============================] - 2s 37us/step - loss: 1.2137 - accuracy: 0.7386 - val_loss: 0.6995 - val_accuracy: 0.8526Epoch 2/1048000/48000 [==============================] - 2s 34us/step - loss: 0.5725 - accuracy: 0.8683 - val_loss: 0.4960 - val_accuracy: 0.8789Epoch 3/1048000/48000 [==============================] - 2s 42us/step - loss: 0.4501 - accuracy: 0.8855 - val_loss: 0.4243 - val_accuracy: 0.8904Epoch 4/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3967 - accuracy: 0.8948 - val_loss: 0.3847 - val_accuracy: 0.8984Epoch 5/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3648 - accuracy: 0.9019 - val_loss: 0.3599 - val_accuracy: 0.9035Epoch 6/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3425 - accuracy: 0.9064 - val_loss: 0.3419 - val_accuracy: 0.9077Epoch 7/1048000/48000 [==============================] - 2s 38us/step - loss: 0.3257 - accuracy: 0.9103 - val_loss: 0.3276 - val_accuracy: 0.9109Epoch 8/1048000/48000 [==============================] - 2s 40us/step - loss: 0.3121 - accuracy: 0.9145 - val_loss: 0.3155 - val_accuracy: 0.9133Epoch 9/1048000/48000 [==============================] - 2s 41us/step - loss: 0.3006 - accuracy: 0.9174 - val_loss: 0.3064 - val_accuracy: 0.9160Epoch 10/1048000/48000 [==============================] - 2s 40us/step - loss: 0.2906 - accuracy: 0.9201 - val_loss: 0.2977 - val_accuracy: 0.9183</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br><span class="line"></span><br><span class="line">print(test_loss, test_acc)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 0s 25us/step0.2771936253398657 0.9223999977111816</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap = <span class="string">'Greys'</span>, interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_14_0.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_14_1.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_14_2.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.plot(history.history['val_accuracy'])</span></span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_15_0.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습3"><a href="#실습3" class="headerlink" title="실습3"></a>실습3</h2><p>이번에는 실제로 CNN을 사용하여 딥러닝을 수행했다. MLT를 수행하기 이전에 Convolution Layer 및 Pooling Layer를 거쳐 학습이 진행된다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-2"><a href="#2019-11-24-딥-러닝-과정-CNN-2" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="두번째-실습-Keras-모델-생성-학습-MNIST-CNN"><a href="#두번째-실습-Keras-모델-생성-학습-MNIST-CNN" class="headerlink" title="두번째 실습. Keras 모델 생성/학습 - MNIST : CNN"></a>두번째 실습. Keras 모델 생성/학습 - MNIST : CNN</h3><p><a href="https://keras.io/ko/datasets/#mnist" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                 random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28)(48000,)(10000, 28, 28)(10000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap=plt.cm.gray)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x240c6b78c48&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1a.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. 이미지 데이터 전처리 : 2차원-&gt;3차원 🌟🌟🌟</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w=h=28            </span></span><br><span class="line"><span class="comment"># X_train = X_train.reshape(X_train.shape[0], w, h, 1)</span></span><br><span class="line"><span class="comment"># 위의 두줄로 대체 가능 위의 방식이 재사용에 용이</span></span><br><span class="line"></span><br><span class="line">X_train = X_train.reshape(<span class="number">48000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">X_val = X_val.reshape(<span class="number">12000</span>, <span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br><span class="line">X_test = X_test.reshape((<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line"></span><br><span class="line">print(X_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28, 1)(12000, 28, 28, 1)(10000, 28, 28, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. 이미지 데이터 전처리 : Normalzation</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_val = X_val / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label 전처리 (one-hot encoding)</span></span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>]) <span class="comment"># 앞에서 10개, label : 숫자가 어떤 숫자인지</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_val = to_categorical(y_val)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[9 9 9 5 3 2 0 4 2 7][[0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : CNN 🌟🌟🌟</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Conv2D, MaxPooling2D, Flatten</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(filters=<span class="number">32</span>,</span><br><span class="line">                kernel_size=(<span class="number">3</span>,<span class="number">3</span>),</span><br><span class="line">                padding=<span class="string">'same'</span>,</span><br><span class="line">                activation=<span class="string">'relu'</span>,</span><br><span class="line">                input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_10&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_9 (Conv2D)            (None, 28, 28, 32)        320       _________________________________________________________________max_pooling2d_7 (MaxPooling2 (None, 14, 14, 32)        0         _________________________________________________________________flatten_6 (Flatten)          (None, 6272)              0         _________________________________________________________________dense_9 (Dense)              (None, 128)               802944    _________________________________________________________________dense_10 (Dense)             (None, 10)                1290      =================================================================Total params: 804,554Trainable params: 804,554Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size=<span class="number">128</span></span><br><span class="line">epochs=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">         epochs=epochs,</span><br><span class="line">         batch_size=batch_size,</span><br><span class="line">         validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">         verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>W1124 16:01:22.815376 23724 deprecation_wrapper.py:119] From c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\keras\backend\tensorflow_backend.py:422: The name tf.global_variables is deprecated. Please use tf.compat.v1.global_variables instead.Train on 48000 samples, validate on 12000 samplesEpoch 1/1048000/48000 [==============================] - 10s 203us/step - loss: 1.1062 - accuracy: 0.7491 - val_loss: 0.4400 - val_accuracy: 0.8799Epoch 2/1048000/48000 [==============================] - 10s 207us/step - loss: 0.3706 - accuracy: 0.8950 - val_loss: 0.3396 - val_accuracy: 0.9028Epoch 3/1048000/48000 [==============================] - 12s 242us/step - loss: 0.3099 - accuracy: 0.9095 - val_loss: 0.3000 - val_accuracy: 0.9153Epoch 4/1048000/48000 [==============================] - 12s 245us/step - loss: 0.2787 - accuracy: 0.9186 - val_loss: 0.2750 - val_accuracy: 0.9217Epoch 5/1048000/48000 [==============================] - 12s 244us/step - loss: 0.2548 - accuracy: 0.9252 - val_loss: 0.2543 - val_accuracy: 0.9284Epoch 6/1048000/48000 [==============================] - 12s 252us/step - loss: 0.2348 - accuracy: 0.9316 - val_loss: 0.2379 - val_accuracy: 0.9331Epoch 7/1048000/48000 [==============================] - 12s 251us/step - loss: 0.2173 - accuracy: 0.9372 - val_loss: 0.2233 - val_accuracy: 0.9353Epoch 8/1048000/48000 [==============================] - 13s 269us/step - loss: 0.2025 - accuracy: 0.9405 - val_loss: 0.2106 - val_accuracy: 0.9405Epoch 9/1048000/48000 [==============================] - 13s 265us/step - loss: 0.1898 - accuracy: 0.9446 - val_loss: 0.1987 - val_accuracy: 0.9421Epoch 10/1048000/48000 [==============================] - 12s 251us/step - loss: 0.1782 - accuracy: 0.9475 - val_loss: 0.1957 - val_accuracy: 0.9433</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 1s 83us/step</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap = <span class="string">'Greys'</span>, interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_0a.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_1a.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_2a.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_0a.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_1a.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습4"><a href="#실습4" class="headerlink" title="실습4"></a>실습4</h2><p>위에서 학습한 방식을 그대로 사용하여 Fashion MNIST 데이터에 적용하여 딥러닝을 수행해보았다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-3"><a href="#2019-11-24-딥-러닝-과정-CNN-3" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="세번째-실습-Keras-모델-생성-학습-Fashion-MNIST-CNN"><a href="#세번째-실습-Keras-모델-생성-학습-Fashion-MNIST-CNN" class="headerlink" title="세번째 실습. Keras 모델 생성/학습 - Fashion MNIST : CNN"></a>세번째 실습. Keras 모델 생성/학습 - Fashion MNIST : CNN</h3><p><a href="https://keras.io/ko/datasets/#-mnist" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> fashion_mnist</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = fashion_mnist.load_data()</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                 random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28)(48000,)(12000, 28, 28)(12000,)(10000, 28, 28)(10000,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image, cmap = plt.cm.gray)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x2ab820aac08&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1b.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. 이미지 데이터 전처리 : 2차원-&gt;3차원 🌟🌟🌟</span></span><br><span class="line">X_train = X_train.reshape(<span class="number">48000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">X_val = X_val.reshape(<span class="number">12000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line">X_test = X_test.reshape(<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(X_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(48000, 28, 28, 1)(12000, 28, 28, 1)(10000, 28, 28, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. 이미지 데이터 전처리 : Normalzation</span></span><br><span class="line"></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_val = X_val / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label categorical (one-hot encoding)</span></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_val = to_categorical(y_val)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[3 1 2 6 7 3 5 1 1 5][[0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 1. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : CNN</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Conv2D, MaxPool2D, Flatten, Dropout</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(filters=<span class="number">32</span>,  <span class="comment"># 필터의 개수</span></span><br><span class="line">                kernel_size=(<span class="number">3</span>,<span class="number">3</span>),  <span class="comment"># 필터 사이즈</span></span><br><span class="line">                padding=<span class="string">'same'</span>,  <span class="comment"># padding</span></span><br><span class="line">                activation=<span class="string">'relu'</span>,  <span class="comment"># activation 함수 설정</span></span><br><span class="line">                input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))) <span class="comment"># (input_dim)</span></span><br><span class="line"></span><br><span class="line">model.add(MaxPool2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>))) <span class="comment"># 보통 (2,2)를 넣음</span></span><br><span class="line">model.add(Flatten())</span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.3</span>))<span class="comment"># Dropout 설정</span></span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>)) <span class="comment"># 다중 분류 문제이기 때문에 softmax</span></span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_5&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_5 (Conv2D)            (None, 28, 28, 32)        320       _________________________________________________________________max_pooling2d_5 (MaxPooling2 (None, 14, 14, 32)        0         _________________________________________________________________flatten_5 (Flatten)          (None, 6272)              0         _________________________________________________________________dense_5 (Dense)              (None, 128)               802944    _________________________________________________________________dropout_2 (Dropout)          (None, 128)               0         _________________________________________________________________dense_6 (Dense)              (None, 10)                1290      =================================================================Total params: 804,554Trainable params: 804,554Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">             optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">                    epochs=epochs,</span><br><span class="line">                    batch_size=batch_size,</span><br><span class="line">                    validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">                    verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 48000 samples, validate on 12000 samplesEpoch 1/1048000/48000 [==============================] - 25s 511us/step - loss: 0.5189 - accuracy: 0.8164 - val_loss: 0.3606 - val_accuracy: 0.8741Epoch 2/1048000/48000 [==============================] - 23s 488us/step - loss: 0.3464 - accuracy: 0.8777 - val_loss: 0.3015 - val_accuracy: 0.8932Epoch 3/1048000/48000 [==============================] - 23s 487us/step - loss: 0.2950 - accuracy: 0.8942 - val_loss: 0.2767 - val_accuracy: 0.9023Epoch 4/1048000/48000 [==============================] - 23s 484us/step - loss: 0.2648 - accuracy: 0.9041 - val_loss: 0.2626 - val_accuracy: 0.9061Epoch 5/1048000/48000 [==============================] - 23s 480us/step - loss: 0.2444 - accuracy: 0.9106 - val_loss: 0.2510 - val_accuracy: 0.9106Epoch 6/1048000/48000 [==============================] - 23s 479us/step - loss: 0.2241 - accuracy: 0.9170 - val_loss: 0.2577 - val_accuracy: 0.9068Epoch 7/1048000/48000 [==============================] - 24s 503us/step - loss: 0.2093 - accuracy: 0.9236 - val_loss: 0.2417 - val_accuracy: 0.9126Epoch 8/1048000/48000 [==============================] - 24s 509us/step - loss: 0.1926 - accuracy: 0.9288 - val_loss: 0.2380 - val_accuracy: 0.9153Epoch 9/1048000/48000 [==============================] - 24s 504us/step - loss: 0.1821 - accuracy: 0.9325 - val_loss: 0.2352 - val_accuracy: 0.9190Epoch 10/1048000/48000 [==============================] - 24s 506us/step - loss: 0.1699 - accuracy: 0.9368 - val_loss: 0.2329 - val_accuracy: 0.9191</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 2s 206us/step</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index].reshape(<span class="number">28</span>, <span class="number">28</span>), cmap = <span class="string">'Greys'</span>, interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_0b.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_1b.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_2b.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_0b.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_12_1b.png" style="width: 50%    ; height: 300px;"></div><h2 id="실습5"><a href="#실습5" class="headerlink" title="실습5"></a>실습5</h2><p>마지막으로 cifar10 데이터셋에 대한 이미지 분류(Image Classification)를 수행하는 Convolutional Neural Networks(CNNs)을 만드는 예제를 수행하였다..</p><p>CIFAR-10은 이미지 인식 분야에서 널리 쓰이는 벤치마크 데이터셋 중 하나이다. CIFAR-10 데이터셋은 아래와 같이 총 10개의 레이블로 이루어져 있다.</p><p>airplane, automobile, bird, cat, deer, dog, frog, horse, ship, and truck.</p><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/cifar.png" style="width: 50%    ; height: 300px;"></div><p>각각의 레이블마다 32×32 크기 이미지인 50,000개의 training 데이터셋, 10,000개의 test 데이터셋이 존재하고, 결과적으로 총 60,000개의 32×32 크기의 이미지로 데이터셋이 구성되어 있다.</p><h4 id="2019-11-24-딥-러닝-과정-CNN-4"><a href="#2019-11-24-딥-러닝-과정-CNN-4" class="headerlink" title="2019.11.24. 딥-러닝 과정 CNN"></a>2019.11.24. 딥-러닝 과정 CNN</h4><h3 id="네번째-실습-Keras-모델-생성-학습-cifar10-CNN"><a href="#네번째-실습-Keras-모델-생성-학습-cifar10-CNN" class="headerlink" title="네번째 실습. Keras 모델 생성/학습 - cifar10 : CNN"></a>네번째 실습. Keras 모델 생성/학습 - cifar10 : CNN</h3><p><a href="https://keras.io/ko/datasets/#-cifar10" target="_blank" rel="external nofollow noopener noreferrer">Keras Dataset</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 데이터 불러오기</span></span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> cifar10</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">(X_train, y_train), (X_test, y_test) = cifar10.load_data()</span><br><span class="line"></span><br><span class="line">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train,</span><br><span class="line">                                                 test_size=<span class="number">0.2</span>,</span><br><span class="line">                                                 random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(40000, 32, 32, 3)(40000, 1)(10000, 32, 32, 3)(10000, 1)(10000, 32, 32, 3)(10000, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 이미지 데이터 확인하기 🖼</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = X_train[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">plt.imshow(image)</span><br></pre></td></tr></table></figure><pre><code>&lt;matplotlib.image.AxesImage at 0x2a31e4ed948&gt;</code></pre><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_3_1c.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. 이미지 데이터 전처리</span></span><br><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_val = X_val / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Label categorical (one-hot encoding)</span></span><br><span class="line"><span class="comment"># print(y_train[:10])</span></span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"></span><br><span class="line">y_train = to_categorical(y_train)</span><br><span class="line">y_val = to_categorical(y_val)</span><br><span class="line">y_test = to_categorical(y_test)</span><br><span class="line"></span><br><span class="line">print(y_train[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>[[0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.] [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. 모델 생성 : CNN</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dropout, Dense, Conv2D, MaxPooling2D, Flatten</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Conv2D(filters=<span class="number">32</span>,</span><br><span class="line">                kernel_size=(<span class="number">3</span>,<span class="number">3</span>),</span><br><span class="line">                padding=<span class="string">'same'</span>,</span><br><span class="line">                activation=<span class="string">'relu'</span>,</span><br><span class="line">                input_shape=(<span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>), padding=<span class="string">'same'</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">model.add(Flatten())</span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">128</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.3</span>))</span><br><span class="line">model.add(Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_7&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================conv2d_10 (Conv2D)           (None, 32, 32, 32)        896       _________________________________________________________________conv2d_11 (Conv2D)           (None, 32, 32, 64)        18496     _________________________________________________________________max_pooling2d_7 (MaxPooling2 (None, 16, 16, 64)        0         _________________________________________________________________flatten_7 (Flatten)          (None, 16384)             0         _________________________________________________________________dense_16 (Dense)             (None, 128)               2097280   _________________________________________________________________dropout_11 (Dropout)         (None, 128)               0         _________________________________________________________________dense_17 (Dense)             (None, 64)                8256      _________________________________________________________________dropout_12 (Dropout)         (None, 64)                0         _________________________________________________________________dense_18 (Dense)             (None, 10)                650       =================================================================Total params: 2,125,578Trainable params: 2,125,578Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Compile - Optimizer, Loss function 설정</span></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">             optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 학습시키기</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">epochs = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">                    epochs=epochs,</span><br><span class="line">                    batch_size=batch_size,</span><br><span class="line">                    validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">                    verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 40000 samples, validate on 10000 samplesEpoch 1/1040000/40000 [==============================] - 67s 2ms/step - loss: 1.7432 - accuracy: 0.3568 - val_loss: 1.3433 - val_accuracy: 0.5201Epoch 2/1040000/40000 [==============================] - 72s 2ms/step - loss: 1.3271 - accuracy: 0.5257 - val_loss: 1.1500 - val_accuracy: 0.5906Epoch 3/1040000/40000 [==============================] - 77s 2ms/step - loss: 1.1586 - accuracy: 0.5886 - val_loss: 1.0559 - val_accuracy: 0.6271Epoch 4/1040000/40000 [==============================] - 79s 2ms/step - loss: 1.0281 - accuracy: 0.6375 - val_loss: 0.9819 - val_accuracy: 0.6544Epoch 5/1040000/40000 [==============================] - 77s 2ms/step - loss: 0.9405 - accuracy: 0.6692 - val_loss: 0.9503 - val_accuracy: 0.6616Epoch 6/1040000/40000 [==============================] - 74s 2ms/step - loss: 0.8635 - accuracy: 0.6951 - val_loss: 0.9583 - val_accuracy: 0.6658Epoch 7/1040000/40000 [==============================] - 80s 2ms/step - loss: 0.7953 - accuracy: 0.7214 - val_loss: 0.9359 - val_accuracy: 0.6790Epoch 8/1040000/40000 [==============================] - 74s 2ms/step - loss: 0.7194 - accuracy: 0.7470 - val_loss: 0.9354 - val_accuracy: 0.6783Epoch 9/1040000/40000 [==============================] - 79s 2ms/step - loss: 0.6575 - accuracy: 0.7661 - val_loss: 0.9470 - val_accuracy: 0.6804Epoch 10/1040000/40000 [==============================] - 76s 2ms/step - loss: 0.6005 - accuracy: 0.7867 - val_loss: 1.0215 - val_accuracy: 0.6707</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 모델 평가하기</span></span><br><span class="line">test_loss, test_acc = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure><pre><code>10000/10000 [==============================] - 5s 517us/step</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 이미지를 랜덤으로 선택해 훈련된 모델로 예측 🖼</span></span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> numpy.random.choice(len(y_test), <span class="number">3</span>, replace = <span class="literal">False</span>):</span><br><span class="line">    predicted = model.predict(X_test[index:index + <span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    label = y_test[index]</span><br><span class="line">    result_label = numpy.where(label == numpy.amax(label))</span><br><span class="line">    result_predicted = numpy.where(predicted == numpy.amax(predicted))</span><br><span class="line">    title = <span class="string">"Label value = %s  Predicted value = %s "</span> % (result_label[<span class="number">0</span>], result_predicted[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    fig = plt.figure(<span class="number">1</span>, figsize = (<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    ax1 = fig.add_axes((<span class="number">0</span>,<span class="number">0</span>,<span class="number">.8</span>,<span class="number">.8</span>))</span><br><span class="line">    ax1.set_title(title)</span><br><span class="line">    images = X_test</span><br><span class="line">    plt.imshow(images[index], interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_10_0c.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_10_1c.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_10_2c.png" style="width: 50%    ; height: 300px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'accuracy'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_accuracy'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>, <span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_0c.png" style="width: 50%    ; height: 300px;"></div><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/output_11_1c.png" style="width: 50%    ; height: 300px;"></div><p>참조<br><a href="https://umbum.tistory.com/223" target="_blank" rel="external nofollow noopener noreferrer">https://umbum.tistory.com/223</a><br><a href="https://untitledtblog.tistory.com/150" target="_blank" rel="external nofollow noopener noreferrer">https://untitledtblog.tistory.com/150</a><br><a href="https://adeshpande3.github.io/A-Beginner%27s-Guide-To-Understanding-Convolutional-Neural-Networks/" target="_blank" rel="external nofollow noopener noreferrer">https://adeshpande3.github.io/A-Beginner%27s-Guide-To-Understanding-Convolutional-Neural-Networks/</a><br><a href="http://solarisailab.com/archives/1700" target="_blank" rel="external nofollow noopener noreferrer">http://solarisailab.com/archives/1700</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 둘째 날 배운 내용을 리뷰해보겠다. 둘째 날에는 이미지 분류 이론, Azure Cloud GPU활용, Cifar10 이미지 분류에 대해서 배웠다.&lt;/p&gt;
&lt;h3 id=&quot;Convolutional-Neural-Network-CNN&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://kyu9341.github.io/categories/MachineLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>ICT멘토링 딥러닝 교육 1일차</title>
    <link href="https://kyu9341.github.io/MachineLearning/2019/11/23/marchinelearning3/"/>
    <id>https://kyu9341.github.io/MachineLearning/2019/11/23/marchinelearning3/</id>
    <published>2019-11-23T00:54:56.000Z</published>
    <updated>2019-12-28T08:46:08.211Z</updated>
    
    <content type="html"><![CDATA[<p>저번주에 한이음에서 주최한 머신러닝 ICT멘토링 AI머신러닝(기초) 교육에 이어 이번에는 AI딥러닝 교육에 참가하게 되었다. 이번주도 토일 10:00 ~ 18:00까지 진행되는데 첫째 날은 딥러닝 이론, 케라스, Azure Cloud 설정, MLP 설정에 대해 배웠다.</p><h3 id="딥러닝이란"><a href="#딥러닝이란" class="headerlink" title="딥러닝이란?"></a>딥러닝이란?</h3><p>Deep Learning = Deep Neural Network = Artificial Neural Network(ANN) 인공 신경망<br>= Multi Layer Perceptron</p><p>인공신경망을 사용하는 머신러닝 모델링 방법 중 하나(Neural Network)이며 다층 인공신경망 구조를 사용하여 빅 데이터 학습한다.</p><h4 id="perceptron"><a href="#perceptron" class="headerlink" title="perceptron"></a>perceptron</h4><p>인공 신경망의 한 종류.</p><p><strong>단층 퍼셉트론</strong> 은 다수의 신호(Input)을 받아서 하나의 신호(Output)를 출력한다. 이 동작은 뉴런과 아주 유사하고 그 과정은 다음과 같다. 다수의 입력을 받았을 때, 퍼셉트론은 각 입력 신호의 세기에 따라 다른 가중치를 부여한다. 그 결과를 고유한 방식으로 처리한 후, 입력 신호의 합이 일정 값을 초과한다면 그 결과를 다른 뉴련으로 전달한다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/perceptron.png" style="width: 90%    ; height: 250px;"></div><p>과거에는 이 퍼셉트론을 하드웨어를 이용하여 구현했다. 이 방식으로도 AND와 OR 문제를 해결이 가능했다. 그러나 이러한 단층 퍼셉트론으로는 XOR문제를 해결할 수 없었다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/xor.png" style="width: 100%    ; height: 250px;"></div><p>이러한 문제를 해결할 수 있는 것이 <strong>다층 퍼셉트론</strong> 이다.</p><p>딥러닝은 기본적으로 다음과 같은 순서로 진행이 된다.</p><p>Weight Initialization -&gt; Forward Propagation -&gt; Back Propagation</p><p>And Gate 연산을 예시로 퍼셉트론의 동작 순서에 대해 알아보자.</p><p><strong>Weight Initialization (가중치 초기화)</strong> : 예를 들어 노드를 3개를 쌓는다면 입력 값마다 3개의 가중치가 생성된다. 아래의 예시에서는 And Gate에서의 동작을 예로 들었는데 여기서는 0과 1 두개의 노드가 존재하므로 각 입력 값마다 2개의 가중치를 생성하여 계산하였다.</p><p><strong>Forward Propagation(순전파)</strong> : 가중치 초기화를 진행한 후에 각각의 입력 값과 가중치 값을 곱해주며 노드(퍼셉트론)에 들어온 값들을 모두 더해 activation function을 적용시켜 출력을 하게 된다. activation function은 threshold값을 지정해 그 값보다 크면 1, 작으면 0이 되는 식으로 동작할 수 있다.</p><p>Ex) And gate     <strong>activation function(활성함수)</strong> : ex) [(0.5 &lt; sum) : 1 / (0.5 &gt; sum) : 0]</p><table><thead><tr><th align="left"></th><th align="left">w1 * x1</th><th align="left">w2 * x2</th><th align="left">sum</th><th align="center">activate function</th><th align="right">output</th><th align="right">result</th></tr></thead><tbody><tr><td align="left">[0, 0]</td><td align="left">0.7*0</td><td align="left">0.4*0</td><td align="left">0</td><td align="center">0</td><td align="right">0</td><td align="right">true</td></tr><tr><td align="left">[1, 0]</td><td align="left">0.7*1</td><td align="left">0.4*0</td><td align="left">0.7</td><td align="center">1</td><td align="right">0</td><td align="right">false</td></tr><tr><td align="left">[0, 1]</td><td align="left">0.7*0</td><td align="left">0.4*1</td><td align="left">0.4</td><td align="center">0</td><td align="right">0</td><td align="right">true</td></tr><tr><td align="left">[1, 1]</td><td align="left">0.7*1</td><td align="left">0.4*1</td><td align="left">1.1</td><td align="center">1</td><td align="right">1</td><td align="right">true</td></tr></tbody></table><p> 세번째 행 : 틀린 결과 -&gt; Weight 재설정</p><p><strong>Back Propagation(역전파)</strong> : 위의 표와 같이 activation function을 거쳐 나온 결과값과 실제 값과의 차이를 비교하여 값이 틀렸다면 다시 가중치를 재설정하여 Forward Propagation과정을 반복한다.</p><p>예측 값과 실제 값의 차이를 비교하는 과정으로 아래의 cost function이 사용된다.</p><ul><li><strong>Cost function</strong> (=loss function = error function = objective function)</li></ul><p>예측 값과 실제 값의 차이를 기반으로 모델의 정확도(성능)을 판단하기 위한 함수로 아래의 수식을 따른다.</p><div style="width: 30%; height: 50px;">    <img src="https://kyu9341.github.io/img/lossfunction.png" style="width:100%    ; height: 50px;"></div><p>오차를 구하여 모델의 정확도를 판단하는데 이 값이 작을수록 모델의 성능이 좋다는 것을 뜻한다. 그래프로 본다면 아래와 같은데 이 오차를 줄이는 방법으로 경사하강법이 있다.</p><h4 id="Gradient-Descent-경사하강법"><a href="#Gradient-Descent-경사하강법" class="headerlink" title="Gradient Descent(경사하강법)"></a>Gradient Descent(경사하강법)</h4><p>해당 함수의 최소값 위치를 찾기 위해 비용함수(Cost Function)의 기울기가 (-)가 되는 방향으로 이동하여 최소값(=기울기 0)을 찾는 알고리즘이다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/Descent.png" style="width: 100%    ; height: 250px;"></div><h4 id="Optimizer-최적화기"><a href="#Optimizer-최적화기" class="headerlink" title="Optimizer(최적화기)"></a>Optimizer(최적화기)</h4><p>위에서 말한 최소값을 찾기 위한 방법으로 SGD, Momentum, NAG, Adagrad, Adadelta, Rmsprop, Adam 등의 여러가지 방법이 있는데, SGD는 layer가 늦은 경우 빠르게 찾아주고 데이터가 간단한 경우에 주로 사용한다. Adam은 정확도가 가장 높아서 일반적으로 가장 많이 사용한다고 한다.</p><p><strong>optimizer의 발전과정</strong></p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/optimizer.png" style="width: 90%    ; height: 250px;"></div><h4 id="Vanishing-Gradient"><a href="#Vanishing-Gradient" class="headerlink" title="Vanishing Gradient"></a>Vanishing Gradient</h4><p>Vanishing Gradient Problem(기울기 값이 사라지는 문제)는 인공신경망을 기울기 값을 베이스로 하는  mothod(backpropagation)로 학습시키려고 할 때 발생하는 문제이다.</p><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/vanishing.png" style="width: 90%    ; height: 250px;"></div><p>Vanishing Gradient Problem은 activate function을 의존적으로 일어난다. sigmoid함수나 tanh함수를 사용함으로써 발생하는 문제인데 layer가 깊어질수록 전달이 약해진다.<br>이 문제를 해결하기 위해서는 sigmoid함수 대신 ReLU 함수나 Leakey ReLU 등의 함수를 사용하면 된다.</p><h4 id="Overfitting"><a href="#Overfitting" class="headerlink" title="Overfitting"></a>Overfitting</h4><p>저번 머신러닝 교육 내용에도 있었지만 역시 딥러닝에도 Overfitting이 존재한다. overfitting은 훈련 데이터에만 정확도가 높아져 새로운 데이터에는 성능이 떨어지는 현상을 말하는데 이를 위한 해결방안으로 다음과 같은 것들이 있다.</p><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/regularization.png" style="width: 80%    ; height: 350px;"></div><p>–    L1 Regularization  :  세세한 값들은 무시하고 큰 특징들만 추출</p><p>–    L2 Regularization  :  세부적인 값들을 약하게 해줌</p><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/dropout.png" style="width: 80%    ; height: 350px;"></div><dl><dt>–    Dropout : hidden node 중 몇 개를 끊어 냄 -&gt; 똑같은 것만 학습하는 것을 방지</dt><dd>성능이 좋고 많이 사용 (20~50% 노드를 꺼줌)</dd></dl><h4 id="신경망-구조"><a href="#신경망-구조" class="headerlink" title="신경망 구조"></a>신경망 구조</h4><div style="width: 100%; height: 460px;">    <img src="https://kyu9341.github.io/img/hidden.png" style="width: 80%    ; height: 450px;"></div><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/output.png" style="width: 80%    ; height: 450px;"></div>#### 케라스다음은 딥러닝 프레임워크 중 하나인 케라스를 사용해서 jupyter notebook상에서 실습을 진행하였다. 케라스는 파이썬으로 구현된 high-level deep learning API이며 내부적으로는 TensorFlow로 동작한다. 쉬운 사용법과 간단한 문법으로 빠른 설계가 가능하고 입문자들이 사용해보기 좋다.<div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/mlt.png" style="width: 80%    ; height: 350px;"></div><p>실습은 딥러닝 방식중 하나인 MLP 를 사용하였고 AND, XOR 기능을 수행하는 모델을 만들었고 마지막으로 당뇨병 예측 모델을 만들어보았다.</p><h3 id="2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP"><a href="#2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP" class="headerlink" title="2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)"></a>2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)</h3><h2 id="첫번째-실습-Simple-Keras-모델-생성-학습-AND-Function"><a href="#첫번째-실습-Simple-Keras-모델-생성-학습-AND-Function" class="headerlink" title="첫번째 실습. Simple Keras 모델 생성/학습 - AND Function"></a>첫번째 실습. Simple Keras 모델 생성/학습 - AND Function</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Numpy 가져오기</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(np.__version__)</span><br></pre></td></tr></table></figure><pre><code>1.17.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 입력/출력 데이터 만들기</span></span><br><span class="line">X = np.array([[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">1</span>]]) <span class="comment"># numpy 형태로 입력 데이터 가져오기</span></span><br><span class="line">y = np.array([[<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">0</span>], [<span class="number">1</span>]]) <span class="comment"># numpy 형태로 출력 데이터 가져오기</span></span><br><span class="line">                                <span class="comment"># 순서 맞춰야함</span></span><br><span class="line">print(X)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[0 0] [1 0] [0 1] [1 1]][[0] [0] [0] [1]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. Keras 패키지 가져오기</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers.core <span class="keyword">import</span> Dense, Activation</span><br><span class="line"></span><br><span class="line">print(keras.__version__)</span><br></pre></td></tr></table></figure><pre><code>2.3.1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. MLP 모델 생성</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line"><span class="comment"># model.add(Dense(4, input_dim=2)) # 첫번째인자 : node의 개수,  input_dim : feature의 개수 (x1, x2)</span></span><br><span class="line"><span class="comment"># model.add(Activation('relu')) # Activation Function 종류 설정</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">4</span>, input_dim=<span class="number">2</span>, activation=<span class="string">'relu'</span>)) <span class="comment"># 위의 두줄과 완전히 같은 뜻</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model.add(Dense(1)) # 최종 출력 1개# Dense Layer</span></span><br><span class="line"><span class="comment"># model.add(Activation('sigmoid'))</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)) <span class="comment"># 위의 두줄과 완전히 같은 뜻</span></span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br><span class="line"><span class="comment">#input 값이 2개지만 b도 하나의 값으로 추가되어 4*3 = 12 로 출력된다.</span></span><br><span class="line"><span class="comment"># Dense Layer : fully connected</span></span><br></pre></td></tr></table></figure><pre><code>Model: &quot;sequential_1&quot;_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_1 (Dense)              (None, 4)                 12        _________________________________________________________________dense_2 (Dense)              (None, 1)                 5         =================================================================Total params: 17Trainable params: 17Non-trainable params: 0_________________________________________________________________None</code></pre><h4 id="출력층-Output-Layer"><a href="#출력층-Output-Layer" class="headerlink" title="출력층(Output Layer)"></a>출력층(Output Layer)</h4><ul><li><p>linear : 특정 값 예측</p></li><li><p>sigmoid : 이진 클래스 예측</p></li><li><p>softmax : 다중 클래스 예측</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Compile - Optimizer, Loss function 설정</span></span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'sgd'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><pre><code>WARNING: Logging before flag parsing goes to stderr.W1123 21:54:23.066224 11320 deprecation.py:323] From c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\tensorflow\python\ops\nn_impl.py:180: add_dispatch_support.&lt;locals&gt;.wrapper (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version.Instructions for updating:Use tf.where in 2.0, which has the same broadcast rule as np.where</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">1</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># fit : 학습을 시키겠다,  verbose : 1 = 학습 과정을 본다 # shuffle : 한번 풀고 순서를 섞는다</span></span><br><span class="line">model.fit(X, y,</span><br><span class="line">          epochs=epochs,</span><br><span class="line">          batch_size=batch_size,</span><br><span class="line">          shuffle=<span class="literal">True</span>,</span><br><span class="line">          verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><pre><code>Epoch 1/10004/4 [==============================] - 0s 1ms/step - loss: 0.3339 - accuracy: 1.0000Epoch 2/10004/4 [==============================] - 0s 992us/step - loss: 0.3319 - accuracy: 1.0000....4/4 [==============================] - 0s 868us/step - loss: 0.0205 - accuracy: 1.0000Epoch 999/10004/4 [==============================] - 0s 992us/step - loss: 0.0204 - accuracy: 1.0000Epoch 1000/10004/4 [==============================] - 0s 858us/step - loss: 0.0204 - accuracy: 1.0000&lt;keras.callbacks.callbacks.History at 0x21a14b58748&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. 모델 테스트하기</span></span><br><span class="line">predict = model.predict(np.array([[<span class="number">0</span>,<span class="number">1</span>],])) <span class="comment"># ,해주어야 함 2차원 값임을 알려주기 위해</span></span><br><span class="line">print(predict)</span><br></pre></td></tr></table></figure><pre><code>[[0.0208632]]</code></pre><hr><h3 id="2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP-1"><a href="#2019-11-23-딥-러닝-과정-Mulit-Layer-Perceptron-MLP-1" class="headerlink" title="2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)"></a>2019.11.23. 딥-러닝 과정 Mulit Layer Perceptron(MLP)</h3><h2 id="세번째-실습-Keras-모델-생성-학습-당뇨병-예측-모델"><a href="#세번째-실습-Keras-모델-생성-학습-당뇨병-예측-모델" class="headerlink" title="세번째 실습. Keras 모델 생성/학습 - 당뇨병 예측 모델"></a>세번째 실습. Keras 모델 생성/학습 - 당뇨병 예측 모델</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Pandas 가져오기</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">print(pd.__version__)</span><br></pre></td></tr></table></figure><pre><code>0.24.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. 데이터 불러오기</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'diabetes_data.csv'</span>)</span><br><span class="line">dataset.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 250px;">    <img src="https://kyu9341.github.io/img/head.png" style="width: 90%    ; height: 250px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. X/y 나누기</span></span><br><span class="line"></span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>]</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">print(X.shape) <span class="comment"># (768, 8) -&gt; 8 : input_dim</span></span><br><span class="line">print(y.shape)</span><br></pre></td></tr></table></figure><pre><code>(768, 8)(768,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Train set, Test set 나누기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y,</span><br><span class="line">                                                    test_size=<span class="number">0.3</span>,</span><br><span class="line">                                                    random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">X_val, X_test, y_val, y_test = train_test_split(X_test, y_test,</span><br><span class="line">                                               test_size=<span class="number">0.5</span>,</span><br><span class="line">                                               random_state=<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">print(X_train.shape)</span><br><span class="line">print(y_train.shape)</span><br><span class="line"></span><br><span class="line">print(X_val.shape)</span><br><span class="line">print(y_val.shape)</span><br><span class="line"></span><br><span class="line">print(X_test.shape)</span><br><span class="line">print(y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>(537, 8)(537,)(115, 8)(115,)(116, 8)(116,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Keras 패키지 가져오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">print(keras.__version__)</span><br></pre></td></tr></table></figure><pre><code>2.2.4</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. MLP 모델 생성</span></span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">12</span>, input_dim=<span class="number">8</span>,</span><br><span class="line">                activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.3</span>))<span class="comment"># Dropout 설정</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">8</span>, activation=<span class="string">'relu'</span>))<span class="comment"># input_dim은 생략 - (12)로 자동 지정</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))<span class="comment"># Dropout 설정</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"></span><br><span class="line">print(model.summary())</span><br></pre></td></tr></table></figure><pre><code>WARNING:tensorflow:From /anaconda/envs/py35/lib/python3.5/site-packages/keras/backend/tensorflow_backend.py:3445: calling dropout (from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a future version.Instructions for updating:Please use `rate` instead of `keep_prob`. Rate should be set to `rate = 1 - keep_prob`._________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================dense_7 (Dense)              (None, 12)                108       _________________________________________________________________dropout_1 (Dropout)          (None, 12)                0         _________________________________________________________________dense_8 (Dense)              (None, 8)                 104       _________________________________________________________________dropout_2 (Dropout)          (None, 8)                 0         _________________________________________________________________dense_9 (Dense)              (None, 1)                 9         =================================================================Total params: 221Trainable params: 221Non-trainable params: 0_________________________________________________________________None</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. Compile - Optimizer, Loss function 설정</span></span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>,</span><br><span class="line">             optimizer=<span class="string">'adam'</span>,</span><br><span class="line">             metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. 학습시키기</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">16</span></span><br><span class="line">epochs = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 한번의 epochs가 끝날 때마다 history에 저장 (데이터 시각화)</span></span><br><span class="line">history = model.fit(X_train, y_train,</span><br><span class="line">         epochs=epochs,</span><br><span class="line">         batch_size=batch_size,</span><br><span class="line">         validation_data=(X_val, y_val), <span class="comment"># validation_set 적용 (꼭 같이 해주는게 좋음)</span></span><br><span class="line">         verbose=<span class="number">1</span>,</span><br><span class="line">         shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><pre><code>Train on 537 samples, validate on 115 samplesEpoch 1/1000537/537 [==============================] - 1s 970us/step - loss: 4.9289 - acc: 0.5736 - val_loss: 3.2560 - val_acc: 0.6609Epoch 2/1000537/537 [==============================] - 0s 88us/step - loss: 3.4709 - acc: 0.6425 - val_loss: 3.2140 - val_acc: 0.6522Epoch 3/1000537/537 [==============================] - 0s 81us/step - loss: 3.7243 - acc: 0.5940 - val_loss: 3.0675 - val_acc: 0.6696Epoch 4/1000.......537/537 [==============================] - 0s 91us/step - loss: 0.5624 - acc: 0.7207 - val_loss: 0.5805 - val_acc: 0.7304Epoch 999/1000537/537 [==============================] - 0s 97us/step - loss: 0.5566 - acc: 0.7169 - val_loss: 0.5870 - val_acc: 0.7391Epoch 1000/1000537/537 [==============================] - 0s 91us/step - loss: 0.5356 - acc: 0.7449 - val_loss: 0.5801 - val_acc: 0.7391</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. 모델 평가하기</span></span><br><span class="line">train_accuracy = model.evaluate(X_train, y_train)</span><br><span class="line">test_accuracy = model.evaluate(X_test, y_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Train Acc:"</span>, train_accuracy)</span><br><span class="line">print(<span class="string">"Test Acc:"</span>, test_accuracy)</span><br></pre></td></tr></table></figure><pre><code>537/537 [==============================] - 0s 21us/step116/116 [==============================] - 0s 27us/stepTrain Acc: [0.5100221896970738, 0.7541899434681045]Test Acc: [0.725729592915239, 0.6724137972141134]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. 학습 시각화하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'acc'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_acc'</span>])</span><br><span class="line">plt.title(<span class="string">'Accuracy'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'accuracy'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>,<span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.plot(history.history[<span class="string">'loss'</span>])</span><br><span class="line">plt.plot(history.history[<span class="string">'val_loss'</span>])</span><br><span class="line">plt.title(<span class="string">'Loss'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.legend([<span class="string">'train'</span>,<span class="string">'test'</span>], loc=<span class="string">'upper left'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/output_11_0.png" style="width: 80%    ; height: 350px;"></div><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/output_11_1.png" style="width: 80%    ; height: 350px;"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 저장하기/불러오기</span></span><br><span class="line">model.save(<span class="string">'my_model.h5'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> load_model</span><br><span class="line">model = load_model(<span class="string">'my_model.h5'</span>)</span><br></pre></td></tr></table></figure><p>참조<br><a href="https://ydseo.tistory.com/41" target="_blank" rel="external nofollow noopener noreferrer">https://ydseo.tistory.com/41</a><br><a href="http://research.sualab.com/introduction/2017/10/10/what-is-deep-learning-1.html" target="_blank" rel="external nofollow noopener noreferrer">http://research.sualab.com/introduction/2017/10/10/what-is-deep-learning-1.html</a><br><a href="https://blog.naver.com/minsu_jj/221607901559" target="_blank" rel="external nofollow noopener noreferrer">https://blog.naver.com/minsu_jj/221607901559</a><br><a href="https://hobbang143.blog.me/221469060596" target="_blank" rel="external nofollow noopener noreferrer">https://hobbang143.blog.me/221469060596</a><br><a href="https://gomguard.tistory.com/187" target="_blank" rel="external nofollow noopener noreferrer">https://gomguard.tistory.com/187</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;저번주에 한이음에서 주최한 머신러닝 ICT멘토링 AI머신러닝(기초) 교육에 이어 이번에는 AI딥러닝 교육에 참가하게 되었다. 이번주도 토일 10:00 ~ 18:00까지 진행되는데 첫째 날은 딥러닝 이론, 케라스, Azure Cloud 설정, ML
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://kyu9341.github.io/categories/MachineLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - Binary Image, Gamma Correction</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/22/ImageProcessing3/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/22/ImageProcessing3/</id>
    <published>2019-11-22T12:02:31.000Z</published>
    <updated>2019-12-27T06:40:50.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Image"><a href="#Binary-Image" class="headerlink" title="Binary Image"></a>Binary Image</h2><p>영상정보는 0에서 255까지의 값을 가지고 있어서 필요에 따라 영상의 값들을 조작하거나 변경하는 영상처리를 수행한다. 그러나 컴퓨터 시스템의 특성과 영상처리의 단순화를 위하여 이진화 하는 작업이 필요한 경우가 많이 존재한다. 영상 이진화는 0에서 255까지의 값을 0과 1의 값으로 변환하는 작업이다. 실제 영상에서는 0과 1 모두 검은 값으로 표시되기 때문에 1은 255로 변환하여 표시하여 준다. 다음 이미지는 영상의 평균 값을 구하여 평균보다 작은 값은 0으로, 평균 이상의 값들은 모두 255로 변환하여 출력한 결과이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/binary.png" style="width: 512px    ; height: 512px;"></div><p>위의 이미지는 lena 영상을 평균 값을 기준으로 이진화를 시킨 모습이다. 이미지의 평균값을 구하는 함수와 평균값을 기준으로 영상을 이진화하는 함수는 다음 코드와 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(uchar** img, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// 이미지의 전체 평균값을 구하는 함수</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0</span>, avg;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">sum += img[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">avg = sum / ((<span class="keyword">double</span>)Row * Col);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Average of Image %1f \n"</span>, avg);</span><br><span class="line"><span class="keyword">return</span> avg;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeBinary</span><span class="params">(uchar** img, uchar** out, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">double</span> avg)</span> <span class="comment">// 이미지 2진화</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (img[i][j] &gt; avg) out[i][j] = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">else</span> out[i][j] = <span class="number">0</span>; <span class="comment">// 평균보다 큰 값은 255, 작은 값은 0 대입</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이진화 영상은 평균값 이외에도 특정한 threshold 값을 지정함으로써 원하는 형태의 이진화 영상을 구할 수 있다. 각각의 영상처리 역할과 분야에 따라 이진화 영상은 다양한 방법으로 사용될 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdaptiveBinary2</span><span class="params">(uchar** img, uchar** out, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (img[i][j] &gt; <span class="number">50</span> &amp;&amp; img[i][j] &lt; <span class="number">120</span>) out[i][j] = img[i][j];</span><br><span class="line"><span class="keyword">else</span> out[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdaptiveBinary1</span><span class="params">(uchar** img, uchar** out, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (img[i][j] &gt; <span class="number">50</span> &amp;&amp; img[i][j] &lt; <span class="number">120</span>) out[i][j] = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> out[i][j] = img[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdaptiveBinary0</span><span class="params">(uchar** img, uchar** out, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (img[i][j] &gt; <span class="number">50</span> &amp;&amp; img[i][j] &lt; <span class="number">120</span>) out[i][j] = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">else</span> out[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 다양한 방식의 이진화 영상을 구하는 방법이다. 기준치를 다양하게 주어 각 기준치마다 영상의 값을 지정해줄 수도 있다. 이러한 기법은 특정한 목적을 가지고 영상을 변환하고자 할 때 적용할 수 있는 방법이다.</p><p>다음은 위의 jet 영상을 각각 AdaptiveBinary0, 1, 2에 적용시킨 모습이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/jet.png" style="width: 512px    ; height: 512px;"></div>**jet512.dat 원영상**<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/jet0.png" style="width: 512px    ; height: 512px;"></div>**AdaptiveBinary0**<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/jet1.png" style="width: 512px    ; height: 512px;"></div>**AdaptiveBinary1**<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/jet2.png" style="width: 512px    ; height: 512px;"></div>**AdaptiveBinary2**<h2 id="Gamma-Correction"><a href="#Gamma-Correction" class="headerlink" title="Gamma Correction"></a>Gamma Correction</h2><p>Gamma Correction은 음극선관을 사용하는 CRT(carhode ray tube) 모니터나 텔레비전에서 영상을 제대로 보여줄 때 하드웨어적인 문제점을 보완하기 위해 도입된 기법으로 영상의 전체적인 밝기를 조절하는 방법이다.</p><div style="width: 30%; height: 50px;">    <img src="https://kyu9341.github.io/img/gammamath.png" style="width:100%    ; height: 50px;"></div>위의 수식에서 r값이 1을 기준으로 작을수록 영상이 어두워지고, 클수록 영상이 밝아지게 된다.<div style="width: 100%; height: 200px;">    <img src="https://kyu9341.github.io/img/gamma.png" style="width:100%    ; height: 200px;"></div><p>위의 히스토그램과 같이 gamma(r)값이 1보다 작다면 영상이 가지는 어두운 값이 많고 1보다 크다면 영상이 가지는 밝은 값이 많아져 위의 히스토그램과 같은 분포를 가지게 된다. gamma값으로 영상의 밝기를 변환해주는 함수는 다음과 같다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PowImg</span><span class="params">(uchar** img, uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">double</span> gamma)</span> <span class="comment">// gamma correction image</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 영상의 전체적인 밝기를 조절 (gamma 값에 따라 - gamma가 클수록 밝아짐)</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++) &#123;</span><br><span class="line">tmp = <span class="built_in">pow</span>(img[i][j] / <span class="number">255.</span>, <span class="number">1</span> / gamma); <span class="comment">// pow(a, b) -&gt; a^b 반환</span></span><br><span class="line"><span class="comment">// 지수법칙 변환 범위 : 0 ~ 1 -&gt; 스케일링 필요 : s = [(r/255)^(1/r)] * 255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tmp * <span class="number">255</span> &gt; <span class="number">255</span>) tmp = <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tmp * <span class="number">255</span> &lt; <span class="number">0</span>) tmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Result[i][j] = tmp * <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음은 각각 r값을 0.5, 3을 주어 밝기를 변환한 영상이다. lena원영상의 픽셀값의 평균은 123.607670이다. 변환된 이미지의 평균값과 비교해보자.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/gamma0.5.png" style="width: 512px    ; height: 512px;"></div>gamma = 0.5, 평균 = 68.473244<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/gamma3.png" style="width: 512px    ; height: 512px;"></div>gamma = 3, 평균 = 195.887569<p>gamma값에 따라 확연히 밝기가 달라지고 평균값 또한 밝기에 따라 함께 변화하는 것을 확인할 수 있다. 이러한 기법은 영상을 밝게 혹은 어둡게 해야 더 많은 정보를 획득할 수 있는 경우 중요한 기법으로 사용할 수 있다.</p><p>추가적으로 원하는 평균값을 가지는 영상을 구하는 방법을 알아보자. 예를 들어, lena영상으로 원하는 평균값을 가지는 영상으로 변환하고 싶다면 어떻게 해야할까? 다음의 코드롤 보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hopeAvg;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"원하는 평균값 입력 : "</span>);</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;hopeAvg);</span><br><span class="line"><span class="comment">// 원하는 평균값 구하기</span></span><br><span class="line"><span class="keyword">if</span> (msum &lt; hopeAvg) &#123; <span class="comment">// 원본 이미지의 평균값이 원하는 평균값 보다 작은 경우</span></span><br><span class="line">  <span class="keyword">for</span> (gamma = <span class="number">1</span>; gamma &lt; <span class="number">4</span>; gamma += <span class="number">0.005</span>) &#123; <span class="comment">// 연산량을 줄이기 위해 gamma = 1(원본 이미지) 부터 시작</span></span><br><span class="line">    PowImg(img, outimg, Row, Col, gamma);</span><br><span class="line">    msum = average(outimg, Row, Col);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gamma = %f\n"</span>, gamma);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msum &gt;= hopeAvg)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// 원본 이미지의 평균값이 원하는 평균값 이상인 경우</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (gamma = <span class="number">1</span>; gamma &gt; <span class="number">0</span>; gamma -= <span class="number">0.005</span>) &#123; <span class="comment">// 연산량을 줄이기 위해 gamma = 1(원본 이미지) 부터 시작</span></span><br><span class="line">    PowImg(img, outimg, Row, Col, gamma);</span><br><span class="line">    msum = average(outimg, Row, Col);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"gamma = %f\n"</span>, gamma);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msum &lt; hopeAvg)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>원하는 평균값을 입력받아 gamma값을 키우거나, 줄이며 원하는 평균값이 나오면 break로 반복문을 빠져나오면 된다. 이러한 방식으로 부르트 포스 알고리즘을 적용하여 해결할 수 있다. 부르트 포스 알고리즘이란, 모든 경우의 수를 다 해보며 원하는 값을 찾는 것인데 이러한 방식은 시간이 오래걸리므로 조금이라도 연산 시간을 줄이기 위해 gamma값을 1부터 시작하도록 하였다. 원영상의 gamma값은 1을 가지며 원하는 평균이 1보다 작다면 1부터 줄여가고, 1보다 크다면 1부터 키워가는 방식이다. 원하는 값에 도달하면 반복을 멈추고 이미지를 생성한다.</p><p>이러한 방식으로 평균값 151을 가지는 레나 영상을 구해보았다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/gamma151.png" style="width: 50%    ; height: 400px;"></div>위와 같이 지정한 평균값에 도달하면 반복을 멈추고 이미지를 생성한다.<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/gamma151img.png" style="width: 512px    ; height: 512px;"></div><p>평균값 151을 가지는 lena영상이다. 원영상보다는 조금 밝이전 것을 확인할 수 있다.</p><p>참조 : <a href="http://blog.daum.net/_blog/BlogTypeView.do?blogid=050RH&amp;articleno=12109204&amp;categoryId=44&amp;regdt=20130604182910" target="_blank" rel="external nofollow noopener noreferrer">http://blog.daum.net/_blog/BlogTypeView.do?blogid=050RH&amp;articleno=12109204&amp;categoryId=44&amp;regdt=20130604182910</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Binary-Image&quot;&gt;&lt;a href=&quot;#Binary-Image&quot; class=&quot;headerlink&quot; title=&quot;Binary Image&quot;&gt;&lt;/a&gt;Binary Image&lt;/h2&gt;&lt;p&gt;영상정보는 0에서 255까지의 값을 가지고 있어서 필요
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>ICT멘토링 머신러닝 교육 2일차</title>
    <link href="https://kyu9341.github.io/MachineLearning/2019/11/17/marchinelearning2/"/>
    <id>https://kyu9341.github.io/MachineLearning/2019/11/17/marchinelearning2/</id>
    <published>2019-11-17T12:09:22.000Z</published>
    <updated>2019-12-27T06:40:47.052Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 둘째 날에 배웠던 내용에 대해 리뷰해보도록 하겠다. 둘째 날은 Regression모델, 머신러닝 알고리즘, python라이브러리인 scikit-learn을 이용하여 실습을 진행하였다.</p><p>오전에는 어제 했던 Classification모델에 이어서 Azure ML Studio에서 Regression모델을 실습해보았다.</p><div style="width: 70%; height: 300px;">    <img src="https://kyu9341.github.io/img/ai3.png" style="width: 70%    ; height: 300px;"></div>Regression모델 같은 경우는 위와 같이 x값에 따른 y의 값을 찾고 싶을 때 사용한다.<p> 데이터 셋으로는 예전에 Kaggle에서 올라왔던 월마트 판매량 예측을 위한 데이터 셋을 이용하였다. 이 데이터는 어제 사용했던 것들과는 달리 3개의 데이터 셋이 따로 존재해서 이 세개의 데이터를 합치는 과정이 필요하다.</p><div style="width: 80%; height: 400px;">    <img src="https://kyu9341.github.io/img/machine8.png" style="width: 80%    ; height: 400px;"></div><p> 먼저 featrue.csv파일을 select columns in datset에서 필요하지 않은 컬럼을 제외시키고 train.csv파일을 가져와 join data로 합쳐주었다. 이 때, 지점과 날짜를 키값으로 하여 합쳤고 다시 stores.csv파일까지  Join Data로 지점을 키값으로 하여 합쳤다.</p><p>이후 Edit Metadata에서 숫자데이터이지만 string형으로 저장되어 있는 CPI, Unemployment를 float형으로 변환해주었다. 다음으로 예측하고 싶은 데이터인 Weekly Sales(주간판매량)을 레이블로 설정해주고 지점, 부서, 유형을 make categorical해주었다. (다른 데이터를 입력받지 않을 것이고, 상하관계가 없으므로)</p><p>이제 데이터 전처리가 끝났으므로 모델을 선택하여 학습을 시켜준다.</p><p>Linear Regression이라는 알고리즘을 사용하여 학습시켜보았다.</p><div style="width: 80%; height: 400px;">    <img src="https://kyu9341.github.io/img/regression1.png" style="width: 80%    ; height: 400px;"></div>위의 이미지과 같이 Scored Labels는 예측 데이터이고 주간 판매량이 실제 데이터이다.<p>아래 이미지는 Boosted Decision Tree Regression알고리즘을 사용하여 한번 더 예측하고 Linear Regression와 비교해본 것이다. 왼쪽이 Linear Regression이고 오른쪽이 Boosted Decision Tree Regression이다.  </p><div style="width: 90%; height: 300px;">    <img src="https://kyu9341.github.io/img/regression2.png" style="width: 100%    ; height: 300px;"></div><p>위의 데이터를 보면 여러가지 값들이 있는데 여기서 주요하게 보아야 할 값은 Mean Absolute Error와 Root Mean Squared Error를 보면 된다. 둘다 예측 값과 실측 값의 차이를 나타내는데 Mean Absolute Error는 절대값을 취한 후 평균을 내어주고 Mean Squared Error는 먼저 제곱을 한 값으로 평균을 낸 후에 루트를 씌워준다. 이게 어떤 차이가 있냐면 Mean Squared Error는 잘못 예측하여 크게 차이나는 값들이 있나면 값이 크게 나타난다. 이 말은 Mean Squared Error가 크게 나타난다면 예측 값 중 크게 차이나는 값들이 존재한다는 것이다. 이 두 값이 낮게 나타나야 좋은 모델이라고 할 수 있다.</p><p>Relative Absolute Error는 예측 값과 실제 값의 비율로 같은 단위로 나누어 상대적 비교가 가능하다. 이를 통해 다른 모델들 과도 비교가 가능하게 되며 이 값은 0에 가까울 수록 좋다. Coefficient of Determination는 1에 가까울 수록 정확도가 높다고 보면 된다.</p><p>위의 데이터를 비교해보면 오른쪽의 데이터가 훨씬 잘 예측을 한 것을 알 수 있다. 따라서 우측의 알고리즘을 웹 서버로 배포를 해보겠다.</p><p>이제 Set Up Web Service에서 Update Predictive Experiment를 눌러 아래와 같이 설정해준다.</p><div style="width: 70%; height: 450px;">    <img src="https://kyu9341.github.io/img/deploy.png" style="width: 90%    ; height: 450px;"></div><p>이때 배포 후에 입력을 받을 때에 구하는 결과값인 주간판매량은 입력을 받을 필요가 없고, 리턴받을 때 입력했던 값들은 받지 않아도 되므로  Scored Labels만 선택하여 준다.</p><div style="width: 80%; height: 450px;">    <img src="https://kyu9341.github.io/img/deploy2.png" style="width: 90%    ; height: 450px;"></div><p>이후 RUN 이후에 Deploy Web Service 버튼을 눌러준다. 여기까지 되었다면 이제 임의의 값을 입력하여 테스트를 해볼 수 있다.</p><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/deploy3.png" style="width: 100%    ; height: 450px;"></div><p>위와 같이 넘어간 화면에서 테스트 버튼을 눌러보면 다음과 같은 화면이 나타나는데 여기서 입력 값들을 입력해주면 결과를 확인할 수 있다.</p><p>이제 서버에 배포된 모델을 파이썬 개발환경인 주피터 노트북에서 이용해보자.</p><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/apikey.png" style="width: 100%    ; height: 450px;"></div><p>위의 화면에서 New Web Services Experience 버튼을 누르면 아래와 같이 넘어간다. 표시된 부분 중 api key는 이후에 사용될 부분이다.</p><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/use.png" style="width: 100%    ; height: 450px;"></div><p>이 화면으로 넘어오게 되면 Use endpoint를 눌러준다.</p><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/api1.png" style="width: 100%    ; height: 450px;"></div><p>이제 위와 같은 화면으로 넘어오게 되는데 아래로 내려보면</p><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/samplecode.png" style="width: 100%    ; height: 450px;"></div><p>위와 같이 Sample Code에서 원하는 언어를 선택하여 가져다가 사용할 수 있다. 우리는 python3으로 주피터 노트북에 옮겨 사용해보았다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">"Inputs"</span>: &#123;</span><br><span class="line">                <span class="string">"input1"</span>:</span><br><span class="line">                [</span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="string">'지점'</span>: <span class="string">"1"</span>,   </span><br><span class="line">                            <span class="string">'날짜'</span>: <span class="string">"2019-11-05T00:00:00z"</span>,   </span><br><span class="line">                            <span class="string">'온도'</span>: <span class="string">"51.31"</span>,   </span><br><span class="line">                            <span class="string">'연료비'</span>: <span class="string">"1.562"</span>,   </span><br><span class="line">                            <span class="string">'소비자물가지수'</span>: <span class="string">"300.0032"</span>,   </span><br><span class="line">                            <span class="string">'실업률'</span>: <span class="string">"6.102"</span>,   </span><br><span class="line">                            <span class="string">'부서'</span>: <span class="string">"11"</span>,   </span><br><span class="line">                            <span class="string">'휴일여부'</span>: <span class="string">"true"</span>,   </span><br><span class="line">                            <span class="string">'유형'</span>: <span class="string">"B"</span>,   </span><br><span class="line">                            <span class="string">'규모'</span>: <span class="string">"21100"</span>,   </span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">"GlobalParameters"</span>:  &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body = str.encode(json.dumps(data))</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://ussouthcentral.services.azureml.net/workspaces/e991e0f1ce3247499498ad7f96dff3c0/services/25abc39d6f6d4c62b1bae93cc13c84e4/execute?api-version=2.0&amp;format=swagger'</span></span><br><span class="line">api_key = <span class="string">'03ttODa2ATC192B0n09d0T0c69vbsz6zStCfAaAex5ZGEAKDKtVEaRxl+gnjnpXUu+WHsub4LI7233fYijLNUw=='</span> <span class="comment"># Replace this with the API key for the web service</span></span><br><span class="line">headers = &#123;<span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>, <span class="string">'Authorization'</span>:(<span class="string">'Bearer '</span>+ api_key)&#125;</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(url, body, headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line"></span><br><span class="line">    result = response.read()</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> error:</span><br><span class="line">    print(<span class="string">"The request failed with status code: "</span> + str(error.code))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print the headers - they include the requert ID and the timestamp, which are useful for debugging the failure</span></span><br><span class="line">    print(error.info())</span><br><span class="line">    print(json.loads(error.read().decode(<span class="string">"utf8"</span>, <span class="string">'ignore'</span>)))</span><br></pre></td></tr></table></figure><p>결과 : b’{“Results”:{“output1”:[{“Scored Labels”:”8219.6923828125”}]}}’</p><p>위와 같은 코드가 나오게되고 먼저 위에서 표시했던 api key를 apikey=”” &lt;&lt; 에 넣어주고 원하는 입력 데이터를 입력한 후 실행을 하게 되면 해당되는 데이터의 예측 값이 리턴되어 출력된다. 이러한 마트 매출액 예측을 이용하면 다음날 매출을 예측하고 예측 데이터가 평소 매출보다 높게 나온다면 직원을 더 출근시키고, 예측 데이터가 적게 나온다면 할인 메시지를 고객들에게 보내는 것 등의 작업이 가능하게 된다.</p><p>어제 만들었던 타이타닉 생존 예측 데이터 또한 위와 같은 과정으로 배포하여보았고 샘플 코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">"Inputs"</span>: &#123;</span><br><span class="line">                <span class="string">"input1"</span>:</span><br><span class="line">                [</span><br><span class="line">                    &#123;</span><br><span class="line">                            <span class="string">'선실등급'</span>: <span class="string">"1"</span>,   </span><br><span class="line">                            <span class="string">'성별'</span>: <span class="string">"female"</span>,   </span><br><span class="line">                            <span class="string">'나이'</span>: <span class="string">"25"</span>,   </span><br><span class="line">                            <span class="string">'형제배우자수'</span>: <span class="string">"2"</span>,   </span><br><span class="line">                            <span class="string">'부모자식수'</span>: <span class="string">"3"</span>,   </span><br><span class="line">                            <span class="string">'요금'</span>: <span class="string">"77"</span>,   </span><br><span class="line">                            <span class="string">'출항지'</span>: <span class="string">"C"</span>,   </span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">"GlobalParameters"</span>:  &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body = str.encode(json.dumps(data))</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://ussouthcentral.services.azureml.net/workspaces/e991e0f1ce3247499498ad7f96dff3c0/services/89edc6fde21540199e28af74c15a5a6a/execute?api-version=2.0&amp;format=swagger'</span></span><br><span class="line">api_key = <span class="string">'aPRcbktBs1ZePedj32JOzkGN2H9BIVC9NTuOPKokhtHpgMTc22QQHpUha7QPSHkFdB+wnPnxwdSRpKPd2o/nHQ=='</span> <span class="comment"># Replace this with the API key for the web service</span></span><br><span class="line">headers = &#123;<span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>, <span class="string">'Authorization'</span>:(<span class="string">'Bearer '</span>+ api_key)&#125;</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(url, body, headers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(req)</span><br><span class="line"></span><br><span class="line">    result = response.read()</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> error:</span><br><span class="line">    print(<span class="string">"The request failed with status code: "</span> + str(error.code))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print the headers - they include the requert ID and the timestamp, which are useful for debugging the failure</span></span><br><span class="line">    print(error.info())</span><br><span class="line">    print(json.loads(error.read().decode(<span class="string">"utf8"</span>, <span class="string">'ignore'</span>)))</span><br></pre></td></tr></table></figure><p>결과 : b’{“Results”:{“output1”:[{“Scored Labels”:”True”,”Scored Probabilities”:”0.827437460422516”}]}}’</p><p>이렇게 ML Studio에서 머신러닝을 수행하면 그 모델을 api화 하여 쉽게 배포하고 활용할 수 있다는 것이 정말 신기했다.</p><p>다음은 파이썬으로 직접 코드를 작성하여 머신러닝을 수행해 보았다.</p><p>첫번째는 간단히 10개의 데이터로 연습하였다. 국가와 나이, 경력, 급여의 컬럼을 가진 데이터이고 국가, 나이, 경력을 feature로 하며 급여를 label로 급여를 예측하는 Regression모델이다.</p><h3 id="2019-11-17-머신러닝-Regression-with-python3-6"><a href="#2019-11-17-머신러닝-Regression-with-python3-6" class="headerlink" title="2019.11.17. 머신러닝 Regression with python3.6"></a>2019.11.17. 머신러닝 Regression with python3.6</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install --upgrade pandas==<span class="number">0.24</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0. Package 가져오기</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">print(pd.__version__)</span><br><span class="line">print(np.__version__)</span><br></pre></td></tr></table></figure><pre><code>0.24.01.17.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.  CSV 데이터 가져오기</span></span><br><span class="line">data = pd.read_csv(<span class="string">'SR_Data.csv'</span>) <span class="comment"># 데이터 읽어오기</span></span><br><span class="line">data.head(<span class="number">10</span>) <span class="comment"># 데이터 앞 10개 출력</span></span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th {    vertical-align: top;}.dataframe thead th {    text-align: right;}</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>Country</th>      <th>Age</th>      <th>Year</th>      <th>Salary</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>France</td>      <td>44.0</td>      <td>15.0</td>      <td>72000</td>    </tr>    <tr>      <th>1</th>      <td>Spain</td>      <td>27.0</td>      <td>3.0</td>      <td>48000</td>    </tr>    <tr>      <th>2</th>      <td>Germany</td>      <td>30.0</td>      <td>2.0</td>      <td>54000</td>    </tr>    <tr>      <th>3</th>      <td>Spain</td>      <td>38.0</td>      <td>NaN</td>      <td>61000</td>    </tr>    <tr>      <th>4</th>      <td>Germany</td>      <td>40.0</td>      <td>10.0</td>      <td>61000</td>    </tr>    <tr>      <th>5</th>      <td>France</td>      <td>35.0</td>      <td>NaN</td>      <td>58000</td>    </tr>    <tr>      <th>6</th>      <td>Spain</td>      <td>NaN</td>      <td>6.0</td>      <td>52000</td>    </tr>    <tr>      <th>7</th>      <td>France</td>      <td>48.0</td>      <td>NaN</td>      <td>79000</td>    </tr>    <tr>      <th>8</th>      <td>Germany</td>      <td>50.0</td>      <td>21.0</td>      <td>83000</td>    </tr>    <tr>      <th>9</th>      <td>France</td>      <td>37.0</td>      <td>7.0</td>      <td>67000</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. feature/label 나누기</span></span><br><span class="line"><span class="comment"># X = data[['Country', 'Age', 'Year']].to_numpy() # Feature : pandas형태를 numpy형태로 변환</span></span><br><span class="line"><span class="comment"># y = data['Salary'].to_numpy # Label : pandas형태를 numpy형태로 변환</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 대부분 다 아래쳐럼 사용</span></span><br><span class="line">X = data.iloc[:, :<span class="number">-1</span>].to_numpy() <span class="comment"># Feature - index location 보통 label이 맨 끝에 있기 때문 (이렇게 많이 사용)</span></span><br><span class="line">y = data.iloc[:, <span class="number">-1</span>].to_numpy() <span class="comment"># Label - 마지막 열을 가져옴</span></span><br><span class="line">print(X)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><pre><code>[[&apos;France&apos; 44.0 15.0] [&apos;Spain&apos; 27.0 3.0] [&apos;Germany&apos; 30.0 2.0] [&apos;Spain&apos; 38.0 nan] [&apos;Germany&apos; 40.0 10.0] [&apos;France&apos; 35.0 nan] [&apos;Spain&apos; nan 6.0] [&apos;France&apos; 48.0 nan] [&apos;Germany&apos; 50.0 21.0] [&apos;France&apos; 37.0 7.0]][72000 48000 54000 61000 61000 58000 52000 79000 83000 67000]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3. Clean Missing Data</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer <span class="comment"># (impute : 대체하다)</span></span><br><span class="line"></span><br><span class="line">imputer = SimpleImputer(missing_values = np.nan, strategy = <span class="string">'mean'</span>) <span class="comment"># missing data를 평균값으로 대체함</span></span><br><span class="line"></span><br><span class="line">imputer.fit(X[:, <span class="number">1</span>:]) <span class="comment"># 설정한 범위 만큼 imputer에 위에 설정한 대로 학습시킴</span></span><br><span class="line">X[:, <span class="number">1</span>:] = imputer.transform(X[:, <span class="number">1</span>:]) <span class="comment"># 학습시킨 imputer를 적용</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X = imputer.fit_transform(X) # 위의 과정을 한번에 처리</span></span><br><span class="line">print(X)</span><br></pre></td></tr></table></figure><pre><code>[[&apos;France&apos; 44.0 15.0] [&apos;Spain&apos; 27.0 3.0] [&apos;Germany&apos; 30.0 2.0] [&apos;Spain&apos; 38.0 9.142857142857142] [&apos;Germany&apos; 40.0 10.0] [&apos;France&apos; 35.0 9.142857142857142] [&apos;Spain&apos; 38.77777777777778 6.0] [&apos;France&apos; 48.0 9.142857142857142] [&apos;Germany&apos; 50.0 21.0] [&apos;France&apos; 37.0 7.0]]</code></pre><h3 id="fit-transform-fit-transform"><a href="#fit-transform-fit-transform" class="headerlink" title="fit(), transform(), fit_transform()"></a>fit(), transform(), fit_transform()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [[<span class="number">2</span>], [nan], [<span class="number">4</span>], [<span class="number">6</span>], [<span class="number">8</span>]]</span><br><span class="line">imputer.fit(x) <span class="comment"># : x데이터로 imputer 학습</span></span><br><span class="line">print(imputer.transform(y))</span><br><span class="line"><span class="comment"># -&gt; [[0], [-1], [1], [5], [5]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imputer.fit(x)</span><br><span class="line">x = imputer.transform(x)</span><br><span class="line"><span class="comment"># 위의 과정을 한번에 처리 (같은 데이터라면 한번에 가능)</span></span><br><span class="line">x = imputer.fit_transform(x)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(X[:, <span class="number">1</span>:])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Make Categorical</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">lebelEncoder = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = lebelEncoder.fit_transform(X[:, <span class="number">0</span>])</span><br><span class="line">print(X)</span><br><span class="line"><span class="comment"># 여기까지만 수행하면 컴퓨터가 0 1 2 순으로 순위를 매겨서 학습함</span></span><br><span class="line"><span class="comment"># 하지만 국가간에 상하관계는 없으므로 아래 과정을 거쳐야함</span></span><br></pre></td></tr></table></figure><pre><code>[[ 0.          1.          0.          0.         44.         15.        ] [ 1.          0.          0.          1.         27.          3.        ] [ 1.          0.          1.          0.         30.          2.        ] [ 1.          0.          0.          1.         38.          9.14285714] [ 1.          0.          1.          0.         40.         10.        ] [ 0.          1.          0.          0.         35.          9.14285714] [ 1.          0.          0.          1.         38.77777778  6.        ] [ 0.          1.          0.          0.         48.          9.14285714] [ 1.          0.          1.          0.         50.         21.        ] [ 0.          1.          0.          0.         37.          7.        ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line">onehotEncoder = OneHotEncoder(categorical_features=[<span class="number">0</span>])</span><br><span class="line">X = onehotEncoder.fit_transform(X).toarray()</span><br><span class="line">print(X)</span><br></pre></td></tr></table></figure><pre><code>[[ 1.          0.          1.          0.          0.         44.  15.        ] [ 0.          1.          0.          0.          1.         27.   3.        ] [ 0.          1.          0.          1.          0.         30.   2.        ] [ 0.          1.          0.          0.          1.         38.   9.14285714] [ 0.          1.          0.          1.          0.         40.  10.        ] [ 1.          0.          1.          0.          0.         35.   9.14285714] [ 0.          1.          0.          0.          1.         38.77777778   6.        ] [ 1.          0.          1.          0.          0.         48.   9.14285714] [ 0.          1.          0.          1.          0.         50.  21.        ] [ 1.          0.          1.          0.          0.         37.   7.        ]]c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\sklearn\preprocessing\_encoders.py:415: FutureWarning: The handling of integer data will change in version 0.22. Currently, the categories are determined based on the range [0, max(values)], while in the future they will be determined based on the unique values.If you want the future behaviour and silence this warning, you can specify &quot;categories=&apos;auto&apos;&quot;.In case you used a LabelEncoder before this OneHotEncoder to convert the categories to integers, then you can now use the OneHotEncoder directly.  warnings.warn(msg, FutureWarning)c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\sklearn\preprocessing\_encoders.py:451: DeprecationWarning: The &apos;categorical_features&apos; keyword is deprecated in version 0.20 and will be removed in 0.22. You can use the ColumnTransformer instead.  &quot;use the ColumnTransformer instead.&quot;, DeprecationWarning)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Make Categorical</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 지금은 이렇게 사용해도 같은 과정임 한번에 가능</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"></span><br><span class="line">ct = ColumnTransformer([(<span class="string">'one_hot_encoder'</span>, OneHotEncoder(), [<span class="number">0</span>])], remainder = <span class="string">'passthrough'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Split Train/Test Set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">123</span>) <span class="comment"># random_state : randomseed와 같음</span></span><br><span class="line"></span><br><span class="line">print(X_train)</span><br></pre></td></tr></table></figure><pre><code>[[ 1.          0.          1.          0.          0.         48.   9.14285714] [ 1.          0.          1.          0.          0.         35.   9.14285714] [ 0.          1.          0.          1.          0.         50.  21.        ] [ 0.          1.          0.          0.          1.         38.   9.14285714] [ 0.          1.          0.          0.          1.         27.   3.        ] [ 0.          1.          0.          0.          1.         38.77777778   6.        ] [ 1.          0.          1.          0.          0.         37.   7.        ] [ 0.          1.          0.          1.          0.         30.   2.        ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Standardization</span></span><br><span class="line"><span class="comment"># 스케일링 작업 MinMaxScaler : 최소 0 최대 1로 변환, StandardScaler : 가장 많이 사용</span></span><br><span class="line"><span class="comment"># y는 어차피 값이 1개이므로 안해도 됨, train과 test는 따로 스케이링 해주어야함</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line"></span><br><span class="line">X_train[:, <span class="number">3</span>:] = scaler.fit_transform(X_train[:, <span class="number">3</span>:])</span><br><span class="line">X_test[:, <span class="number">3</span>:] = scaler.fit_transform(X_test[:, <span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line">print(X_train)</span><br></pre></td></tr></table></figure><pre><code>[[1.         0.         1.         0.         0.         0.91304348  0.37593985] [1.         0.         1.         0.         0.         0.34782609  0.37593985] [0.         1.         0.         1.         0.         1.  1.        ] [0.         1.         0.         0.         1.         0.47826087  0.37593985] [0.         1.         0.         0.         1.         0.  0.05263158] [0.         1.         0.         0.         1.         0.51207729  0.21052632] [1.         0.         1.         0.         0.         0.43478261  0.26315789] [0.         1.         0.         1.         0.         0.13043478  0.        ]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. Train</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decision Tree</span></span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">regressor_tree = DecisionTreeRegressor()</span><br><span class="line">regressor_tree.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><pre><code>DecisionTreeRegressor(criterion=&apos;mse&apos;, max_depth=None, max_features=None,                      max_leaf_nodes=None, min_impurity_decrease=0.0,                      min_impurity_split=None, min_samples_leaf=1,                      min_samples_split=2, min_weight_fraction_leaf=0.0,                      presort=False, random_state=None, splitter=&apos;best&apos;)</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?LinearRegression</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. Predict(Scoring)</span></span><br><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">y_pred_tree = regressor_tree.predict(X_test)</span><br><span class="line">print(y_test)</span><br><span class="line">print(y_pred)</span><br><span class="line">print(y_pred_tree)</span><br></pre></td></tr></table></figure><pre><code>[61000 72000][51245.42658746 83189.03318025][48000. 79000.]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. Evaluate</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error, mean_squared_error</span><br><span class="line">print(mean_absolute_error(y_test, y_pred))</span><br><span class="line">print(mean_squared_error(y_test, y_pred))</span><br><span class="line"></span><br><span class="line">print(mean_absolute_error(y_test, y_pred_tree))</span><br><span class="line">print(mean_squared_error(y_test, y_pred_tree))</span><br></pre></td></tr></table></figure><pre><code>10471.803296395785110173082.9847061510000.0109000000.0</code></pre><p>두번째로는 userID, 성별, 나이, 추정 급여를 feature로 구매 여부를 분류해내는 classification 모델이다. userID는 feature에서 제외시키고 진행한다.</p><h3 id="2019-11-17-머신러닝-with-python3-6"><a href="#2019-11-17-머신러닝-with-python3-6" class="headerlink" title="2019.11.17. 머신러닝 with python3.6"></a>2019.11.17. 머신러닝 with python3.6</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install --upgrade pandas==<span class="number">0.24</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><pre><code>Requirement already up-to-date: pandas==0.24.0 in c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages (0.24.0)Requirement already satisfied, skipping upgrade: pytz&gt;=2011k in c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages (from pandas==0.24.0) (2019.2)Requirement already satisfied, skipping upgrade: numpy&gt;=1.12.0 in c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages (from pandas==0.24.0) (1.17.0)Requirement already satisfied, skipping upgrade: python-dateutil&gt;=2.5.0 in c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages (from pandas==0.24.0) (2.8.0)Requirement already satisfied, skipping upgrade: six&gt;=1.5 in c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages (from python-dateutil&gt;=2.5.0-&gt;pandas==0.24.0) (1.12.0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0. Package 가져오기</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">print(pd.__version__)</span><br><span class="line">print(np.__version__)</span><br></pre></td></tr></table></figure><pre><code>0.24.01.17.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.  CSV 데이터 가져오기</span></span><br><span class="line">data = pd.read_csv(<span class="string">'Social_Network_Ads.csv'</span>)</span><br><span class="line">data.head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }<pre><code>.dataframe tbody tr th {    vertical-align: top;}.dataframe thead th {    text-align: right;}</code></pre><p></style><p></p><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>User ID</th>      <th>Gender</th>      <th>Age</th>      <th>EstimatedSalary</th>      <th>Purchased</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>15624510</td>      <td>Male</td>      <td>19.0</td>      <td>19000.0</td>      <td>0</td>    </tr>    <tr>      <th>1</th>      <td>15810944</td>      <td>Male</td>      <td>35.0</td>      <td>20000.0</td>      <td>0</td>    </tr>    <tr>      <th>2</th>      <td>15668575</td>      <td>Female</td>      <td>26.0</td>      <td>NaN</td>      <td>0</td>    </tr>    <tr>      <th>3</th>      <td>15603246</td>      <td>Female</td>      <td>27.0</td>      <td>57000.0</td>      <td>0</td>    </tr>    <tr>      <th>4</th>      <td>15804002</td>      <td>Male</td>      <td>NaN</td>      <td>76000.0</td>      <td>0</td>    </tr>    <tr>      <th>5</th>      <td>15728773</td>      <td>Male</td>      <td>27.0</td>      <td>58000.0</td>      <td>0</td>    </tr>    <tr>      <th>6</th>      <td>15598044</td>      <td>NaN</td>      <td>27.0</td>      <td>84000.0</td>      <td>0</td>    </tr>    <tr>      <th>7</th>      <td>15694829</td>      <td>Female</td>      <td>32.0</td>      <td>150000.0</td>      <td>1</td>    </tr>    <tr>      <th>8</th>      <td>15600575</td>      <td>Male</td>      <td>25.0</td>      <td>33000.0</td>      <td>0</td>    </tr>    <tr>      <th>9</th>      <td>15727311</td>      <td>Female</td>      <td>35.0</td>      <td>65000.0</td>      <td>0</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2. feature/label 나누기</span></span><br><span class="line">X = data.iloc[:, <span class="number">1</span>:<span class="number">4</span>].values</span><br><span class="line">y = data.iloc[:, <span class="number">-1</span>].values</span><br><span class="line"></span><br><span class="line">print(X.shape)</span><br><span class="line">print(y.shape)</span><br></pre></td></tr></table></figure><pre><code>(400, 3)(400,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-1. Clean Missing Data-number</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imputer_number = SimpleImputer(missing_values=np.nan, strategy=<span class="string">'mean'</span>) <span class="comment"># 숫자 데이터부터 평균값으로 대체하여 줌</span></span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">4</span>] = imputer_number.fit_transform(X[:, <span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">print(pd.DataFrame(X))</span><br></pre></td></tr></table></figure><pre><code>          0    1        20      Male   19    190001      Male   35    200002    Female   26  69628.93    Female   27    570004      Male  NaN    760005      Male   27    580006       NaN   27    840007    Female   32   1500008      Male   25    330009    Female   35    6500010   Female   26    8000011   Female   26    5200012     Male  NaN    8600013     Male   32    1800014     Male   18    8200015     Male   29    8000016     Male   47  69628.917     Male   45    2600018     Male   46    2800019   Female   48    2900020     Male   45    2200021   Female   47    4900022     Male   48    4100023   Female   45    2200024     Male   46    2300025     Male   47  69628.926     Male   49    2800027   Female   47    3000028     Male   29    4300029     Male   31    18000..      ...  ...      ...370  Female   60    46000371    Male   60    83000372  Female   39    73000373    Male   59   130000374  Female   37  69628.9375  Female   46    32000376  Female   46    74000377  Female   42    53000378    Male   41    87000379  Female   58    23000380    Male   42    64000381    Male   48    33000382  Female   44   139000383    Male   49    28000384  Female   57    33000385    Male   56    60000386  Female   49    39000387    Male   39    71000388    Male   47    34000389  Female   48    35000390     NaN   48    33000391    Male   47    23000392  Female   45    45000393    Male   60    42000394  Female   39    59000395  Female   46    41000396    Male   51    23000397  Female   50    20000398    Male   36    33000399  Female   49    36000[400 rows x 3 columns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-2. Clean Missing Data-category</span></span><br><span class="line">imputer_category = SimpleImputer(missing_values=np.nan, strategy=<span class="string">'most_frequent'</span>) <span class="comment"># 가장 빈도가 높은 데이터로 대체</span></span><br><span class="line">X[:, :] = imputer_category.fit_transform(X[:, :])</span><br><span class="line"></span><br><span class="line">print(pd.DataFrame(X))</span><br></pre></td></tr></table></figure><pre><code>          0   1        20      Male  19    190001      Male  35    200002    Female  26  69628.93    Female  27    570004      Male  35    760005      Male  27    580006    Female  27    840007    Female  32   1500008      Male  25    330009    Female  35    6500010   Female  26    8000011   Female  26    5200012     Male  35    8600013     Male  32    1800014     Male  18    8200015     Male  29    8000016     Male  47  69628.917     Male  45    2600018     Male  46    2800019   Female  48    2900020     Male  45    2200021   Female  47    4900022     Male  48    4100023   Female  45    2200024     Male  46    2300025     Male  47  69628.926     Male  49    2800027   Female  47    3000028     Male  29    4300029     Male  31    18000..      ...  ..      ...370  Female  60    46000371    Male  60    83000372  Female  39    73000373    Male  59   130000374  Female  37  69628.9375  Female  46    32000376  Female  46    74000377  Female  42    53000378    Male  41    87000379  Female  58    23000380    Male  42    64000381    Male  48    33000382  Female  44   139000383    Male  49    28000384  Female  57    33000385    Male  56    60000386  Female  49    39000387    Male  39    71000388    Male  47    34000389  Female  48    35000390  Female  48    33000391    Male  47    23000392  Female  45    45000393    Male  60    42000394  Female  39    59000395  Female  46    41000396    Male  51    23000397  Female  50    20000398    Male  36    33000399  Female  49    36000[400 rows x 3 columns]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4. Make Categorical</span></span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line">ct = ColumnTransformer([(<span class="string">'one_hot_encoder'</span>, OneHotEncoder(),[<span class="number">0</span>])], remainder=<span class="string">'passthrough'</span>)</span><br><span class="line">X = ct.fit_transform(X).astype(float)</span><br><span class="line"></span><br><span class="line">print(X)</span><br></pre></td></tr></table></figure><pre><code>[[0.0000000e+00 1.0000000e+00 1.9000000e+01 1.9000000e+04] [0.0000000e+00 1.0000000e+00 3.5000000e+01 2.0000000e+04] [1.0000000e+00 0.0000000e+00 2.6000000e+01 6.9628866e+04] ... [1.0000000e+00 0.0000000e+00 5.0000000e+01 2.0000000e+04] [0.0000000e+00 1.0000000e+00 3.6000000e+01 3.3000000e+04] [1.0000000e+00 0.0000000e+00 4.9000000e+01 3.6000000e+04]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5. Split Train/Test Set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">9</span>) <span class="comment"># random_state : randomseed</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"X_train:"</span>, X_train.shape)</span><br><span class="line">print(<span class="string">"y_train:"</span>, y_train.shape)</span><br><span class="line">print(<span class="string">"X_test:"</span>, X_test.shape)</span><br><span class="line">print(<span class="string">"y_test:"</span>, y_test.shape)</span><br></pre></td></tr></table></figure><pre><code>X_train: (320, 4)y_train: (320,)X_test: (80, 4)y_test: (80,)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 6. Standardization</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train[:, <span class="number">3</span>:] = sc.fit_transform(X_train[:, <span class="number">3</span>:])</span><br><span class="line">X_test[:, <span class="number">3</span>:] = sc.fit_transform(X_test[:, <span class="number">3</span>:])</span><br><span class="line"></span><br><span class="line">print(X_train)</span><br></pre></td></tr></table></figure><pre><code>[[ 1.00000000e+00  0.00000000e+00  2.80000000e+01  4.24335352e-01] [ 0.00000000e+00  1.00000000e+00  2.10000000e+01  6.30659849e-02] [ 1.00000000e+00  0.00000000e+00  3.90000000e+01  3.29602043e-02] ... [ 0.00000000e+00  1.00000000e+00  4.20000000e+01 -1.47674479e-01] [ 0.00000000e+00  1.00000000e+00  3.90000000e+01  2.13594888e-01] [ 1.00000000e+00  0.00000000e+00  4.40000000e+01  2.08015329e+00]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7. Train</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">classifier = LogisticRegression()</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><pre><code>c:\users\kyu93\appdata\local\programs\python\python37\lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to &apos;lbfgs&apos; in 0.22. Specify a solver to silence this warning.  FutureWarning)LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,                   intercept_scaling=1, l1_ratio=None, max_iter=100,                   multi_class=&apos;warn&apos;, n_jobs=None, penalty=&apos;l2&apos;,                   random_state=None, solver=&apos;warn&apos;, tol=0.0001, verbose=0,                   warm_start=False)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from sklearn import svm</span></span><br><span class="line"><span class="comment"># classifier_svm = svm.SVC(gamma='scale')</span></span><br><span class="line"><span class="comment"># classifier_svm.fit(X_train, y_train)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8. Predict(Scoring)</span></span><br><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line"><span class="comment"># y_pred2=classifier_svm.predict(X_test)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 9. Evaluate</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line">print(accuracy_score(y_test, y_pred))</span><br><span class="line"><span class="comment"># print(accuracy_score(y_test, y_pred2))</span></span><br></pre></td></tr></table></figure><pre><code>0.875</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10. ConfusionMatrix</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="comment"># cm2 = confusion_matrix(y_test, y_pred2)</span></span><br><span class="line"></span><br><span class="line">print(cm)</span><br><span class="line"><span class="comment"># print(cm2)</span></span><br></pre></td></tr></table></figure><pre><code>[[46  2] [ 8 24]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 11. ConfusionMatrix Visualize</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sn</span><br><span class="line"></span><br><span class="line">df_cm = pd.DataFrame(cm, index = [<span class="string">'true'</span>, <span class="string">'false'</span>],</span><br><span class="line">                    columns = [<span class="string">'true'</span>, <span class="string">'false'</span>])</span><br><span class="line">plt.figure(figsize = (<span class="number">10</span>,<span class="number">7</span>))</span><br><span class="line">sn.heatmap(df_cm, annot=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><div style="width: 70%; height: 450px;">    <img src="https://kyu9341.github.io/img/output_15_1.png" style="width: 90%    ; height: 450px;"></div><p>이렇게 2일간의 ICT멘토링 머신러닝 기초교육이 마무리되었다. 내 주말을 모두 뺏겨버렸지만 아깝지 않게 많은 것을 얻어가는 것 같다. 기본적인 머신러닝의 이론부터 활용 분야, 알고리즘 등 몰랐거나 애매하게 알았던 부분을 제대로 알게 되었고 Azure ML Studio에서 실습을 통해 머신러닝의 workflow를 직접 경험해 볼 수 있었다. 배포까지 해보면서 실제로 머신러닝을 사용한다면 어떠한 방식으로 구현을 해야할 것 같다는 생각도 해볼 수 있었고 또한 파이썬으로 주피터에서 직접 코드도 작성해보며 ML Studio에서 진행했던 흐름을 실제 코드로는 어떻게 작성되는지도 보았다. 앞으로 계속해서 머신러닝을 공부할 것인데 그 기반을 잘 잡게된 것 같아 기분이 좋다. 다음주에 있는 딥러닝 교육도 참가해 리뷰해볼 예정이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에는 둘째 날에 배웠던 내용에 대해 리뷰해보도록 하겠다. 둘째 날은 Regression모델, 머신러닝 알고리즘, python라이브러리인 scikit-learn을 이용하여 실습을 진행하였다.&lt;/p&gt;
&lt;p&gt;오전에는 어제 했던 Classificat
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://kyu9341.github.io/categories/MachineLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>ICT멘토링 머신러닝 교육 1일차</title>
    <link href="https://kyu9341.github.io/MachineLearning/2019/11/16/marchinelearning1/"/>
    <id>https://kyu9341.github.io/MachineLearning/2019/11/16/marchinelearning1/</id>
    <published>2019-11-16T12:09:22.000Z</published>
    <updated>2019-12-27T06:40:43.114Z</updated>
    
    <content type="html"><![CDATA[<p>이번에 한이음에서 주최하는 ICT멘토링 MS AI머신러닝(기초)교육에 참여하게 되었다. 토일 10:00 ~ 18:00까지 2일에 걸쳐서 진행되는데 첫째 날에는 인공지능 개론/사례, 머신러닝 이론, Classification모델에 대해서 배웠다. 이번 포스팅에서는 첫째 날 배운 내용에 대해 리뷰해보도록 하겠다.</p><h2 id="인공지능이란"><a href="#인공지능이란" class="headerlink" title="인공지능이란?"></a>인공지능이란?</h2><p>기계를 인간과 비슷하게 동작하게 하는 기술이다. 인간이 사고하는 과정처럼 인식(보고, 듣고) -&gt; 이해(학습, 분석) -&gt; 반응(결과)의 순으로 진행이된다.</p><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/ai1.png" style="width: 100%    ; height: 300px;"></div><ul><li><p>인공지능 : 기계 혹은 컴퓨터가 인간의 지능을 모방해 인간과 비슷하게 동작하도록 만들어진 기술</p></li><li><p>머신러닝 : 인공지능의 한 분야. 컴퓨터가 데이터를 이용해 학습하는 알고리즘 기술(input 과 output을 보고 중간에 어떤 일이 일어나는지 파악하는 것)<br>ex) 인공신경망, 결정 트리, 벡터 머신 등</p></li><li><p>딥러닝 : 인공신경망을 사용하는 머신러닝 모델링 방법 중 하나(Neural Network)<br>다층 인공신경망 구조를 사용하여 빅 데이터 학습</p></li></ul><p>ex) 사물인식, 감정분석, 필기체 인식, 음성인식 등</p><h2 id="머신러닝의-종류"><a href="#머신러닝의-종류" class="headerlink" title="머신러닝의 종류"></a>머신러닝의 종류</h2><p>머신러닝은 크게 3가지로 분류를 할 수 있다.</p><ul><li><p>Supervised Learning(지도학습, 감독학습)</p><ul><li>문제와 함께 정답을 제공(Feature &amp; Label)</li><li>예측(Regression), 추정(Forecast), 분류(Classification) 등의 문제 해결 시 주로 사용</li><li>만들기 쉽고, 성능도 좋음</li></ul></li><li><p>Unsupervised Learning (비지도학습)</p><ul><li>문제만 제공 (Feature)</li><li>패턴/구조 발견 (Anomaly Detection) : 평소와 다른 점 발견 (이상감지) ex) 지진, 의료 등 이상 징후 감지</li><li>그룹화 (Clustering) : 여러 데이터를 input, 알아서 비슷한 것들을 모아줌</li></ul></li><li><p>Reinforcement Learning (강화 학습)</p><ul><li>정답이 아닌 보상 제공</li><li>인과관계가 중요</li><li>게임(알파고), 로봇</li><li>사람의 움직임을 따라 움직이는 아바타</li></ul></li></ul><h3 id="Overfitting-과적합"><a href="#Overfitting-과적합" class="headerlink" title="Overfitting(과적합)"></a>Overfitting(과적합)</h3><p>Overfitting은 학습이 너무 잘 되어서 학습데이터에 대해서는 높은 정확도를 나타내지만 테스트 데이터나 실제 적용시에는 성능이 떨어지는 현상을 말한다.</p><div style="width: 100%; height: 300px;">    <img src="https://kyu9341.github.io/img/ai2.png" style="width: 100%    ; height: 300px;"></div>위의 그림처럼 너무 학습 데이터에 대해서만 정확도가 높아 다른 실제 데이터에 대해서는 정확도가 떨어지는 경우가 있는데 학습 데이터가 실제 데이터를 충분히 반영하지 못했을 경우가 그렇다. 이러한 Overfitting을 해결하는 방법으로는 더 많은 학습 데이터를 수집는 것과 Feature의 개수를 줄이는 것, 그리고 정규화를 하는 방법 등이 있다. 정규화는 데이터를 구분하는 선이 구불구불해지지 않게 막아주는 역할을 한다.<h3 id="머신러닝의-workflow"><a href="#머신러닝의-workflow" class="headerlink" title="머신러닝의 workflow"></a>머신러닝의 workflow</h3><p>일반적인 머신러닝의 작업순서는 다음과 같다.</p><ol><li>문제 정의</li><li>데이터 셋 준비(전처리)</li><li>모델 설정</li><li>모델 훈련 / 평가</li><li>모델 활용</li></ol><p>먼저 해결해야할 문제를 정의한다. 그리고 그에 필요한 데이터 셋을 수집하고 학습시키기 위해 전처리 과정을 거친다. 이후 적합한 알고리즘을 선택하여 모델을 설정하고 데이터 셋을 학습 데이터와 테스트 데이터로 나누어 훈련을 시키고 테스트를 하여 훈련이 잘 되었다면 모델을 이용하여 필요한 곳에 사용하면 된다.</p><h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><p>첫째 날의 실습 환경은 MS의 클라우드 서비스인 Azure를 사용한 Azure ML Studio를 사용했다.</p><p>Azure ML Studio는 코드를 따로 작성하지 않고 머신러닝의 각 과정을 모듈화하고 데이터 시각화 또한 잘 되어있어 처음 머신러닝을 배울 때 쉽게 이해할 수 있다.</p><p>실습해보았던 문제는 타이타닉 탑승객의 데이터 셋을 이용하여 생존 여부를 예측하는 것이다. 탑승객이 살았거나 죽었거나의 두가지로 나누어지므로 2진 분류 문제이고 Supervised Learning에 Classification에 속한다.</p><p>진행과정은 다음과 같다.</p><h4 id="Data-Processing"><a href="#Data-Processing" class="headerlink" title="Data Processing"></a>Data Processing</h4><p>Feature Selection – Feature Metadata Edit – Clean Missing data – data split</p><div style="width: 100%; height: 450px;">    <img src="https://kyu9341.github.io/img/machine4.png" style="width: 40%    ; height: 450px;"></div>먼저 데이터 셋을 가져오고 각 컬럼을 확인하여 생존 여부와 관계가 없는 데이터는 컬럼에서 제외시켜준다.<div style="width: 100%; height: 500px;">    <img src="https://kyu9341.github.io/img/machine3.png" style="width: 100%    ; height: 500px;"></div>위와 같이 탑승객의 이름 같은 경우는 생존 여부와 관련이 전혀 없으므로 제외시켜준다. 이때, Unique value가 전체 데이터 수와 근접하고 string형인 경우는 학습에 도움이 되지 않는 경우가 많다.<div style="width: 100%; height: 500px;">    <img src="https://kyu9341.github.io/img/machine2.png" style="width: 100%    ; height: 500px;"></div><p>위와 그림은 관계가 없다고 생각하는 데이터들을 제외하고 남은 데이터들이다.</p><p>이후 각 데이터 별로 지정된 값만 입력을 받을 데이터에는 Make Categorical을 적용해주고 생존 여부 같은 경우는 데이터 타입을 boolean타입으로 변경하고 label로 지정을 해준다.</p><p>다음은 Clean Missing data 과정인데 Missing Data를 삭제하거나 다른 데이터로 대체하여 학습을 수행하도록 하는 과정이다. 이 과정에서는 탑승객의 나이같은 경우는 평균값으로 데이터를 채워주고 성별 같은 숫자형이 아닌 데이터들은 가장 많은 빈도를 가지는 데이터로 대체하여 채워주었다.</p><p>다음 Data Split과정은 데이터 셋을 약 7<del>80%의 비율은 Training Data Set로 나머지 2</del>30%는 Test Data Set로 나누어 학습시키게 된다. 이 때, Random Split을 해주어야 하는데 만약 데이터가 정렬되어 있는 경우 아래쪽의 30%를 테스트 데이터로 사용한다면 정확한 결과를 얻기 힘들기 때문에 random seed를 적용하여 랜덤한 테스트 셋을 추출하게 된다. 또한 이 과정에서 Stratified Split도 적용하였는데 Startified Split란 예를 들어 성별에 적용한다면 18명 중 6명을 추출하는 경우 일반적으로는 남여 관계없이 6명을 선택하지만 이 경우 남자 3명 여자 3명을 추출하는 식으로 치우치지 않은 테스트 셋을 추출할 수 있게 된다.</p><h4 id="Train-Model"><a href="#Train-Model" class="headerlink" title="Train Model"></a>Train Model</h4><p>Initialize - Train Model - Score Model - Evaluate - Deploy</p><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/machine5.png" style="width: 80%    ; height: 350px;"></div><p>모델을 학습시키는 단계에서는 먼저 어떠한 알고리즘으로 학습을 시킬지 생각해야 한다. 알고리즘의 선택 기준으로는 정확도(Accuracy), 훈련 시간(Train Time), 선형성(Linearity), Parameter, Feature 등이 있다. 여러가지 요소를 잘 고려하여 선택해야 한다.</p><p>여기서는 2진 분류 알고리즘 중 하나인 Two-Class Boosted Decision Tree라는 모델을 사용하여 학습을 시켰다. 아래는 Training set을 이용하여 학습을 시키고 Score Model 단계에서 Test set으로 테스트를 한 결과이다.</p><div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/machine6.png" style="width: 80%    ; height: 350px;"></div>Scored Labels가 학습된 데이터로 나온 결과이며 좌측의 생존 여부와 비교하여 모델이 정답을 맞추었는지 아닌지 확인해 볼 수 있다. Scored Probabilities 는 정답일 확률이며 0.5가 넘어가면 True 아니면 False로 결과가 나온다.<div style="width: 100%; height: 350px;">    <img src="https://kyu9341.github.io/img/machine7.png" style="width: 80%    ; height: 350px;"></div><p>마지막으로 Evaluate Model 단계인데 학습된 모델이 얼마나 정확하게 Test set을 맞추었는지 평가할 수 있다. 보통 Accuracy를 가장 중요하게 보면 되는데 각각의 값들은 아래의 식을 따른다.</p><p>Accuracy : TP + TN / TP+ FP +FN + TN<br>Precision : TP / TP + FP<br>Recall : TP / TP + FN</p><p>어느 분야에 활용되느냐에 따라 중요하게 보아야 할 값이 달라지게 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번에 한이음에서 주최하는 ICT멘토링 MS AI머신러닝(기초)교육에 참여하게 되었다. 토일 10:00 ~ 18:00까지 2일에 걸쳐서 진행되는데 첫째 날에는 인공지능 개론/사례, 머신러닝 이론, Classification모델에 대해서 배웠다. 
      
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://kyu9341.github.io/categories/MachineLearning/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - Negative, Mosaic</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/12/ImageProcessing2/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/12/ImageProcessing2/</id>
    <published>2019-11-12T03:07:54.000Z</published>
    <updated>2019-12-27T06:40:31.795Z</updated>
    
    <content type="html"><![CDATA[<div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/ImageProcessing6.png" style="width: 512px    ; height: 512px;"></div><p>저번 포스팅에서 위와 같이 레나 영상을 띄우는 것 까지 해보았다. 이번 포스팅부터는 여러 이미지에 대해 다양한 효과를 적용시키고 가공하는 방법에 대해 다루어볼 것이다. 우리는 그레이 스케일의 0~255 까지의 값을 가지는 이미지만 활용할 것이다.</p><h2 id="Negative-반전-효과"><a href="#Negative-반전-효과" class="headerlink" title="Negative(반전 효과)"></a>Negative(반전 효과)</h2><p>먼저 첫번째로는 가장 기본적인 이미지 반전 효과를 주는 것에 대해 알아보겠다.</p><p>이미지를 반전시키는 방법은 간단하다. 이미지는 0~255의 값을 가지는데 각 픽셀의 가지는 값들을 모두 255에서 빼주면 된다. 다음 코드를 보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Negative</span><span class="params">(uchar** img, uchar** Result, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col)</span> <span class="comment">// Nagative 효과 넣기 (반전)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j++)</span><br><span class="line">Result[i][j] = <span class="number">255</span> - img[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이미지를 반전시켜주는 즉, Negative효과를 주는 함수이다. 입력 이미지의 각 값들을 255에서 빼서 결과 이미지에 넣어주면 된다. 이러한 과정을 거쳐 lena이미지를 처리하면 다음과 같은 결과가 나오게 된다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/Negative.png" style="width: 512px    ; height: 512px;"></div><p>위와 같이 이미지가 반전되어 출력되는 것을 확인할 수 있다.</p><h2 id="Mosaic-모자이크"><a href="#Mosaic-모자이크" class="headerlink" title="Mosaic(모자이크)"></a>Mosaic(모자이크)</h2><p>다음은 이미지에 모자이크 효과를 주는 방법을 알아보겠다.</p><p>모자이크는 먼저 모자이크 블록의 크기를 입력받아 그 크기만큼 증가하며 이미지의 한 블록 내의 값들의 평균을 내어 그 블록의 값을 모두 평균값으로 바꿔주면 된다. 아래의 코드를 보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mosaic</span><span class="params">(uchar** img, uchar** out, <span class="keyword">int</span> Row, <span class="keyword">int</span> Col, <span class="keyword">int</span> Block)</span> <span class="comment">// 이미지 모자이크 처리</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, x, y, tmp, count;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Row; i += Block) <span class="comment">// 입력 받은 블록 크기만큼 증가하며 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Col; j += Block)</span><br><span class="line">&#123;</span><br><span class="line">tmp = <span class="number">0</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; Block; y++) <span class="comment">// 블록 크기만큼 반복</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; Block; x++) &#123;</span><br><span class="line">tmp += img[i + y][j + x]; <span class="comment">// uchar형에서는 0~255 값밖에 처리 못하므로 정수형 변수에 각 픽셀값을 누적</span></span><br><span class="line">count++; <span class="comment">// 몇번 누적했는지 측정</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tmp /= count; <span class="comment">// 블록 내의 평균을 구함</span></span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; Block; y++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; Block; x++) &#123;</span><br><span class="line">out[i + y][j + x] = tmp; <span class="comment">// 해당 블록의 각 위치에 모두 평균값을 대입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 구현할 수 있으며 다음 이미지는 lena를 각각 블록 크기를 8, 16으로 하여 모자이크 처리를 한 이미지이다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/mosaic8.png" style="width: 512px    ; height: 512px;"></div><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/mosaic16.png" style="width: 512px    ; height: 512px;"></div><p>위와 같이 지정한 블록 크기에 따라 모자이크의 정도가 달라지는 것을 볼 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;width: 512px; height: 512px;&quot;&gt;
    &lt;img src=&quot;https://kyu9341.github.io/img/ImageProcessing6.png&quot; style=&quot;width: 512px
    ; heigh
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>디지털 영상처리 - 개발환경 구축</title>
    <link href="https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/11/ImageProcessing1/"/>
    <id>https://kyu9341.github.io/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/2019/11/11/ImageProcessing1/</id>
    <published>2019-11-11T14:09:13.000Z</published>
    <updated>2019-12-31T06:30:37.705Z</updated>
    
    <content type="html"><![CDATA[<p>이번 학기에 배우고 있는 과목인 디지털 영상처리를 리뷰해보겠다. 원래는 영상처리를 블로그에 리뷰할지 말지 고민을 했었는데 점점 재미있고 더 깊이 알아보고 싶어서 앞으로 지금까지 해왔던 과정이나 앞으로 진행하는 과정을 하나씩 리뷰해볼 생각이다.</p><p>우선 교수님이 이 수업의 목적은 C 프로그래밍 능력 향상이라 하셨다. 그 목적에 맞게 영상을 보기 위한 프로그램은 OpenCV를 사용하며 그 외의 소스는 순수하게 C언어 코드로만 영상처리를 수행한다.</p><p>이번 포스팅에서는 간단히 작업 환경 설정과 영상처리의 대표 이미지인 레나이미지를 띄워보는 것 까지 진행해보겠다.</p><p>작업 환경은 윈도우의 비쥬얼 스튜디오에서 진행하며 OpenCV 3.4.1 버전을 사용한다.</p><p>다운로드 주소 : <a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.4.1/opencv-3.4.1-vc14_vc15.exe/download" target="_blank" rel="external nofollow noopener noreferrer">https://sourceforge.net/projects/opencvlibrary/files/opencv-win/3.4.1/opencv-3.4.1-vc14_vc15.exe/download</a></p><p>원하는 경로에 다운로드를 받고 환경변수를 설정해주도록 한다. 경로는 opencv\build\x64\vc15\bin와 같고 앞에 자신이 저장한 폴더의 경로를 추가하면 된다.</p><p>다음으로는 프로젝트를 생성하고 프로젝트 이름을 opencv라고 하겠다. 이후 프로젝트를 우클릭하여 속성으로 이동해 다음과 같이 설정을 변경한다.</p><div style="width: 100%; height: 500px;">    <img src="https://kyu9341.github.io/img/ImageProcessing1.png" style="width: 100%    ; height: 500px;"></div><p>위에 표시된 부분을 확인하고 구성의 Debug와 Release를 각각 선택하여 플랫폼을 x64로 설정한다. 모든 설정은 Debug와 Release모두 설정해주도록 한다.</p><p>다음은 링커의 일반에서 다음과 같이 설정한다.</p><div style="width: 100%; height: 500px;">    <img src="https://kyu9341.github.io/img/ImageProcessing2.png" style="width: 100%    ; height: 500px;"></div><p>이 후 링커의 입력 부분으로 가서 추가 종속성에 오른쪽 끝의 화살표를 누르면 편집(Edit)이 뜨고 편집화면에 Debug인 경우 opencv_world341d.lib를 입력하고 적용을 누르며 Release인 경우 opencv_world341.lib를 입력하고 적용을 해준다.</p><div style="width: 100%; height: 500px;">    <img src="https://kyu9341.github.io/img/ImageProcessing3.png" style="width: 100%    ; height: 500px;"></div><p>위의 사진이 340인 이유는 내가 OpenCV 3.4.0버전을 받았기 때문이다. 별 차이는 없으니 이어서 진행하자.</p><p>마지막으로 VC++디렉터리 오른쪽의 포함 디렉토리에 아래와 같이 include디렉토리와 라이브러리 디렉토리를 설정해준다.</p><div style="width: 100%; height: 500px;">    <img src="https://kyu9341.github.io/img/ImageProcessing4.png" style="width: 100%    ; height: 500px;"></div><p>아래 프로그램은 C언어로 Raw Image를 화면에 띄우는 프로그램이다. OpenCV를 이용하였고 앞으로 이미지를 띄울 때 이 프로그램을 계속해서 사용할 것이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv\cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv\highgui.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv\cxcore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uchar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define unsigned char uchar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>** <span class="title">uc_alloc</span><span class="params">(<span class="keyword">int</span> size_x, <span class="keyword">int</span> size_y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>** m;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((m = (<span class="keyword">unsigned</span> <span class="keyword">char</span>**)<span class="built_in">calloc</span>(size_y, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uc_alloc error 1\7\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_y; i++)</span><br><span class="line"><span class="keyword">if</span> ((m[i] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">calloc</span>(size_x, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"uc_alloc error 2\7\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_ucmartrix</span><span class="params">(<span class="keyword">int</span> size_x, <span class="keyword">int</span> size_y, <span class="keyword">unsigned</span> <span class="keyword">char</span>** ucmatrix, <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">FILE* f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fopen_s(&amp;f, filename, <span class="string">"rb"</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s File open Error!\n"</span>, filename);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_y; i++)</span><br><span class="line"><span class="keyword">if</span> (fread(ucmatrix[i], <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>), size_x, f) != size_x) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"data read error \n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_ucmatrix</span><span class="params">(<span class="keyword">int</span> size_x, <span class="keyword">int</span> size_y, <span class="keyword">unsigned</span> <span class="keyword">char</span>** ucmatrix, <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">FILE* f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fopen_s(&amp;f, filename, <span class="string">"wb"</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s File open Error!\n"</span>, filename);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size_y; i++)</span><br><span class="line"><span class="keyword">if</span> (fread(ucmatrix[i], <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>), size_x, f) != size_x) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"data read error \n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fclose(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">IplImage* cvImg;</span><br><span class="line">CvSize imgSize;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>** img;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"exe imgdata xsie ysize \n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imgSize.<span class="built_in">width</span> = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">imgSize.<span class="built_in">height</span> = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">img = uc_alloc(imgSize.<span class="built_in">width</span>, imgSize.<span class="built_in">height</span>);</span><br><span class="line">read_ucmartrix(imgSize.<span class="built_in">width</span>, imgSize.<span class="built_in">height</span>, img, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">cvImg = cvCreateImage(imgSize, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; imgSize.<span class="built_in">height</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; imgSize.<span class="built_in">width</span>; j++) &#123;</span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)(cvImg-&gt;imageData + cvImg-&gt;widthStep * i))[j] = img[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvNamedWindow(argv[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">cvShowImage(argv[<span class="number">1</span>], cvImg);</span><br><span class="line"></span><br><span class="line">cvWaitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cvDestroyWindow(<span class="string">"image"</span>);</span><br><span class="line">cvReleaseImage(&amp;cvImg);</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>프로그램은 위에서 설정한 opencv.cpp에서 작성한 것이며 윈도우의 cmd를 아래와 같이 실행시킨다.</p><p>자신의 opencv.exe 실행파일이 있는 곳으로 가서</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/ImageProcessing5.png" style="width: 100%    ; height: 400px;"></div><p>위와 같이 실행파일 영상의 세로축크기 영상의 가로축 크기 순으로 입력하여 프로그램을 동작시키면 아래와 같이 이미지가 출력된다.</p><div style="width: 512px; height: 512px;">    <img src="https://kyu9341.github.io/img/ImageProcessing6.png" style="width: 512px    ; height: 512px;"></div><p>위와 같이 레나 영상이 잘 출력이 된 것을 확인할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이번 학기에 배우고 있는 과목인 디지털 영상처리를 리뷰해보겠다. 원래는 영상처리를 블로그에 리뷰할지 말지 고민을 했었는데 점점 재미있고 더 깊이 알아보고 싶어서 앞으로 지금까지 해왔던 과정이나 앞으로 진행하는 과정을 하나씩 리뷰해볼 생각이다.&lt;/
      
    
    </summary>
    
    
      <category term="영상처리" scheme="https://kyu9341.github.io/categories/%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC/"/>
    
    
  </entry>
  
  <entry>
    <title>파이썬 소켓 통신</title>
    <link href="https://kyu9341.github.io/python/2019/11/10/python7/"/>
    <id>https://kyu9341.github.io/python/2019/11/10/python7/</id>
    <published>2019-11-10T13:45:42.000Z</published>
    <updated>2019-12-27T06:40:23.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="파이썬-소켓-통신"><a href="#파이썬-소켓-통신" class="headerlink" title="파이썬 소켓 통신"></a>파이썬 소켓 통신</h2><p>이번 한이음 공모전에서 서버로 Django를 사용하고 있는데 안드로이드와 유니티 사이에 리모컨과 같은 통신 기능을 구현하기 위해 안드로이드와 장고 사이에는 기존에 사용하던 http통신을 유지하고 장고와 유니티(C#)간의 통신을 소켓을 이용하여 구현해보기로 하였다.</p><p>이전에 공개S/W개발자 대회에서 안드로이드와 라즈베리파이간의 통신을 구현할 때는 Polling방식을 통해 라즈베리파이가 지속적으로 서버에 요청을 보내 데이터베이스 값을 읽어 변화한 값이 있는 경우 그에 따른 동작을 수행하도록 구현하였었고 이번에 파이썬을 통해 소켓을 처음 사용해보기 때문에 간단히 공부한 내용을 리뷰해보자.</p><h3 id="소켓이란"><a href="#소켓이란" class="headerlink" title="소켓이란?"></a>소켓이란?</h3><p>소켓은 네트워크 상에서 돌아가는 두 개의 프로그램 간 양방향 통신의 하나의 엔드포인트이다. 소켓은 포트 번호에 바인딩되어 TCP레이어에서 데이터가 전달되어야 하는 어플리케이션을 식별할 수 있게 한다.</p><h4 id="엔드-포인트"><a href="#엔드-포인트" class="headerlink" title="엔드 포인트"></a>엔드 포인트</h4><p>여기서 엔드 포인트란 아이피 주소와 포트번호의 조합을 의미한다. 모든 TCP연결은 2개의 엔드 포인트로 유일하게 식별되어질 수 있다. 따라서 클라이언트와 서버 간 여러 개의 연결이 맺어질 수도 있다.</p><h4 id="소켓-객체"><a href="#소켓-객체" class="headerlink" title="소켓 객체"></a>소켓 객체</h4><ul><li>socket() 함수는 첫 번째 인자로 Address Family(AF)와 Socket Type(Enum형태의 Int값)을 받는다.</li><li>socket() 함수 인자 Address Family와 Socket Type의 기본값은 각각 AF_INET, SOCKET_STREAM이다.</li><li>아래부터는 이해를 돕기 위해 서버 소켓(요청 수신 및 응답)과 클라이언트 소켓(요청 송신)으로 나누어 설명한다.</li></ul><h3 id="서버-소켓"><a href="#서버-소켓" class="headerlink" title="서버 소켓"></a>서버 소켓</h3><ul><li>예시로 서버 소켓은 대기 소켓(수신 소켓)과 실제 통신을 담당하는 소켓(응답 소켓 또는 반환 소켓)으로 설정한다.</li><li>서버 소켓은 연결 요청을 대기하다가 연결을 수락하는 경우 새로운 Socket 객체를 반환한다.</li><li>실제 외부와의 통신은 여기서 반환된 새로운 Socket객체를 통해 통신한다.</li></ul><h4 id="socket-bind-address-소켓-맵핑"><a href="#socket-bind-address-소켓-맵핑" class="headerlink" title="socket.bind(address) - 소켓 맵핑"></a>socket.bind(address) - 소켓 맵핑</h4><ul><li>생성한 소켓에 고유한 호스트와 포트를 매핑한다.</li><li>인자로 address(호스트와 포트 정보)를 튜플 형태로 전달받는다. ex) socket.bind(HOST, PORT)</li><li>Socket 객체(프로그램 인터페이스)에 고유한 네트워크 IP자원(호스트와 포트)를 맵핑함으로써 프로그램 인터페이스와 네트워크 지원을 연결시킨다.</li></ul><h4 id="socket-listen-연결-요청-대기-상태-설정"><a href="#socket-listen-연결-요청-대기-상태-설정" class="headerlink" title="socket.listen() - 연결 요청 대기 상태 설정"></a>socket.listen() - 연결 요청 대기 상태 설정</h4><ul><li>소켓은 생성된 이후 연결 요청 대기를 한 이후에만 연결이 가능하므로 소켓 맵핑 후에는 반드시 연결 요청 대기 상태를 설정해야 한다.</li><li>연결 대기 상태는 오로지 대기(listen)만 할 뿐 실제 연결이 성립되면 새로운 소켓을 반환한다.</li></ul><h4 id="socket-accept-연결-승낙-후-실제-통신-소켓-반환"><a href="#socket-accept-연결-승낙-후-실제-통신-소켓-반환" class="headerlink" title="socket.accept() - 연결 승낙 후 실제 통신 소켓 반환"></a>socket.accept() - 연결 승낙 후 실제 통신 소켓 반환</h4><ul><li>연결 요청 대기 중인 소켓은 socket.accept()를 사용하여 연결을 승낙하고 연결이 성립된 새로운 소켓과 주소정보를 반환한다.</li><li>실제 외부와의 통신은 여기서 생성된 새로운 소켓을 이용한다.</li></ul><h4 id="socket-close-연결-요청-대기-종료"><a href="#socket-close-연결-요청-대기-종료" class="headerlink" title="socket.close() - 연결 요청 대기 종료"></a>socket.close() - 연결 요청 대기 종료</h4><ul><li>socket.close()를 사용할 경우 해당 소켓은 종료된다.</li></ul><h3 id="클라이언트-소켓"><a href="#클라이언트-소켓" class="headerlink" title="클라이언트 소켓"></a>클라이언트 소켓</h3><ul><li>클라이언트 소켓은 서버 소켓과 달리 오로지 클라이언트 소켓 하나로 구성된다.</li></ul><h4 id="socket-connect-address-서버-소켓에-연결-요청"><a href="#socket-connect-address-서버-소켓에-연결-요청" class="headerlink" title="socket.connect(address) - 서버 소켓에 연결 요청"></a>socket.connect(address) - 서버 소켓에 연결 요청</h4><ul><li>socket.connect()를 사용하여 서버 소켓에 연결 요청을 보낸다.</li><li>인자로 address(연결할 소켓의 호스트와 포트 정보)를 튜플 형태로 전달 받는다.</li><li>파이썬 3.5버전 이후에는 연결이 종료된 경우 InterruptedError에러나 socket.timeout 없이 대기 상태로 전환된다.</li></ul><h3 id="서버-소켓과-클라이언트-소켓의-통신"><a href="#서버-소켓과-클라이언트-소켓의-통신" class="headerlink" title="서버 소켓과 클라이언트 소켓의 통신"></a>서버 소켓과 클라이언트 소켓의 통신</h3><p>서버 소켓과 클라이언트 소켓 간 데이터 송수신을 설명한다.</p><h4 id="socket-send-byte-socket-sendall-byte-데이터-송신"><a href="#socket-send-byte-socket-sendall-byte-데이터-송신" class="headerlink" title="socket.send(byte), socket.sendall(byte) - 데이터 송신"></a>socket.send(byte), socket.sendall(byte) - 데이터 송신</h4><ul><li>클라이언트 소켓에서 서버 소켓으로 데이터를 전송할 때는 socket.send() 혹은 socket.sendall()을 이용한다.</li><li>인자인 byte는 송신할 데이터를 의미한다.</li><li>socket.send()와 socket.sendall()은 기본적으로 같은 역할을 하지만 sendall()의 경우는 전송이 완료된 데이터의 바이트 수를 리턴한다.</li></ul><h4 id="socket-recv-bufsize-데이터-수신"><a href="#socket-recv-bufsize-데이터-수신" class="headerlink" title="socket.recv(bufsize) - 데이터 수신"></a>socket.recv(bufsize) - 데이터 수신</h4><ul><li>데이터를 수신할 때 사용되며 수신한 데이터(바이트 객체)를 반환한다.</li><li>인자인 bufsize는 한 번에 수신할 수 있는 최대 데이터 크기를 의미한다.</li></ul><h3 id="통신-예제"><a href="#통신-예제" class="headerlink" title="통신 예제"></a>통신 예제</h3><p>통신을 위해 server에 해당하는 파일과 client에 해당하는 2개의 파이썬 파일을 작성한다.</p><ul><li>server.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> select <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">10000</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, PORT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소켓 생성</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소켓 주소 정보 할당</span></span><br><span class="line">serverSocket.bind(ADDR)</span><br><span class="line">print(<span class="string">'bind'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 연결 수신 대기 상태</span></span><br><span class="line">serverSocket.listen(<span class="number">100</span>)</span><br><span class="line">print(<span class="string">'listen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 연결 수락</span></span><br><span class="line">clientSocekt, addr_info = serverSocket.accept()</span><br><span class="line">print(<span class="string">'accept'</span>)</span><br><span class="line">print(<span class="string">'--client information--'</span>)</span><br><span class="line">print(clientSocekt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 클라이언트로부터 메시지를 가져옴</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = clientSocekt.recv(<span class="number">65535</span>)</span><br><span class="line">    print(<span class="string">'recieve data : '</span>,data.decode())</span><br><span class="line">    msg = data.decode()</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'exit'</span>: <span class="comment"># exit라는 메세지를 받으면 종료</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소켓 종료</span></span><br><span class="line">clientSocekt.close()</span><br><span class="line">serverSocket.close()</span><br><span class="line">print(<span class="string">'close'</span>)</span><br></pre></td></tr></table></figure><ul><li>client.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> select <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">10000</span></span><br><span class="line">BUFSIZE = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line"></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># 서버에 접속하기 위한 소켓을 생성한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    clientSocket.connect(ADDR)  <span class="comment"># 서버에 접속을 시도한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>  Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'%s:%s'</span> % ADDR)</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'connect is success'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sendData = input(<span class="string">"input data : "</span>)</span><br><span class="line">    clientSocket.send(sendData.encode())</span><br></pre></td></tr></table></figure><p>로컬에서 서버에 데이터를 계속해서 보내고 서버는 받은 데이터를 출력하며 exit라는 문자열을 받으면 종료하도록 구성하였다. 간단하게 실행 화면을 보자.</p><p>cmd에서 해당 파일의 위치로 이동하여 python server.py 로 먼저 서버 파일을 실행하고 클라이언트 파일을 실행하여 데이터를 송수신한다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/socket1.png" style="width: 100%    ; height: 400px;"></div><p>위는 서버의 실행화면이고 클라이언트측에서 보낸 데이터를 출력하는 것을 볼 수 있다.</p><div style="width: 100%; height: 400px;">    <img src="https://kyu9341.github.io/img/socket2.png" style="width: 100%    ; height: 400px;"></div><p>위는 클라이언트 실행화면이고 데이터를 전송하는 모습을 볼 수 있다.</p><p>추가로 조금 정리하자면 파이썬에서 다른 언어로 된 소켓 서버에 전송하는 경우 그 언어가 읽어들이는 방식에 따라 라인을 단위로 읽어들이는 경우 아래와 같이 개행문자를 추가로 붙여서 인코딩하여 보내주면 문제가 해결될 수 있다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendData = input(<span class="string">"input data : "</span>) + <span class="string">"\n"</span></span><br><span class="line">clientSocket.send(sendData.encode())</span><br></pre></td></tr></table></figure><p><strong>참조</strong></p><p> <a href="https://m.blog.naver.com/nonamed0000/221259426463" target="_blank" rel="external nofollow noopener noreferrer">https://m.blog.naver.com/nonamed0000/221259426463</a></p><p> <a href="https://djangoworld.tistory.com/12" target="_blank" rel="external nofollow noopener noreferrer">https://djangoworld.tistory.com/12</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;파이썬-소켓-통신&quot;&gt;&lt;a href=&quot;#파이썬-소켓-통신&quot; class=&quot;headerlink&quot; title=&quot;파이썬 소켓 통신&quot;&gt;&lt;/a&gt;파이썬 소켓 통신&lt;/h2&gt;&lt;p&gt;이번 한이음 공모전에서 서버로 Django를 사용하고 있는데 안드로이드와 유
      
    
    </summary>
    
    
      <category term="python" scheme="https://kyu9341.github.io/categories/python/"/>
    
    
  </entry>
  
</feed>
